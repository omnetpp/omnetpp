<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>OMNeT++ - Manual</TITLE>
   <META NAME="Author" CONTENT="Andras Varga">
</HEAD>

<style type="text/css">
body,th,td,p,ul,ol,li,h1,h2,h3,h4 {font-family:arial,sans-serif }
body,td,p,ul,ol,li { font-size:11pt }
th,td { font-size:10pt; }

h1 {color: #006f00;}
h2 {color: #006f00;}
h3 {color: #006f00;}
pre { margin-left:8pt; background:#fffff4; padding:5pt; border:1px solid; border-color:#a0a0a0 }
table {background:#fffff4; margin-left:8pt; border-collapse:collapse; border: 2px solid}
td,th {text-align:left; vertical-align:top; border:1px solid; padding:3pt; border-color:#000000}
.subheading {color: black; font-weight: bold;}
a {text-decoration: none;}
a:visited {text-decoration: none;}
# a:hover {text-decoration: underline;}
</style>

<BODY TEXT="#000000" BGCOLOR="#FFFFE8" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<br>
<img src="omnetpp.png" border="0">
<!--
<h1><FONT COLOR="#FF0000"><B><FONT SIZE=+4>OMNeT++ </FONT></B>
<I><FONT SIZE=+1>Discrete Event Simulation System</FONT></I></FONT></h1>
-->

<H1><B>User Manual</B></H1><H3>OMNeT++ version 4.0</H3><H1>Chapters</H1>
<p>
<B><A HREF="#toc_1" class="toc">1 Introduction</A></B><BR>
<B><A HREF="#toc_2" class="toc">2 Overview</A></B><BR>
<B><A HREF="#toc_3" class="toc">3 The NED Language</A></B><BR>
<B><A HREF="#toc_4" class="toc">4 Simple Modules</A></B><BR>
<B><A HREF="#toc_5" class="toc">5 Messages</A></B><BR>
<B><A HREF="#toc_6" class="toc">6 The Simulation Library</A></B><BR>
<B><A HREF="#toc_7" class="toc">7 Building Simulation Programs</A></B><BR>
<B><A HREF="#toc_8" class="toc">8 Configuring and Running Simulations</A></B><BR>
<B><A HREF="#toc_9" class="toc">9 Network Graphics And Animation</A></B><BR>
<B><A HREF="#toc_10" class="toc">10 Analyzing Simulation Results</A></B><BR>
<B><A HREF="#toc_11" class="toc">11 Eventlog</A></B><BR>
<B><A HREF="#toc_12" class="toc">12 Documenting NED and Messages</A></B><BR>
<B><A HREF="#toc_13" class="toc">13 Parallel Distributed Simulation</A></B><BR>
<B><A HREF="#toc_14" class="toc">14 Customization and Embedding</A></B><BR>
<B><A HREF="#toc_15" class="toc">15 NED Reference</A></B><BR>
<B><A HREF="#toc_16" class="toc">16 NED Language Grammar</A></B><BR>
<B><A HREF="#toc_17" class="toc">17 NED XML Binding</A></B><BR>
<B><A HREF="#toc_18" class="toc">18 NED Functions</A></B><BR>
<B><A HREF="#toc_19" class="toc">19 Message Definitions Grammar</A></B><BR>
<B><A HREF="#toc_20" class="toc">20 Display String Tags</A></B><BR>
<B><A HREF="#toc_21" class="toc">21 Configuration Options</A></B><BR>
<B><A HREF="#toc_22" class="toc">22 Result File Formats</A></B><BR>
<B><A HREF="#toc_23" class="toc">23 Eventlog File Format</A></B><BR>
</p><HR><H1>Table of Contents</H1>
<p>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_1"/><A HREF="#sec100" class="toc">1 Introduction</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.1"/><A HREF="#sec101" class="toc">1.1 What is OMNeT++?</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.2"/><A HREF="#sec102" class="toc">1.2 Organization of this manual</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.3"/><A HREF="#sec103" class="toc">1.3 Credits</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_2"/><A HREF="#sec104" class="toc">2 Overview</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1"/><A HREF="#sec105" class="toc">2.1 Modeling concepts</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.1"/><A HREF="#sec106" class="toc">2.1.1 Hierarchical modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.2"/><A HREF="#sec107" class="toc">2.1.2 Module types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.3"/><A HREF="#sec108" class="toc">2.1.3 Messages, gates, links</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.4"/><A HREF="#sec109" class="toc">2.1.4 Modeling of packet transmissions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.5"/><A HREF="#sec110" class="toc">2.1.5 Parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.6"/><A HREF="#sec111" class="toc">2.1.6 Topology description method</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2"/><A HREF="#sec112" class="toc">2.2 Programming the algorithms</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3"/><A HREF="#sec113" class="toc">2.3 Using OMNeT++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3.1"/><A HREF="#sec114" class="toc">2.3.1 Building and running simulations</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3.2"/><A HREF="#sec115" class="toc">2.3.2 What is in the distribution</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_3"/><A HREF="#sec116" class="toc">3 The NED Language</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.1"/><A HREF="#sec117" class="toc">3.1 NED overview</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.2"/><A HREF="#sec118" class="toc">3.2 NED files</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.3"/><A HREF="#sec119" class="toc">3.3 Simple modules</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.4"/><A HREF="#sec120" class="toc">3.4 Channels</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5"/><A HREF="#sec121" class="toc">3.5 Compound modules</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.1"/><A HREF="#sec122" class="toc">3.5.1 Compound module parameters and gates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.2"/><A HREF="#sec123" class="toc">3.5.2 Submodules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.3"/><A HREF="#sec124" class="toc">3.5.3 Assigning values to submodule parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.4"/><A HREF="#sec125" class="toc">3.5.4 Defining sizes of submodule gate vectors</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.5.5"/><A HREF="#sec126" class="toc">3.5.5 Connections</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.6"/><A HREF="#sec127" class="toc">3.6 Networks</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.7"/><A HREF="#sec128" class="toc">3.7 Inheritance</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8"/><A HREF="#sec129" class="toc">3.8 Packages</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8.1"/><A HREF="#sec130" class="toc">3.8.1 Packages, imports</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8.2"/><A HREF="#sec131" class="toc">3.8.2 Directory Structure, package.ned</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8.3"/><A HREF="#sec132" class="toc">3.8.3 Name lookups</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8.4"/><A HREF="#sec133" class="toc">3.8.4 The NEDPATH environment variable</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8.5"/><A HREF="#sec134" class="toc">3.8.5 OMNeT++ Projects in Eclipse</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.8.6"/><A HREF="#sec135" class="toc">3.8.6 Cross-Project Dependencies</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.9"/><A HREF="#sec136" class="toc">3.9 Inner types</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.10"/><A HREF="#sec137" class="toc">3.10 Interfaces</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.11"/><A HREF="#sec138" class="toc">3.11 Metadata annotations</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.12"/><A HREF="#sec139" class="toc">3.12 Parameters</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.12.1"/><A HREF="#sec140" class="toc">3.12.1 Random parameters and const</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.12.2"/><A HREF="#sec141" class="toc">3.12.2 XML parameters</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.13"/><A HREF="#sec142" class="toc">3.13 Gates</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.14"/><A HREF="#sec143" class="toc">3.14 Expressions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.14.1"/><A HREF="#sec144" class="toc">3.14.1 Defining new functions</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.15"/><A HREF="#sec145" class="toc">3.15 Submodule type as parameter</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.16"/><A HREF="#sec146" class="toc">3.16 Parameterized compound modules</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.16.1"/><A HREF="#sec147" class="toc">3.16.1 Examples</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.16.2"/><A HREF="#sec148" class="toc">3.16.2 Design patterns for compound modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.16.3"/><A HREF="#sec149" class="toc">3.16.3 Topology templates</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.17"/><A HREF="#sec150" class="toc">3.17 Large networks</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.17.1"/><A HREF="#sec151" class="toc">3.17.1 Generating NED files</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.17.2"/><A HREF="#sec152" class="toc">3.17.2 Building the network from C++ code</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.18"/><A HREF="#sec153" class="toc">3.18 XML binding for NED files</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_4"/><A HREF="#sec154" class="toc">4 Simple Modules</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1"/><A HREF="#sec155" class="toc">4.1 Simulation concepts</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.1"/><A HREF="#sec156" class="toc">4.1.1 Discrete Event Simulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.2"/><A HREF="#sec157" class="toc">4.1.2 The event loop</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.3"/><A HREF="#sec158" class="toc">4.1.3 Simple modules in OMNeT++</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.4"/><A HREF="#sec159" class="toc">4.1.4 Events in OMNeT++</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.5"/><A HREF="#sec160" class="toc">4.1.5 Simulation time</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.6"/><A HREF="#sec161" class="toc">4.1.6 FES implementation</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.2"/><A HREF="#sec162" class="toc">4.2 Packet transmission modeling</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.2.1"/><A HREF="#sec163" class="toc">4.2.1 Delay, bit error rate, data rate</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.2.2"/><A HREF="#sec164" class="toc">4.2.2 Multiple transmissions on links</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3"/><A HREF="#sec165" class="toc">4.3 Defining simple module types</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.1"/><A HREF="#sec166" class="toc">4.3.1 Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.2"/><A HREF="#sec167" class="toc">4.3.2 Constructor</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.3"/><A HREF="#sec168" class="toc">4.3.3 Constructor and destructor vs initialize() and finish()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.4"/><A HREF="#sec169" class="toc">4.3.4 "Garbage collection" and compatibility</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.5"/><A HREF="#sec170" class="toc">4.3.5 An example</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3.6"/><A HREF="#sec171" class="toc">4.3.6 Using global variables</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4"/><A HREF="#sec172" class="toc">4.4 Adding functionality to cSimpleModule</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.1"/><A HREF="#sec173" class="toc">4.4.1 handleMessage()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.2"/><A HREF="#sec174" class="toc">4.4.2 activity()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.3"/><A HREF="#sec175" class="toc">4.4.3 initialize() and finish()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.4"/><A HREF="#sec176" class="toc">4.4.4 handleParameterChange()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.5"/><A HREF="#sec177" class="toc">4.4.5 Reusing module code via subclassing</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5"/><A HREF="#sec178" class="toc">4.5 Finite State Machines in OMNeT++</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6"/><A HREF="#sec179" class="toc">4.6 Sending and receiving messages</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.1"/><A HREF="#sec180" class="toc">4.6.1 Sending messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.2"/><A HREF="#sec181" class="toc">4.6.2 Broadcasts and retransmissions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.3"/><A HREF="#sec182" class="toc">4.6.3 Delayed sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.4"/><A HREF="#sec183" class="toc">4.6.4 Direct message sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.5"/><A HREF="#sec184" class="toc">4.6.5 Receiving messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.6"/><A HREF="#sec185" class="toc">4.6.6 The wait() function</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.7"/><A HREF="#sec186" class="toc">4.6.7 Modeling events using self-messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.8"/><A HREF="#sec187" class="toc">4.6.8 Stopping the simulation</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7"/><A HREF="#sec188" class="toc">4.7 Accessing module parameters</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7.1"/><A HREF="#sec189" class="toc">4.7.1 Emulating parameter arrays</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8"/><A HREF="#sec190" class="toc">4.8 Accessing gates and connections</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.1"/><A HREF="#sec191" class="toc">4.8.1 Gate objects</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.2"/><A HREF="#sec192" class="toc">4.8.2 Connection parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.3"/><A HREF="#sec193" class="toc">4.8.3 Transmission state</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.4"/><A HREF="#sec194" class="toc">4.8.4 Connectivity</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9"/><A HREF="#sec195" class="toc">4.9 Walking the module hierarchy</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.10"/><A HREF="#sec196" class="toc">4.10 Direct method calls between modules</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11"/><A HREF="#sec197" class="toc">4.11 Dynamic module creation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.1"/><A HREF="#sec198" class="toc">4.11.1 When do you need dynamic module creation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.2"/><A HREF="#sec199" class="toc">4.11.2 Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.3"/><A HREF="#sec200" class="toc">4.11.3 Creating modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.4"/><A HREF="#sec201" class="toc">4.11.4 Deleting modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.5"/><A HREF="#sec202" class="toc">4.11.5 Module deletion and finish()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.6"/><A HREF="#sec203" class="toc">4.11.6 Creating connections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11.7"/><A HREF="#sec204" class="toc">4.11.7 Removing connections</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_5"/><A HREF="#sec205" class="toc">5 Messages</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1"/><A HREF="#sec206" class="toc">5.1 Messages and packets</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.1"/><A HREF="#sec207" class="toc">5.1.1 The cMessage class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.2"/><A HREF="#sec208" class="toc">5.1.2 Self-messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.3"/><A HREF="#sec209" class="toc">5.1.3 Modelling packets</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.4"/><A HREF="#sec210" class="toc">5.1.4 Encapsulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.5"/><A HREF="#sec211" class="toc">5.1.5 Attaching parameters and objects</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2"/><A HREF="#sec212" class="toc">5.2 Message definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.1"/><A HREF="#sec213" class="toc">5.2.1 Introduction</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.2"/><A HREF="#sec214" class="toc">5.2.2 Declaring enums</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.3"/><A HREF="#sec215" class="toc">5.2.3 Message declarations</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.4"/><A HREF="#sec216" class="toc">5.2.4 Inheritance, composition</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.5"/><A HREF="#sec217" class="toc">5.2.5 Using existing C++ types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.6"/><A HREF="#sec218" class="toc">5.2.6 Customizing the generated class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.7"/><A HREF="#sec219" class="toc">5.2.7 Using STL in message classes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.8"/><A HREF="#sec220" class="toc">5.2.8 Summary</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.9"/><A HREF="#sec221" class="toc">5.2.9 What else is there in the generated code?</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_6"/><A HREF="#sec222" class="toc">6 The Simulation Library</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1"/><A HREF="#sec223" class="toc">6.1 Class library conventions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.1"/><A HREF="#sec224" class="toc">6.1.1 Base class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.2"/><A HREF="#sec225" class="toc">6.1.2 Setting and getting attributes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.3"/><A HREF="#sec226" class="toc">6.1.3 className()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.4"/><A HREF="#sec227" class="toc">6.1.4 Name attribute</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.5"/><A HREF="#sec228" class="toc">6.1.5 fullName() and fullPath()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.6"/><A HREF="#sec229" class="toc">6.1.6 Copying and duplicating objects</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.7"/><A HREF="#sec230" class="toc">6.1.7 Iterators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.8"/><A HREF="#sec231" class="toc">6.1.8 Error handling</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2"/><A HREF="#sec232" class="toc">6.2 Logging from modules</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.3"/><A HREF="#sec233" class="toc">6.3 Simulation time conversion</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4"/><A HREF="#sec234" class="toc">6.4 Generating random numbers</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.1"/><A HREF="#sec235" class="toc">6.4.1 Random number generators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.2"/><A HREF="#sec236" class="toc">6.4.2 Random number streams, RNG mapping</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.3"/><A HREF="#sec237" class="toc">6.4.3 Accessing the RNGs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.4"/><A HREF="#sec238" class="toc">6.4.4 Random variates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.5"/><A HREF="#sec239" class="toc">6.4.5 Random numbers from histograms</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.5"/><A HREF="#sec240" class="toc">6.5 Container classes</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.5.1"/><A HREF="#sec241" class="toc">6.5.1 Queue class: cQueue</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.5.2"/><A HREF="#sec242" class="toc">6.5.2 Expandable array: cArray</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.6"/><A HREF="#sec243" class="toc">6.6 The parameter class: cPar</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.6.1"/><A HREF="#sec244" class="toc">6.6.1 Reading the value</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.6.2"/><A HREF="#sec245" class="toc">6.6.2 Changing the value</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.6.3"/><A HREF="#sec246" class="toc">6.6.3 cPar storage types</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.7"/><A HREF="#sec247" class="toc">6.7 Routing support: cTopology</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.7.1"/><A HREF="#sec248" class="toc">6.7.1 Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.7.2"/><A HREF="#sec249" class="toc">6.7.2 Basic usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.7.3"/><A HREF="#sec250" class="toc">6.7.3 Shortest paths</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8"/><A HREF="#sec251" class="toc">6.8 Statistics and distribution estimation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.1"/><A HREF="#sec252" class="toc">6.8.1 cStatistic and descendants</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.2"/><A HREF="#sec253" class="toc">6.8.2 Distribution estimation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.3"/><A HREF="#sec254" class="toc">6.8.3 The k-split algorithm</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.4"/><A HREF="#sec255" class="toc">6.8.4 Transient detection and result accuracy</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9"/><A HREF="#sec256" class="toc">6.9 Recording simulation results</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9.1"/><A HREF="#sec257" class="toc">6.9.1 Output vectors: cOutVector</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9.2"/><A HREF="#sec258" class="toc">6.9.2 Output scalars</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9.3"/><A HREF="#sec259" class="toc">6.9.3 Precision</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10"/><A HREF="#sec260" class="toc">6.10 Watches and snapshots</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.1"/><A HREF="#sec261" class="toc">6.10.1 Basic watches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.2"/><A HREF="#sec262" class="toc">6.10.2 Read-write watches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.3"/><A HREF="#sec263" class="toc">6.10.3 Structured watches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.4"/><A HREF="#sec264" class="toc">6.10.4 STL watches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.5"/><A HREF="#sec265" class="toc">6.10.5 Snapshots</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.6"/><A HREF="#sec266" class="toc">6.10.6 Breakpoints</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.7"/><A HREF="#sec267" class="toc">6.10.7 Getting coroutine stack usage</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11"/><A HREF="#sec268" class="toc">6.11 Deriving new classes</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11.1"/><A HREF="#sec269" class="toc">6.11.1 cOwnedObject or not?</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11.2"/><A HREF="#sec270" class="toc">6.11.2 cOwnedObject virtual methods</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11.3"/><A HREF="#sec271" class="toc">6.11.3 Class registration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11.4"/><A HREF="#sec272" class="toc">6.11.4 Details</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12"/><A HREF="#sec273" class="toc">6.12 Object ownership management</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.1"/><A HREF="#sec274" class="toc">6.12.1 The ownership tree</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.2"/><A HREF="#sec275" class="toc">6.12.2 Managing ownership</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_7"/><A HREF="#sec276" class="toc">7 Building Simulation Programs</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.1"/><A HREF="#sec277" class="toc">7.1 Overview</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2"/><A HREF="#sec278" class="toc">7.2 Using Unix and gcc</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2.1"/><A HREF="#sec279" class="toc">7.2.1 Installation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2.2"/><A HREF="#sec280" class="toc">7.2.2 Building simulation models</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2.3"/><A HREF="#sec281" class="toc">7.2.3 Multi-directory models</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2.4"/><A HREF="#sec282" class="toc">7.2.4 Static vs shared OMNeT++ system libraries</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3"/><A HREF="#sec283" class="toc">7.3 Using Windows and Microsoft Visual C++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.1"/><A HREF="#sec284" class="toc">7.3.1 Installation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.2"/><A HREF="#sec285" class="toc">7.3.2 Building simulation models on the command line</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.3"/><A HREF="#sec286" class="toc">7.3.3 Building simulation models from the MSVC IDE</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_8"/><A HREF="#sec287" class="toc">8 Configuring and Running Simulations</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.1"/><A HREF="#sec288" class="toc">8.1 Configuring simulations</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2"/><A HREF="#sec289" class="toc">8.2 The configuration file: omnetpp.ini</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.1"/><A HREF="#sec290" class="toc">8.2.1 An example</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.2"/><A HREF="#sec291" class="toc">8.2.2 The concept of simulation runs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.3"/><A HREF="#sec292" class="toc">8.2.3 File syntax</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.4"/><A HREF="#sec293" class="toc">8.2.4 File inclusion</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3"/><A HREF="#sec294" class="toc">8.3 Sections</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3.1"/><A HREF="#sec295" class="toc">8.3.1 Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3.2"/><A HREF="#sec296" class="toc">8.3.2 Fallbacks</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.4"/><A HREF="#sec297" class="toc">8.4 Scenarios</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.4.1"/><A HREF="#sec298" class="toc">8.4.1 Basic use</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.4.2"/><A HREF="#sec299" class="toc">8.4.2 Named iteration variables</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.4.3"/><A HREF="#sec300" class="toc">8.4.3 Repeating runs with different seeds</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.5"/><A HREF="#sec301" class="toc">8.5 Scenarios and Result Analysis</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.5.1"/><A HREF="#sec302" class="toc">8.5.1 Output vectors and scalars</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.5.2"/><A HREF="#sec303" class="toc">8.5.2 Saving parameters as scalars</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.5.3"/><A HREF="#sec304" class="toc">8.5.3 Experiment-Measurement-Replication</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.6"/><A HREF="#sec305" class="toc">8.6 User interfaces</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.6.1"/><A HREF="#sec306" class="toc">8.6.1 The [General] section</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.7"/><A HREF="#sec307" class="toc">8.7 Setting module parameters in omnetpp.ini</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.7.1"/><A HREF="#sec308" class="toc">8.7.1 Using wildcard patterns</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.7.2"/><A HREF="#sec309" class="toc">8.7.2 Applying the defaults</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.8"/><A HREF="#sec310" class="toc">8.8 Configuring output vectors</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9"/><A HREF="#sec311" class="toc">8.9 Configuring the random number generators</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9.1"/><A HREF="#sec312" class="toc">8.9.1 Number of RNGs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9.2"/><A HREF="#sec313" class="toc">8.9.2 RNG choice</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9.3"/><A HREF="#sec314" class="toc">8.9.3 RNG mapping</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9.4"/><A HREF="#sec315" class="toc">8.9.4 Automatic seed selection</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9.5"/><A HREF="#sec316" class="toc">8.9.5 Manual seed configuration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.9.6"/><A HREF="#sec317" class="toc">8.9.6 Choosing good seed values: the seedtool utility</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.10"/><A HREF="#sec318" class="toc">8.10 Cmdenv: the command-line interface</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.10.1"/><A HREF="#sec319" class="toc">8.10.1 Command-line switches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.10.2"/><A HREF="#sec320" class="toc">8.10.2 Cmdenv ini file options</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.10.3"/><A HREF="#sec321" class="toc">8.10.3 Interpreting Cmdenv output</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.11"/><A HREF="#sec322" class="toc">8.11 Tkenv: the graphical user interface</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.11.1"/><A HREF="#sec323" class="toc">8.11.1 Command-line switches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.11.2"/><A HREF="#sec324" class="toc">8.11.2 In Memoriam... </A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.12"/><A HREF="#sec325" class="toc">8.12 Repeating or iterating simulation runs</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.12.1"/><A HREF="#sec326" class="toc">8.12.1 Executing several runs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.12.2"/><A HREF="#sec327" class="toc">8.12.2 Variations over parameter values</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.12.3"/><A HREF="#sec328" class="toc">8.12.3 Variations over seed value (multiple independent runs)</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.13"/><A HREF="#sec329" class="toc">8.13 Akaroa support: Multiple Replications in Parallel</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.13.1"/><A HREF="#sec330" class="toc">8.13.1 Introduction</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.13.2"/><A HREF="#sec331" class="toc">8.13.2 What is Akaroa</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.13.3"/><A HREF="#sec332" class="toc">8.13.3 Using Akaroa with OMNeT++</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.14"/><A HREF="#sec333" class="toc">8.14 Typical issues</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.14.1"/><A HREF="#sec334" class="toc">8.14.1 Stack problems</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.14.2"/><A HREF="#sec335" class="toc">8.14.2 Memory leaks and crashes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.14.3"/><A HREF="#sec336" class="toc">8.14.3 Simulation executes slowly</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_9"/><A HREF="#sec337" class="toc">9 Network Graphics And Animation</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1"/><A HREF="#sec338" class="toc">9.1 Display strings</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1.1"/><A HREF="#sec339" class="toc">9.1.1 Display string syntax</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1.2"/><A HREF="#sec340" class="toc">9.1.2 Submodule display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1.3"/><A HREF="#sec341" class="toc">9.1.3 Background display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1.4"/><A HREF="#sec342" class="toc">9.1.4 Connection display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1.5"/><A HREF="#sec343" class="toc">9.1.5 Message display strings</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2"/><A HREF="#sec344" class="toc">9.2 Colors</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.1"/><A HREF="#sec345" class="toc">9.2.1 Color names</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.2"/><A HREF="#sec346" class="toc">9.2.2 Icon colorization</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3"/><A HREF="#sec347" class="toc">9.3 The icons</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3.1"/><A HREF="#sec348" class="toc">9.3.1 The image path</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3.2"/><A HREF="#sec349" class="toc">9.3.2 Categorized icons</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3.3"/><A HREF="#sec350" class="toc">9.3.3 Icon size</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.4"/><A HREF="#sec351" class="toc">9.4 Layouting</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5"/><A HREF="#sec352" class="toc">9.5 Enhancing animation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5.1"/><A HREF="#sec353" class="toc">9.5.1 Changing display strings at runtime</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5.2"/><A HREF="#sec354" class="toc">9.5.2 Bubbles</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_10"/><A HREF="#sec355" class="toc">10 Analyzing Simulation Results</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1"/><A HREF="#sec356" class="toc">10.1 Output vectors</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1.1"/><A HREF="#sec357" class="toc">10.1.1 Plotting output vectors with Plove</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1.2"/><A HREF="#sec358" class="toc">10.1.2 Format of output vector files</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1.3"/><A HREF="#sec359" class="toc">10.1.3 Working without Plove</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2"/><A HREF="#sec360" class="toc">10.2 Scalar statistics</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2.1"/><A HREF="#sec361" class="toc">10.2.1 Format of output scalar files</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2.2"/><A HREF="#sec362" class="toc">10.2.2 The Scalars tool</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3"/><A HREF="#sec363" class="toc">10.3 Analysis and visualization tools</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.1"/><A HREF="#sec364" class="toc">10.3.1 Grace</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.2"/><A HREF="#sec365" class="toc">10.3.2 ROOT</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.3"/><A HREF="#sec366" class="toc">10.3.3 Gnuplot</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_11"/><A HREF="#sec367" class="toc">11 Eventlog</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.1"/><A HREF="#sec368" class="toc">11.1 Introduction</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2"/><A HREF="#sec369" class="toc">11.2 Configuration</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.1"/><A HREF="#sec370" class="toc">11.2.1 File Name</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.2"/><A HREF="#sec371" class="toc">11.2.2 Recording Intervals</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.3"/><A HREF="#sec372" class="toc">11.2.3 Recording Modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.4"/><A HREF="#sec373" class="toc">11.2.4 Recording Message Data</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.3"/><A HREF="#sec374" class="toc">11.3 Eventlog Tool</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.3.1"/><A HREF="#sec375" class="toc">11.3.1 Filter</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.3.2"/><A HREF="#sec376" class="toc">11.3.2 Echo</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_12"/><A HREF="#sec377" class="toc">12 Documenting NED and Messages</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.1"/><A HREF="#sec378" class="toc">12.1 Overview</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2"/><A HREF="#sec379" class="toc">12.2 Authoring the documentation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2.1"/><A HREF="#sec380" class="toc">12.2.1 Documentation comments</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2.2"/><A HREF="#sec381" class="toc">12.2.2 Text layout and formatting</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2.3"/><A HREF="#sec382" class="toc">12.2.3 Special tags</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2.4"/><A HREF="#sec383" class="toc">12.2.4 Additional text formatting using HTML</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2.5"/><A HREF="#sec384" class="toc">12.2.5 Escaping HTML tags</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2.6"/><A HREF="#sec385" class="toc">12.2.6 Where to put comments</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2.7"/><A HREF="#sec386" class="toc">12.2.7 Customizing the title page</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2.8"/><A HREF="#sec387" class="toc">12.2.8 Adding extra pages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2.9"/><A HREF="#sec388" class="toc">12.2.9 Incorporating externally created pages</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3"/><A HREF="#sec389" class="toc">12.3 Invoking opp_neddoc</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.1"/><A HREF="#sec390" class="toc">12.3.1 Multiple projects</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.4"/><A HREF="#sec391" class="toc">12.4 How does opp_neddoc work?</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_13"/><A HREF="#sec392" class="toc">13 Parallel Distributed Simulation</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.1"/><A HREF="#sec393" class="toc">13.1 Introduction to Parallel Discrete Event Simulation</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.2"/><A HREF="#sec394" class="toc">13.2 Assessing available parallelism in a simulation model</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3"/><A HREF="#sec395" class="toc">13.3 Parallel distributed simulation support in OMNeT++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3.1"/><A HREF="#sec396" class="toc">13.3.1 Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3.2"/><A HREF="#sec397" class="toc">13.3.2 Parallel Simulation Example</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3.3"/><A HREF="#sec398" class="toc">13.3.3 Placeholder modules, proxy gates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3.4"/><A HREF="#sec399" class="toc">13.3.4 Configuration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3.5"/><A HREF="#sec400" class="toc">13.3.5 Design of PDES Support in OMNeT++</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_14"/><A HREF="#sec401" class="toc">14 Customization and Embedding</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.1"/><A HREF="#sec402" class="toc">14.1 Architecture</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.2"/><A HREF="#sec403" class="toc">14.2 Embedding OMNeT++</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.3"/><A HREF="#sec404" class="toc">14.3 Sim: the simulation kernel and class library</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.3.1"/><A HREF="#sec405" class="toc">14.3.1 The global simulation object</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.3.2"/><A HREF="#sec406" class="toc">14.3.2 The coroutine package</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.4"/><A HREF="#sec407" class="toc">14.4 The Model Component Library</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.5"/><A HREF="#sec408" class="toc">14.5 Envir, Tkenv and Cmdenv</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.5.1"/><A HREF="#sec409" class="toc">14.5.1 The main() function</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.5.2"/><A HREF="#sec410" class="toc">14.5.2 The cEnvir interface</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.5.3"/><A HREF="#sec411" class="toc">14.5.3 Customizing Envir</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.5.4"/><A HREF="#sec412" class="toc">14.5.4 Implementation of the user interface: simulation applications</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_15"/><A HREF="#sec413" class="toc">15 NED Reference</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.1"/><A HREF="#sec414" class="toc">15.1 Syntax</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.1.1"/><A HREF="#sec415" class="toc">15.1.1 NED file extension</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.1.2"/><A HREF="#sec416" class="toc">15.1.2 NED file encoding</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.1.3"/><A HREF="#sec417" class="toc">15.1.3 Reserved words</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.1.4"/><A HREF="#sec418" class="toc">15.1.4 Identifiers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.1.5"/><A HREF="#sec419" class="toc">15.1.5 Case sensitivity</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.1.6"/><A HREF="#sec420" class="toc">15.1.6 Literals</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.1.7"/><A HREF="#sec421" class="toc">15.1.7 Comments</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.1.8"/><A HREF="#sec422" class="toc">15.1.8 Grammar</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.2"/><A HREF="#sec423" class="toc">15.2 Built-in definitions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.3"/><A HREF="#sec424" class="toc">15.3 Packages</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.3.1"/><A HREF="#sec425" class="toc">15.3.1 Package declaration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.3.2"/><A HREF="#sec426" class="toc">15.3.2 Directory structure, package.ned</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.4"/><A HREF="#sec427" class="toc">15.4 Name uniqueness</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.5"/><A HREF="#sec428" class="toc">15.5 Type name resolution</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.5.1"/><A HREF="#sec429" class="toc">15.5.1 Imports</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.5.2"/><A HREF="#sec430" class="toc">15.5.2 Base types and submodules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.5.3"/><A HREF="#sec431" class="toc">15.5.3 Parametric module types ("like" submodules)</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.5.4"/><A HREF="#sec432" class="toc">15.5.4 Network name in the ini file</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.6"/><A HREF="#sec433" class="toc">15.6 Inheritance</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.7"/><A HREF="#sec434" class="toc">15.7 Simple modules</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.8"/><A HREF="#sec435" class="toc">15.8 Channels</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.8.1"/><A HREF="#sec436" class="toc">15.8.1 Current namespace</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.9"/><A HREF="#sec437" class="toc">15.9 Interfaces</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.10"/><A HREF="#sec438" class="toc">15.10 Compound modules</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.11"/><A HREF="#sec439" class="toc">15.11 Networks</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.11.1"/><A HREF="#sec440" class="toc">15.11.1 The network keyword</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.11.2"/><A HREF="#sec441" class="toc">15.11.2 The @isNetwork property</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.12"/><A HREF="#sec442" class="toc">15.12 Properties</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.12.1"/><A HREF="#sec443" class="toc">15.12.1 Property inheritance</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.13"/><A HREF="#sec444" class="toc">15.13 Parameters</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.13.1"/><A HREF="#sec445" class="toc">15.13.1 Parameter inheritance</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.13.2"/><A HREF="#sec446" class="toc">15.13.2 The @unit property</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.14"/><A HREF="#sec447" class="toc">15.14 Gates</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.14.1"/><A HREF="#sec448" class="toc">15.14.1 Rules for gate vector sizes</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.15"/><A HREF="#sec449" class="toc">15.15 Expressions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.15.1"/><A HREF="#sec450" class="toc">15.15.1 Referencing parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.15.2"/><A HREF="#sec451" class="toc">15.15.2 Operators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.15.3"/><A HREF="#sec452" class="toc">15.15.3 The <tt>sizeof()</tt> and <tt>index</tt> operators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.15.4"/><A HREF="#sec453" class="toc">15.15.4 The <tt>xmldoc()</tt> operator</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.15.5"/><A HREF="#sec454" class="toc">15.15.5 XML documents and the XPath subset supported</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.15.6"/><A HREF="#sec455" class="toc">15.15.6 Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_15.15.7"/><A HREF="#sec456" class="toc">15.15.7 Physical units</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_16"/><A HREF="#sec457" class="toc">16 NED Language Grammar</A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_17"/><A HREF="#sec458" class="toc">17 NED XML Binding</A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_18"/><A HREF="#sec459" class="toc">18 NED Functions</A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_19"/><A HREF="#sec460" class="toc">19 Message Definitions Grammar</A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_20"/><A HREF="#sec461" class="toc">20 Display String Tags</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_20.1"/><A HREF="#sec462" class="toc">20.1 Message display strings</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_21"/><A HREF="#sec463" class="toc">21 Configuration Options</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_21.1"/><A HREF="#sec464" class="toc">21.1 Configuration Options</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_21.2"/><A HREF="#sec465" class="toc">21.2 Predefined Configuration Variables</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_22"/><A HREF="#sec466" class="toc">22 Result File Formats</A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_23"/><A HREF="#sec467" class="toc">23 Eventlog File Format</A></B></FONT><BR>
</p><hr><hr><H1><A NAME="sec100"/>1 Introduction</H1>
<a name="cha:introduction"></a>

<p>
<H2><A NAME="sec101"/>1.1 What is OMNeT++?</H2>

<p>OMNeT++ is an object-oriented modular discrete event network simulation
framework. It has a generic architecture, so it can be (and has been)
used in various problem domains:

<p><ul>
  <li>modeling of wired and wireless communication networks
  <li>protocol modeling
  <li>modeling of queueing networks
  <li>modeling of multiprocessors and other distributed hardware systems
  <li>validating of hardware architectures
  <li>evaluating performance aspects of complex software systems
  <li>and in general, it can be used for the modeling and simulation of
        any system where the discrete event approach is suitable, and which
        can be conveniently mapped into entities communicating by exchanging
        messages.
</ul>

<p>OMNeT++ itself is not a simulator of anything concrete, but it rather
provides infrastructure and tools for <i>writing</i> simulations. One of
the fundamental ingredients of this infrastructure is a component
architecture for simulation models. Models are assembled from reusable
components termed <i>modules</i>. Well-written modules are truly reusable,
and can be combined in various ways like LEGO blocks.

<p>Modules can be connected with each other via gates (other systems would
call them ports), and combined to form compound modules. The depth of
module nesting is not limited. Modules communicate through message passing,
where messages may carry arbitrary data structures. Modules can may
messages along predefined paths via gates and connections, or directly to
their destination; the latter is useful for wireless simulations, for
example. Modules may have parameters, which can be used to customize module
behaviour, and/or to parameterize the model's topology.
Modules at the lowest level of the module hierarchy are called
simple modules, and they encapsulate behaviour. Simple modules
are programmed in C++, and make use of the simulation library.

<p><fontmaroon><em> Unknown LaTeX command </em> \begin </font>graybox<fontmaroon><em>  </em>  </font>
OMNeT++ simulations can be run under various user interfaces.
Graphical, animating user interfaces are highly useful for
demonstration and debugging purposes, and command-line user
interfaces are best for batch execution.

<p>
The simulator as well as user interfaces and tools are highly portable.
They are tested on the most common operating systems (Linux, Mac OS/X,
Windows), and they can be compiled out of the box or after trivial
modifications on most Unix-like operating systems.

<p>OMNeT++ also supports parallel distributed simulation. OMNeT++ can
use several mechanisms for communication between partitions of
a parallel distributed simulation, for example MPI or named pipes.
The parallel simulation algorithm can easily be extended or new
ones plugged in. Models do not need any special instrumentation
to be run in parallel -- it is just a matter of configuration.
OMNeT++ can even be used for classroom presentation of parallel
simulation algorithms, because simulations can be run in parallel
even under the GUI which provides detailed feedback on what is going on.

<p>OMNEST is the commercially supported version of OMNeT++.
OMNeT++ is only free for academic and non-profit use --
for commercial purposes one needs to obtain OMNEST licenses
from Simulcraft Inc.

<p>

<H2><A NAME="sec102"/>1.2 Organization of this manual</H2>

<p>The manual is organized the following way:

<p><ul>
  <li>The chapters <a href="#sec100">[1]</a> and <a href="#sec104">[2]</a>
    contain introductory material
  <li>The second group of chapters,
    <a href="#sec116">[3]</a>,
    <a href="#sec154">[4]</a> and
    <a href="#sec222">[6]</a>
    are the programming guide. They present the NED language<!--ned!language-->,
    the simulation concepts and their implementation in OMNeT++, explain
    how to write simple<!--module!simple--> modules and describe the class library.
  <li>The chapters
    <a href="#sec337">[9]</a> and
    <a href="#sec377">[12]</a>
    elaborate the topic further, by explaining how one can customize
    the network graphics and how to write NED source code comments
    from which documentation can be generated.
  <li>The following chapters,
    <a href="#sec276">[7]</a>,
    <a href="#sec287">[8]</a> and
    <a href="#sec355">[10]</a> deal with practical issues
    like building and running simulations and analyzing results, and
    present the tools OMNeT++ provides to support these tasks.
  <li>Chapter <a href="#sec392">[13]</a> is devoted to the support
    of distributed execution.
  <li>Finally, Chapter <a href="#sec401">[14]</a> explains the
    architecture and the internals of OMNeT++. This chapter will be
    useful to those who want to extend the capabilities of the
    simulator or want to embed it into a larger application.
  <li>Appendix <a href="#sec457">[16]</a> provides a reference
    of the NED language<!--ned!language-->.
</ul>

<p>

<p>


<p><H2><A NAME="sec103"/>1.3 Credits</H2>

<p>OMNeT++ has been developed by Andr&aacute;s Varga (andras@omnetpp.org,
andras.varga@omnest.com).

<p>In the early stage of the project, several people have contributed
to OMNeT++. Although most contributed code is no longer part of
the OMNeT++, nevertheless I'd like to acknowledge the work of the
following people. First of all, I'd like thank Dr Gy&ouml;rgy Pongor
(pongor@hit.bme.hu), my advisor at the Technical University of Budapest
who initiated the OMNeT++ as a student project.

<p>My fellow student &Aacute;kos Kun started to program the first NED parser
in 1992-93, but it was abandoned after a few months.
The first version of nedc was finally developed in summer 1995,
by three exchange students from TU Delft: Jan Heijmans, Alex Paalvast
and Robert van der Leij. nedc was first called JAR after their initials
until it got renamed to nedc. nedc was further developed and refactored
several times until it finally retired and got replaced by nedtool in OMNeT++ 3.0.
The second group of Delft exchange students (Maurits Andr&eacute;,
George van Montfort, Gerard van de Weerd) arrived in fall 1995.
They performed some testing of the simulation library, and
wrote some example simulations, for example the original version of Token Ring,
and simulation of the NIM game which survived until OMNeT++ 3.0.
These student exchanges were organized by Dr. Leon Rothkranz
at TU Delft, and Gy&ouml;rgy Pongor at TU Budapest.

<p>The diploma thesis of Zolt&aacute;n Vass (spring 1996) was to prepare
OMNeT++ for parallel execution over PVM to OMNeT++. This code has been
replaced with the new Parallel Simulation Architecture in OMNeT++ 3.0.
G&aacute;bor Lencse (lencse@hit.bme.hu) was also interested in parallel
simulation, namely a method called Statistical Synchronization (SSM).
He implemented the FDDI model (practically unchanged until now), and added
some extensions into NED for SSM. These extensions have been removed
since then (OMNeT++ 3.0 does parallel execution on different principles).

<p>The <i>P<sup>2</sup></i> algorithm and the original implementation of the k-split algorithm
was programmed in fall 1996 by Babak Fakhamzadeh from TU Delft.
k-split was later reimplemented by Andr&aacute;s.

<p>Several bugfixes and valuable suggestions for improvements came
from the user community of OMNeT++. It would be impossible to
mention everyone here, and the list is constantly growing --
instead, the README and ChangeLog files contain acknowledgements.

<p>Between summer 2001 and fall 2004, the OMNeT++ CVS was hosted
at the University of Karlsruhe. Credit for setting
up and maintaining the CVS server goes to Ulrich Kaage.
Ulrich can also be credited with converting the User Manual from
Microsoft Word format to LaTeX, which was a huge undertaking
and great help.

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec104"/>2 Overview</H1>
<a name="cha:overview"></a>

<p>
<H2><A NAME="sec105"/>2.1 Modeling concepts</H2>

<p>An OMNeT++ model consists of modules that communicate with message passing.
The active modules are termed <i>simple modules</i>; they are written in C++,
using the simulation class library. Simple modules can be grouped into
<i>compound modules</i> and so forth; the number of hierarchy levels is not
limited. Messages can be sent either via connections that span between
modules or directly to their destination modules. The concept of simple and
compound modules is similar to DEVS atomic and coupled models.

Both simple and compound modules are instances of <i>module types</i>.
When describing the model, the user defines module types; instances of these
module types serve as components for more complex module types. Finally,
the user creates the system module as a network module which is a special
compound module type without gates to the external world. When a module
type is used as a building block, there is no distinction whether it is a
simple or a compound module. This allows the user to transparently split a
module into several simple modules within a compound module, or do the
opposite, re-implement the functionality of a compound module in one simple
module, without affecting existing users of the module type.

<p>In Fig. <a href="#fig:ch-overview:modules">below</a>, boxes represent simple modules
(thick border) and compound modules (thin border).
Arrows connecting small boxes represent connections and gates.

<p>
<div align=center>
<img src="usmanFig2.png">
<center><i>Figure: Simple and compound modules</i></center>
<a name="fig:ch-overview:modules"></a>
</div>

<p>

<p>Modules communicate with messages which -- in addition to
usual attributes such as timestamp -- may contain arbitrary
data. Simple modules typically send messages via gates, but it is also
possible to send them directly to their destination modules. Gates are the
input and output interfaces of modules: messages are sent out through
output gates and arrive through input gates. An input and an output gate
can be linked with a connection. Connections are created within a single
level of module hierarchy: within a compound module, corresponding gates of
two submodules, or a gate of one submodule and a gate of the compound
module can be connected. Connections spanning across hierarchy levels are
not permitted, as it would hinder model reuse. Due to the hierarchical
structure of the model, messages typically travel through a chain of
connections, to start and arrive in simple modules. Compound modules act as
'cardboard boxes' in the model, transparently relaying messages between
their inside and the outside world. Properties such as propagation delay,
data rate and bit error rate, can be assigned to connections. One can also
define connection types with specific properties (termed channels) and
reuse them in several places. Modules can have parameters. Parameters are
mainly used to pass configuration data to simple modules, and to help
define model topology. Parameters may take string, numeric or boolean
values. Because parameters are represented as objects in the program,
parameters -- in addition to holding constants -- may transparently act as
sources of random numbers with the actual distributions provided with the
model configuration, they may interactively prompt the user for the value,
and they might also hold expressions referencing other parameters. Compound
modules may pass parameters or expressions of parameters to their
submodules.

<p>

<p>

<p>
OMNeT++ provides efficient tools for the user to describe the
structure of the actual system. Some of the main features are:
<ul>
<li>hierarchically nested modules
<li>modules are instances of module types
<li>modules communicate with messages through channels
<li>flexible module parameters
<li>topology description language
</ul>

<p><H3><A NAME="sec106"/>2.1.1 Hierarchical modules</H3>

<p>
An OMNeT++ model consists of hierarchically nested
modules<!--module!hierarchy-->, which communicate by passing
messages to each another.
OMNeT++ models are often referred to as <i>networks</i>. The top
level module is the <i>system module</i>.  The system module
contains <i>submodules</i>, which can also contain submodules
themselves (Fig. <a href="#fig:ch-overview:modules">below</a>). The depth of module
nesting is not limited; this allows the user to reflect the logical
structure of the actual system in the model structure.

<p>Model structure is described in OMNeT++'s NED language.

<p>
<div align=center>
<img src="usmanFig2.png">
<center><i>Figure: Simple and compound modules</i></center>
<a name="fig:ch-overview:modules"></a>
</div>

<p>

<p>Modules that contain submodules are termed <i>compound
  modules</i><!--module!compound-->, as opposed <i>simple
  modules</i><!--module!simple--> which are at the lowest level of the
module hierarchy. Simple modules contain the algorithms in the model.
The user implements the simple modules in C++, using the OMNeT++
simulation class library.

<p>
<H3><A NAME="sec107"/>2.1.2 Module types</H3>
<!--module!types-->

<p>Both simple and compound modules are instances of <i>module
  types</i>. While describing the model, the user defines module types;
instances of these module types serve as components for more complex
module types. Finally, the user creates the system module as an
instance of a previously defined module type; all modules of the
network are instantiated as submodules and sub-submodules of the
system module.

<p>When a module type is used as a building block, there is no
distinction whether it is a simple or a compound module. This allows
the user to split a simple module into several
simple modules embedded into a compound<!--module!compound--> module,
or vica versa, aggregate the functionality of a compound module into a
single simple module, without affecting existing users of the module
type.

<p>Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create <i>component libraries</i><!--module!libraries-->. This feature
will be discussed later, in Chapter <a href="#sec287">[8]</a>.

<p>

<p><H3><A NAME="sec108"/>2.1.3 Messages, gates, links</H3>

<p>Modules communicate by exchanging
<i>messages</i><!--message!exchanging-->. In an actual simulation,
messages can represent frames or packets in a computer network, jobs
or customers in a queuing network or other types of mobile entities.
Messages can contain arbitrarily complex data structures. Simple
modules can send messages either directly to their destination or
along a predefined path, through gates and connections.

<p>
The ``local simulation time'' of a module advances when the module
receives a message. The message can arrive from another module
or from the same module (<i>self-messages</i> are used to implement
timers).

<p>
<i>Gates</i><!--gate--> are the input and output interfaces of
modules; messages are sent out through output gates and arrive through
input gates.

<p>Each <i>connection</i><!--connection--> (also called
<i>link</i><!--link-->) is created within a single level of the
module hierarchy: within a compound module, one can connect the
corresponding gates of two submodules, or a gate of one submodule and
a gate of the compound module (Fig.
<a href="#fig:ch-overview:connections">below</a>).

<p>
<div align=center>
<img src="usmanFig3.png">
<center><i>Figure: Connections</i></center>
<a name="fig:ch-overview:connections"></a>
</div>

<p>
Due to the hierarchical structure of the model, messages typically
travel through a series of connections, to start and arrive in simple
modules. Such series of connections that go from simple module to
simple module are called <i>routes</i>.  Compound modules act as
`cardboard boxes' in the model, transparently relaying messages
between their inside and the outside world.

<p>
<H3><A NAME="sec109"/>2.1.4 Modeling of packet transmissions</H3>

<p>Connections can be assigned three parameters, which facilitate
the modeling of communication networks, but can be useful in
other models too: <i>propagation delay</i>, <i>bit error rate</i>
and <i>data rate</i>, all three being optional. One can specify
link parameters individually for each connection, or define link types
and use them throughout the whole model.

<p>Propagation delay is the amount of time the arrival of
the message is delayed by when it travels through the channel.

<p>Bit error rate speficifies the probability that a bit is incorrectly
transmitted, and allows for simple noisy channel modelling.

<p>Data rate is specified in bits/second, and it is used for calculating
transmission time of a packet.

<p>When data rates are in use, the sending of the message in the model
corresponds to the transmission of the first bit, and
the arrival of the message corresponds to the reception
of the last bit. This model is not always applicable,
for example protocols like Token Ring and FDDI do not wait
for the frame to arrive in its entirety, but rather start repeating
its first bits soon after they arrive -- in other words,
frames ``flow through'' the stations, being delayed only a few bits.
If you want to model such networks, the data rate modeling feature
of OMNeT++ cannot be used.

<p>

<p><H3><A NAME="sec110"/>2.1.5 Parameters</H3>
<!--module!parameters-->
<!--parameters|seemodule parameters-->

<p>Modules can have parameters. Parameters can be assigned either
in the NED files or the configuration file omnetpp.ini.

<p>Parameters may be used to customize simple module behaviour,
and for parameterizing the model topology.

<p>Parameters can take string, numeric or boolean values, or can
contain XML data trees. Numeric values include expressions using
other parameters and calling C functions, random variables from
different distributions, and values input interactively by the user.

<p>Numeric-valued parameters can be used to construct topologies in a
flexible way. Within a compound module, parameters can define the
number of submodules, number of gates, and the way the internal
connections are made.

<p>
<H3><A NAME="sec111"/>2.1.6 Topology description method</H3>
<!--topology!description-->
The user defines the structure of the model in NED language descriptions
(Network Description).The NED language will be discussed in detail
in Chapter <a href="#sec116">[3]</a>.

<p>
<H2><A NAME="sec112"/>2.2 Programming the algorithms</H2>

<p>The simple<!--module!simple--> modules of a model contain algorithms
as C++ functions.
The full flexibility and power of the programming language can
be used, supported by the OMNeT++ simulation class library.
The simulation programmer can choose between event-driven and process-style
description, and can freely use object-oriented concepts
(inheritance, polymorphism etc) and design patterns to extend the
functionality of the simulator.

<p>Simulation objects (messages, modules, queues etc.) are represented
by C++ classes. They have been designed to work together efficiently,
creating a powerful simulation programming framework.
The following classes are part of the simulation class library:

<p><ul>
  <li>modules, gates, connections etc.
  <li>parameters
  <li>messages
  <li>container classes (e.g. queue, array)
  <li>data collection classes
  <li>statistic and distribution estimation classes (histograms, <i>P<sup>2</sup></i>
  algorithm for calculating quantiles etc.)
  <li>transient detection and result accuracy detection classes
</ul>

<p>The classes are also specially instrumented, allowing one
to traverse objects of a running simulation and display information
about them such as name, class name, state variables or contents.
This feature has made it possible to create a simulation GUI where
all internals of the simulation are visible.

<p>


<p><H2><A NAME="sec113"/>2.3 Using OMNeT++</H2>

<p>
<H3><A NAME="sec114"/>2.3.1 Building and running simulations</H3>
<!--simulation!building-->
<!--simulation!running-->

<p>This section provides insight into working with OMNeT++ in practice:
Issues such as model files, compiling and running simulations are
discussed.

<p>An OMNeT++ model consists of the following parts:
<ul>
  <li>NED language topology description(s)<!--ned!files--> (<tt>.ned</tt> files)
    which describe the module structure with parameters, gates etc.
    NED files can be written using any text editor or the
    GNED graphical editor<!--ned!graphical editor-->.
  <li>Message definitions (<tt>.msg</tt> files). You can define various message
    types and add data fields to them. OMNeT++ will translate message definitions
    into full-fledged C++ classes.
  <li>Simple modules sources. They are C++ files, with <tt>.h</tt>/<tt>.cc</tt> suffix.
</ul>

<p>The simulation system provides the following components:
<ul>
  <li>Simulation kernel<!--simulation!kernel-->. This contains the
    code that manages the simulation and the simulation class library.
    It is written in C++, compiled and put together to form a library
    (a file with .a or .lib extension)
  <li>User interfaces<!--simulation!user interface-->.
    <!--user interface--> OMNeT++ user interfaces
    are used in simulation execution, to facilitate debugging,
    demonstration, or batch execution of simulations. There are
    several user interfaces, written in C++, compiled and put together
    into libraries (<tt>.a</tt> or <tt>.lib</tt> files).
</ul>

<p>
Simulation programs are built from the above components. First,
<tt>.msg</tt> files are translated into C++ code using the <tt>opp_msgc</tt>.
program. Then all C++ sources are compiled, and linked with the simulation
kernel and a user interface library to form a simulation executable.
NED files<!--ned!files--> can either be also translated into C++
(using <tt>nedtool</tt>) and linked in, or loaded dynamically in their original
text forms when the simulation program starts.

<p>

<p><p class="subheading">Running the simulation and analyzing the results</p>

<p>The simulation executable is a standalone program,
thus it can be run on other machines without OMNeT++ or the model files
being present. When the program is started, it reads a configuration
file<!--simulation!configuration file--> (usually called
<tt>omnetpp.ini</tt><!--omnetpp.ini-->). This file contains settings that
control how the simulation is executed, values for model parameters, etc.
The configuration file can also prescribe several simulation runs; in
the simplest case, they will be executed by the simulation program one
after another.

<p>The output of the simulation is written into data files: output vector
files<!--output!vector file-->, output scalar files
<!--output!scalar file-->, and possibly the user's own output files.
OMNeT++ provides a GUI tool named Plove to view and plot the contents
of output vector files. It is not expected that someone will
process the result files using OMNeT++ alone: output files are text
files in a format which can be read into math packages like Matlab
or Octave, or imported into spreadsheets like OpenOffice Calc,
Gnumeric or MS Excel (some preprocessing using <tt>sed</tt>, <tt>awk</tt>
or <tt>perl</tt> might be required, this will be discussed later).
All these external programs provide rich functionality for statistical
analysis and visualization, and it is outside the scope of OMNeT++ to
duplicate their efforts. This manual briefly describes
some data plotting programs and how to use them with OMNeT++.

<p>Output scalar files can be visualized using the Scalars tool.
It can draw bar charts, x-y plots (e.g. throughput vs offered load),
or export data via the clipboard for more detailed analysis into
spreadsheets and other programs.

<p>
<p class="subheading">User interfaces</p>
<!--simulation!user interface-->

<p>The primary purpose of user interfaces is to make the internals
of the model visible to the user, to control simulation execution,
and possibly allow the user to intervene by changing variables/objects
inside the model. This is very important in the development/debugging
phase of the simulation project. Just as important, a hands-on
experience allows the user to get a `feel' of the model's
behaviour. The graphical user interface can also be used to
demonstrate a model's operation.

<p>
The same simulation model can be executed with different user
interfaces, without any change in the model files themselves.
The user would test and debug the simulation with a powerful
graphical user interface, and finally run it with a simple and
fast user interface that supports batch execution.

<p>
<p class="subheading">Component libraries</p>
<!--module!libraries-->

<p>Module types can be stored in files separate from the place
of their actual use. This enables the user to group existing
module types and create component libraries.

<p>
<p class="subheading">Universal standalone simulation programs</p>

<p>
A simulation executable can store several independent models
that use the same set of simple modules. The user can specify
in the configuration file which model is to be run. This
allows one to build one large executable that contains several
simulation models, and distribute it as a standalone simulation
tool. The flexibility of the topology description language also
supports this approach.

<p>
<H3><A NAME="sec115"/>2.3.2 What is in the distribution</H3>

<p>If you installed the source distribution, the omnetpp directory on your system
should contain the following subdirectories. (If you installed a precompiled
distribution, some of the directories may be missing, or there might be
additional directories, e.g. containing software bundled with OMNeT++.)

<p>The simulation system itself:

<p><pre>
  <b>omnetpp/</b>         OMNeT++ root directory
    <b>bin/</b>           OMNeT++ executables (GNED, nedtool, etc.)
    <b>include/</b>       header files for simulation models
    <b>lib/</b>           library files
    <b>bitmaps/</b>       icons that can be used in network graphics
    <b>doc/</b>           manual (PDF), readme, license, etc.
      <b>manual/</b>      manual in HTML
      <b>tictoc-tutorial/</b>  introduction into using OMNeT++
      <b>api/</b>         API reference in HTML
      <b>nedxml-api/</b>  API reference for the NEDXML library
      <b>src/</b>         sources of the documentation
    <b>src/</b>           OMNeT++ sources
      <b>nedc/</b>        nedtool, message compiler
      <b>sim/</b>         simulation kernel
        <b>parsim/</b>    files for distributed execution
        <b>netbuilder/</b>files for dynamically reading NED files
      <b>envir/</b>       common code for user interfaces
      <b>cmdenv/</b>      command-line user interface
      <b>tkenv/</b>       Tcl/Tk-based user interface
      <b>gned/</b>        graphical NED editor
      <b>plove/</b>       output vector analyzer and plotting tool
      <b>scalars</b>      output scalar analyzer and plotting tool
      <b>nedxml/</b>      NEDXML library
      <b>utils/</b>       makefile-creator, documentation tool, etc.
    <b>test/</b>          regression test suite
      <b>core/</b>        regression test suite for the simulation library
      <b>distrib/</b>     regression test suite for built-in distributions
      ...
</pre>

<p>Sample simulations are in the <tt>samples</tt> directory.

<p><pre>
    <b>samples/</b>     directories for sample simulations
      <b>aloha/</b>     models the Aloha protocol
      <b>cqn/</b>       Closed Queueing Network
      ...
</pre>

<p>The <tt>contrib</tt> directory contains material from the OMNeT++ community.

<p><pre>
    <b>contrib/</b>     directory for contributed material
      <b>octave/</b>    Octave scripts for result processing
      <b>emacs/</b>     NED syntax highlight for Emacs
</pre>

<p>You may also find additional directories like <tt>msvc/</tt>, which contain
integration components for Microsoft Visual C++, etc.

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec116"/>3 The NED Language</H1>
<a name="cha:the-ned-language"></a>

<p>
<H2><A NAME="sec117"/>3.1 NED overview</H2>

<p>The user describes the structure of a simulation model in the NED language. NED
stands for Network Description. NED lets the user declare simple modules, and
connect and assemble them into compound modules. The user can label some compound
modules as <i>networks</i>, self-contained simulation models. Channels are
another component type, whose instances can also be used in compound modules.

<p>The NED languge has several features which let it scale well to large projects:

<p><dl>

<p><li>[Hierarchical] The traditional way to deal with complexity is via
introducing hierarchies. In OMNeT++, any module which would be too complex as
a single entity can be broken down into smaller modules, and used as a
compound module.

<p><li>[Component-Based] Simple modules and compound modules are inherently
reusable, which not only reduces code copying, but more importantly, allows
component libraries (like the INET Framework, MiXiM, Castalia, etc.) to
exist.

<p><li>[Interfaces] Module and channel interfaces can be used as a
placeholder where normally a module or channel type would be used, and the
concrete module or channel type is determined at network setup time by a
parameter. Concrete module types have to ``implement'' the interface they
can substitute. For example, given a compound module type named
<tt>MobileHost</tt> contains a <tt>mobility</tt> submodule of the type
<tt>IMobility</tt> (where <tt>IMobility</tt> is a module interface), the actual
type of <tt>mobility</tt> may be chosen from the module types that implemented
<tt>IMobility</tt> (<tt>RandomWalkMobility</tt>, <tt>TurtleMobility</tt>, etc.)

<p><li>[Inheritance] Modules and channels can be subclassed. Derived modules
and channels may add new parameters, gates, and (in the case of compound
modules) new submodules and connections. They may set existing parameters
to a specific value, and also set the gate size of a gate vector. This
makes it possible, for example, to take a <tt>GenericTCPClientApp</tt> module
and derive an <tt>FTPApp</tt> from it by setting certain parameters to a fixed
value; or derive a <tt>WebClientHost</tt> compound module from a
<tt>BaseHost</tt> compound module by adding a <tt>WebClientApp</tt> submodule and
connecting it to the inherited <tt>TCP</tt> submodule.

<p><li>[Packages] To address name clashes between different models and to
simplify specifying which NED files are needed by a specific simulation
model, the NED language features a Java-like package structure.

<p><li>[Inner types] Channel types and module types used locally by a
compound module can be defined within the compound module, in order to
reduce namespace pollution.

<p><li>[Metadata annotations] It is possible to annotate module or channel
types, parameters, gates and submodules by adding properties. Metadata are
not used by the simulation kernel directly, but they can carry extra
information for various tools, the runtime environment, or even for other
modules in the model. For example, a module's graphical representation
(icon, etc)  or the prompt string and physical unit (milliwatt, etc) of a
parameter are already specified as metadata annotations.

<p></dl>

<p><fontmaroon><em> Unknown LaTeX command </em> \begin </font>note<fontmaroon><em>  </em>  </font>
    The NED language has changed significantly in the 4.0 version.
    Inheritance, interfaces, packages, inner types, metadata annotations, inout
    gates were all added in the 4.0 release, together with many other features.
    Since the basic syntax has changed as well, old NED files need to be
    converted to the new syntax. There are automated tools for this purpose, so
    manual editing is only needed to take advantage of new NED features.

<p>
The NED language has an equivalent tree representation which can be
serialized to XML; that is, NED files can be converted to XML and back
without loss of data, including comments. This lowers the barrier for
programmatic manipulation of NED files, for example extracting information,
refactoring and transforming NED, generating NED from information stored in
other system like SQL databases, and so on.

<p>
    This chapter is going to explain the NED language gradually, via examples.
    If you are looking for a more formal and concise treatment, see
    Appendix <a href="#sec457">[16]</a>.

<p>

<p><H2><A NAME="sec118"/>3.2 NED files</H2>

<p>NED files have the <tt>.ned</tt> file name suffix. The location of the files
matter as well, because the NED language has a package structure similar to
Java, where the subdirectory corresponds to the package. More about this in
section FIXME.

<p>
<H2><A NAME="sec119"/>3.3 Simple modules</H2>

<p>Simple modules are the basic building blocks for other (compound)
modules. An example simple module declaration:

<p>
<pre>
//
// A queue with a built-in server
//
simple Queue
{
    parameters:
        @display("i=block/queue;q=queue");
        int capacity = default(-1);  // use -1 for unlimited
        volatile double serviceTime @unit(s);
    gates:
        input in[];
        output out;
}
</pre>

<p>This declares a simple module named <tt>Queue</tt>, which has two parameters
<tt>capacity</tt> and <tt>serviceTime</tt>, and two gates <tt>in</tt> and <tt>out</tt>. The
lines starting with ``<tt>//</tt>'' are comments.

<p>Note that the module name (<tt>Queue</tt>) begins with a capital letter, and
parameter and gate names (<tt>capacity</tt>, <tt>serviceTime</tt>, <tt>in</tt>,
<tt>out</tt>) begin with lowercase. This is the recommended naming convention.
(Capitalization matters because the language is case sensitive). It is also
the recommended practice to have one module per file, and the file name to be
the same as the module name (plus <tt>.ned</tt>).

<p>Notice that this declaration doesn't contain any code to define the operation
of the queue itself: that part is expressed in C++. By default, OMNeT++ looks for a
C++ class of the same name (so here, <tt>Queue</tt>), although this gets slightly
more complicated if C++ namespaces or NED packages are present, and the user
can also explicitly specify which C++ class to use.

<p>The <tt>capacity</tt> parameter is created with the type <tt>int</tt>, and
<tt>serviceTime</tt> with <tt>double</tt>. Other NED parameter types include
<tt>bool</tt>, <tt>string</tt> and <tt>xml</tt>. Parameters can be read from C++ code,
and they can get values from NED code, from the configuration (ini files, see
FIXME), or interactively from the user. It is also possible to give them a default value (see
<tt>default(-1)</tt> in the example), which gets assigned to the parameter if a
matching <tt>apply-default=true</tt> line is found in the configuration.

<p>
    How do you decide whether to assign a parameter from NED or from and ini
    file? The point of ini files is a cleaner separation of the <i>model</i>
    and <i>experiments</i>. NED files (together with C++ code) are considered
    to be part of the model, and to be more or less constant. Ini files, on
    the other hand, are for experimenting with the model, by running it
    several times with different parameters. Thus, parameters that are expected
    to change (or make sense to be changed) during experimentation should be
    put into ini files.

<p>
The <tt>serviceTime</tt> parameter is decorated with <tt>@unit(s)</tt>. This means
that the value must be specified in either seconds, or in a physical unit OMNeT++
can convert to seconds, like milliseconds or hours; dimensionless numbers
will not be accepted. The OMNeT++ runtime does a full and rigorous unit check on
parameters to ensure ``unit safety'' of models.

<p><tt>serviceTime</tt> is also declared <tt>volatile</tt>: this indicates that the
underlying C++ code is going to re-read the parameter at runtime for every
use of it; for example, this queue would re-read the parameter for every job
serviced. Thus, it makes sense to assign <tt>serviceTime</tt> a random value like
<tt>uniform(0.5s, 1.5s)</tt>, which would result in every job to have a different,
random service time. Non-volatile parameters, however, are evaluated and
replaced with a constant at the start of the simulation.

<p>
    This does not mean that a non-volatile parameter cannot be assigned a value
    like <tt>uniform(0.5s, 1.5s)</tt>. It can, but that has a totally different
    effect. Had we omitted the <tt>volatile</tt> keyword from the
    <tt>serviceTime</tt> parameter, for example, the effect would be that every
    job had the <i>same</i> constant service time, say <tt>1.2975367s</tt>,
    chosen randomly at the beginning of the simulation.

<p>
So far we have neglected the <tt>@display</tt> line in the above code. It is called
<i>display string</i>, and specifies how the module appears in the animation.
This particular display string specifies a default icon
(<tt>block/queue</tt>), and requests that the length of an internal C++ queue
object named <tt>queue</tt> be displayed next to the module icon. Other display
strings may specify position, color, arrangement, etc. of modules. The
syntactical similarity of <tt>@display</tt> to <tt>@unit</tt> is not accidental; they
are both metadata annotations (<i>properties</i> in OMNeT++), recognized and
treated specially by the runtime.

<p>Gates are the connection points of modules. OMNeT++ has three types of gates:
<i>input</i>, <i>output</i> and <i>inout</i>, the latter being essentially
an input and an output gate glued together. The C++ code that implements the
simple module may send and receive messages via gates. Gates allow one-to-one
connections, but in this example the <tt>in</tt> gate is declared as a <i>gate
vector</i> (or <i>vector gate</i>) in order to allow several sources to send jobs
into the queue. The size of the gate vector (the number of gates in it) is left
undefined here, letting actual users (compound modules or networks that
instantiate this module type) create as many gates as they want.

<p>
    In many other systems, the equivalent of OMNeT++ gates are called
    <i>ports</i>. We have retained the term <i>gate</i> to reduce
    collisions with other uses of the otherwise overloaded word
    <i>port</i>: router port, TCP port, I/O port, etc.

<p>
Parameters and gates will be discussed in detail in section FIXME.
Both the <tt>parameters:</tt> and <tt>gates:</tt> sections in the simple module are
optional.

<p>Simple modules can be extended (or specialized) via subclassing. This will be
discussed in section FIXME.

<p>Comments in the NED source also serve a purpose in addition to making
the NED source more readable: in the OMNeT++ IDE they get displayed at various places (tooltips,
content assist, etc), and become part of the documentation extracted from the
NED files. The NED documentation system, not completely unlike <i>JavaDoc</i>
or <i>Doxygen</i>, will be described in Chapter <a href="#sec377">[12]</a>.

<p>FIXME @class, @namespace

<p><H2><A NAME="sec120"/>3.4 Channels</H2>

<p>A channel definition specifies a connection type of some given characteristics.
Let us see an example channel:

<p><pre>
channel Backbone extends ned.BasicChannel
{
    parameters:
        delay = 2ms;
        datarate = 10Gbps;
}
</pre>

<p>
    The <tt>parameters:</tt> keyword is optional (everywhere, not only in
    channels), so it can be left out.

<p>
Our <tt>Backbone</tt> channel type extends (subclasses, builds upon) the
<tt>ned.BasicChannel</tt> channel type. (In the latter name, <tt>ned</tt> is the
package name, and <tt>BasicChannel</tt> is the actual type name.)
<tt>ned.BasicChannel</tt> is a built-in NED type, and it declares four parameters:
<tt>delay</tt> (propagation delay), <tt>error</tt> (bit error rate), <tt>datarate</tt>
(channel bandwidth, used for calculating transmission time of a packet), and
<tt>disabled</tt> (a boolean parameter).

<p>
    <tt>error</tt> and <tt>datarate</tt> are present to facilitate simulation of
    communication networks, they would simply be unused in, say, queueing
    network simulations.

<p>
<tt>ned.BasicChannel</tt> initializes these parameters to provide an ideal channel
(zero delay and bit error rate, infinite data rate). In the above
declaration, we override <tt>delay</tt> and <tt>datarate</tt> to get our custom
channel.

<p>For completeness, there is another built-in channel type,
<tt>ned.IdealChannel</tt>. It defines no parameters, and its C++ implementation
does nothing but let the message though without any change or delay.



<p>Channels types resemble simple modules in the sense that they need an underlying
C++ class to function, the NED declaration itself is not enough. Our
<tt>Backbone</tt> channel inherits this C++ class from <tt>ned.BasicChannel</tt>.

<p>FIXME @class, @namespace

<p>
<H2><A NAME="sec121"/>3.5 Compound modules</H2>

<p>Compound modules are modules that are composed of one or more submodules.
Any module type (simple or compound module) can be used as a submodule.
Like simple modules, compound modules can also have gates and parameters,
and they can be used wherever simple modules can be used.

<p>It is useful to think about compound modules as ``cardboard boxes''
that help you organize your simulation model and bring structure into
it. No active behaviour is associated with compound modules -- they
are simply for grouping modules into larger components that can
can be used either as a model (see section <a href="#sec127">[3.6]</a>)
or as a building block for other compound modules.

<p>By convention, module type names begin with upper-case letters.

<p>Submodules may use parameters of the compound module.
They may be connected with each other and/or with
the compound module itself.

<p>A compound module definition<!--module!compound!definition--> looks
similar to a simple<!--module!simple--> module definition:
it has <tt>gates</tt> and <tt>parameters</tt> sections.
There are two additional sections, <tt>submodules</tt> and
<tt>connections</tt>.

<p>Let us see a compound module from the <i>Routing</i> example simulation:

<p><pre>
module Node
{
    parameters:
        int address;
        @display("i=misc/node_vs,gold");
    gates:
        inout port[];
    submodules:
        app: App {
            parameters:
                address = address;
                @display("p=140,60");
        }
        routing: Routing {
            parameters:
                @display("p=140,130");
            gates:
                in[sizeof(port)];
                out[sizeof(port)];
        }
        queue[sizeof(port)]: L2Queue {
            parameters:
                @display("p=80,200,row");
        }
    connections:
        routing.localOut --&gt; app.in;
        routing.localIn &lt;-- app.out;
        for i=0..sizeof(port)-1 {
            routing.out[i] --&gt; queue[i].in;
            routing.in[i] &lt;-- queue[i].out;
            queue[i].line &lt;--&gt; port[i];
        }
}
</pre>

<p>All sections (<tt>parameters</tt>, <tt>gates</tt>, <tt>submodules</tt>,
<tt>connections</tt>) are optional.

<p><H3><A NAME="sec122"/>3.5.1 Compound module parameters and gates</H3>

<p>Parameters<!--module!compound!parameters--> and gates <!--gate-->
for compound modules are declared and work in the same way
as with simple modules, described in sections
<a href="#sec139">[3.12]</a>
and <a href="#sec142">[3.13]</a>.

<p>Typically, compound module parameters are passed to submodules and
used for initializing their parameters.

<p>Parameters can also be used in defining the internal structure of
the compound module: the number of submodules and sizes of gate vectors
can be defined with the help of parameters, and parameters can
also be used in defining the connections inside the compound module.
As a practical example, you can create a <tt>Router</tt> compound module
with a variable number of ports, specified in a <tt>numOfPorts</tt> parameter.

<p>Parameters affecting the internal structure should not be declared
<tt>volatile</tt>, as it may lead to unexpected results.

<p><H3><A NAME="sec123"/>3.5.2 Submodules</H3>

<p>Submodules<!--module!submodule--> are defined in the
<tt>submodules:</tt> section of a compound
module declaration. Submodules are identified by names.
By convention, submodule names begin with lower-case letters.

<p>Submodules are instances of a module type, either simple
or compound -- there is no distinction. The module type
must be known to the NED compiler, that is, it must have appeared
earlier in the same NED file or have been imported from another
NED file.

<p>It is possible to define vectors of submodules, and the
size of the vector may come from a parameter value.

<p>When defining submodules, you can assign values to their
parameters, and if the corresponding module type has gate vectors,
you have to specify their sizes.

<p>
Example:

<p><pre>
<b>module</b> CompoundModule
    //...
    <b>submodules</b>:
        submodule1: ModuleType1
            <b>parameters</b>:
                //...
            <b>gatesizes</b>:
                //...
        submodule2: ModuleType2
            <b>parameters</b>:
                //...
            <b>gatesizes</b>:
                //...
<b>endmodule</b>
</pre>

<p>
<p class="subheading">Submodule vectors</p>

<p>
It is possible to create an array<!--module!array--> of
submodules<!--submodule|seemodule--> (a module
vector<!--module!vector-->).  This is done with an expression between
brackets right behind the module type name. The expression can refer
to module parameters. A zero value as module count is also allowed.

<p>Example:

<p><pre>
<b>module</b> CompoundModule
    <b>parameters</b>:
        size: <b>const</b>;
    <b>submodules</b>:
        submod1: Node[3]
            //...
        submod2: Node[size]
            //...
        submod3: Node[2*size+1]
            //...
<b>endmodule</b>
</pre>

<p>
<H3><A NAME="sec124"/>3.5.3 Assigning values to submodule parameters</H3>

<p><!--module!submodule!parameters-->

<p>If the module type used as submodule has parameters, you can assign
values to them in the <tt>parameters</tt> section of the submodule
declaration.
As a value you can use a constant (such as <tt>42</tt> or
<tt>"www.foo.org"</tt>), various parameters (most commonly, parameters
of the compound module), or write an arbitrary expression containing
the above.

<p>It is not mandatory to mention and assign all parameters.
Unassigned parameters can get their values at runtime: either from
the configuration file (<tt>omnetpp.ini</tt>), or if the value
isn't there either, the simulator will prompt you to enter it
interactively. Indeed, for flexibility reasons it is often very useful
not to ``hardcode'' parameter values in the NED file,
but to leave them to <tt>omnetpp.ini</tt> where they can be
changed more easily.

<p>
Example:

<p><pre>
<b>module</b> CompoundModule
    <b>parameters</b>:
        param1: numeric,
        param2: numeric,
        useParam1: bool;
    <b>submodules</b>:
        submodule1: Node
            <b>parameters</b>:
                p1 = 10,
                p2 = param1+param2,
                p3 = useParam1==true ? param1 : param2;
        //...
<b>endmodule</b>
</pre>

<p>
The expression syntax <!--ned!expressions--> is very similar to C.
Expressions may contain constants (literals) and parameters of the
compound module being defined. Parameters can be passed by value
or by reference. The latter means that the expression is evaluated
at runtime each time its value is accessed (e.g. from simple module
code), opening up interesting possibilities for the modeler.
You can also refer to parameters of the already defined submodules,
with the syntax <tt>submodule.parametername</tt>
(or <tt>submodule[index].parametername</tt>).

<p>Expressions are described in detail in section <a href="#"></a>.

<p>
<p class="subheading">The <tt>input</tt> keyword</p>
<a name="sec:ch-ned-lang:input"></a>

<p>When a parameter does not receive a value inside NED files or in
the configuration file (<tt>omnetpp.ini</tt>), the user will be prompted
to enter its value at the beginning of the simulation.
If you plan to make use of interactive prompting, you can specify
a prompt text and a default value.

<p>The syntax is the following:

<p><pre>
   parameters:
      numCPUs = <b>input</b>(10, "Number of processors?"), // default value, prompt
      processingTime = <b>input</b>(10ms), // prompt text
      cacheSize = input;
</pre>

<p>The third version is actually the same as leaving out the parameter
from the list of assignments, but you can use it to make it explicit
that you do not want to assign a value from the NED file.

<p>
<H3><A NAME="sec125"/>3.5.4 Defining sizes of submodule gate vectors</H3>

<p><!--module!gate sizes-->
<!--gate!vector!size-->

<p>The sizes of gate vectors are defined with the
<tt>gatesizes</tt> keyword.  Gate vector sizes
can be given as constants, parameters or expressions.

<p>An example:

<p><pre>
<b>simple</b> Node
    <b>gates</b>:
        <b>in</b>: inputs[];
        <b>out</b>: outputs[];
<b>endsimple</b>

<b>module</b> CompoundModule
    <b>parameters</b>:
        numPorts: <b>const</b>;
    <b>submodules</b>:
        node1: Node
            <b>gatesizes</b>:
                inputs[2], outputs[2];
        node2: Node
            <b>gatesizes</b>:
                inputs[numPorts], outputs[numPorts];
        //...
<b>endmodule</b>
</pre>

<p>
<tt>gatesizes</tt> is not mandatory.
If you omit <tt>gatesizes</tt> for a gate vector, it will be created with zero size.

<p>One reason for omitting <tt>gatesizes</tt> is that you'll want to use
the <tt>gate++</tt> (``extend gate vector with a new gate'') notation later in the
<tt>connections</tt> section.

<p>

<p><H3><A NAME="sec126"/>3.5.5 Connections</H3>

<p>The compound module definition specifies how the gates of the compound
module and its immediate sub-modules are connected<!--connection-->.

<p>You can connect two submodules or a submodule with its enclosing
compound module. (For completeness, you can also connect two gates
of the compound module on the inside, but this is rarely needed).
This means that NED does not permit connections that span
multiple levels of hierarchy -- this restriction
enforces compound modules to be self-contained, and thus promotes
reusability. Gate directions must also be observed,
that is, you cannot connect two output gates or two input gates.

<p>Only one-to-one connections are supported, so a particular gate may only
be used occur in one connection. One-to-many and many-to-one
connections can be achieved using simple modules that duplicate
messages or merge message flows. The rationale is that wherever
such fan-in or fan-out occurs in a model, it is usually associated
with some processing anyway that makes it necessary to use
simple modules.

<p>Connections<!--ned!connections--> are specified in the
<tt>connections:</tt> section of a compound
module definition. It lists the connections, separated by semicolons.

<p>Example:

<p><pre>
<b>module</b> CompoundModule
    <b>parameters</b>: //...
    <b>gates</b>: //...
    <b>submodules</b>: //...
    <b>connections</b>:
        node1.output --&gt; node2.input;
        node1.input &lt;-- node2.output;
        //...
<b>endmodule</b>
</pre>

<p>The source gate can be an output gate of a submodule or an input
gate of the compound module, and the destination gate can be
an input gate of a submodule or an output gate of the compound
module. The arrow can point either left-to-right or right-to-left.

<p>The <i>gate++</i> notation allows you to extend a gate vector
with new gates, without having to declare the vector size in advance
with <tt>gatesizes</tt>. This feature is very convenient for connecting
nodes of a network:

<p><pre>
<b>simple</b> Node
    <b>gates</b>:
        <b>in</b>: in[];
        <b>out</b>: out[];
<b>endsimple</b>

<b>module</b> SmallNet
    <b>submodules</b>:
        node: Node[6];
    <b>connections</b>:
        node[0].out++ --&gt; node[1].in++;
        node[0].in++ &lt;-- node[1].out++;

        node[1].out++ --&gt; node[2].in++;
        node[1].in++ &lt;-- node[2].out++;

        node[1].out++ --&gt; node[4].in++;
        node[1].in++ &lt;-- node[4].out++;

        node[3].out++ --&gt; node[4].in++;
        node[3].in++ &lt;-- node[4].out++;

        node[4].out++ --&gt; node[5].in++;
        node[4].in++ &lt;-- node[5].out++;
<b>endmodule</b>
</pre>

<p>
A connection:

<p><ul>
  <li>may have attributes (delay, bit error rate or data rate) or
        use a named channel;
  <li>may occur inside a for-loop (to create multiple connections);
  <li>may be conditional.
</ul>

<p>These connection types are described in the following sections.

<p>
<p class="subheading">Single connections and channels</p>

<p><!--ned!connections-->
<!--connection-->

<p>If you do not specify a channel<!--channel-->, the connection will have
no propagation delay, no transmission delay and no bit errors:

<pre>
    node1.outGate --&gt; node2.inGate;
</pre>
<p>
You can specify a channel by its name<!--channel!name-->:
<pre>
    node1.outGate --&gt; Fiber --&gt; node2.inGate;
</pre>

<p>In this case, the NED sources must contain the definition of
the channel.

<p>One can also specify the channel parameters directly<!--channel!parameters-->:
<pre>
    node1.outGate --&gt; error 1e-9 delay 0.001 --&gt; node2.inGate;
</pre>

<p>Either of the parameters can be omitted and they can be in any
order.

<p>
<p class="subheading">Loop connections</p>

<p>
If submodule or gate vectors are used, it is possible to create
more than one connection with one statement. This is termed a <i>multiple</i>
or <i>loop connection</i><!--connection!loop-->.

<p>A multiple connection is created with the <tt>for</tt>
statement:

<p><pre>
<b>for</b> i=0..4 <b>do</b>
    node1.outGate[i] --&gt; node2[i].inGate
<b>endfor</b>;
</pre>

<p>
The result of the above loop connection can be illustrated as
depicted in Fig. <a href="#fig:ch-ned-lang:loop-connection">below</a>.

<p>
<div align=center>
<img src="usmanFig7.png">
<center><i>Figure: Loop connection</i></center>
<a name="fig:ch-ned-lang:loop-connection"></a>
</div>

<p>

<p>One can place several connections in the body of the
<tt>for</tt> statement, separated by semicolons.

<p>One can create nested loops<!--ned!nested for statements-->
by specifying more than one indices in the <tt>for</tt> statement,
with the first variable forming the outermost loop.

<p><pre>
<b>for</b> i=0..4, j=0..4 <b>do</b>
    //...
<b>endfor</b>;
</pre>

<p>One can also use an index in the lower and upper bound expressions
of the subsequent indices:

<p><pre>
<b>for</b> i=0..3, j=i+1..4 <b>do</b>
    //...
<b>endfor</b>;
</pre>

<p>
<p class="subheading">Conditional connections</p>

<p><!--connection!conditional-->

<p>Creation of a connection can be made conditional, using the <tt>if</tt>
keyword:

<p><!--ned!keywords!if-->

<p><pre>
<b>for</b> i=0..n <b>do</b>
    node1.outGate[i] --&gt; node2[i].inGate <b>if</b> i%2==0;
<b>endfor</b>;
</pre>

<p>The <tt>if</tt> condition is evaluated for each connection
(in the above example, for each <i>i</i> value), and the
decision is made individually each time whether to create the
the connection or not. In the above example we connected every
second gate. Conditions may also use random variables, as
shown in the next section.

<p>
<p class="subheading">The nocheck modifier</p>

<p>By default, NED requires that all gates be connected. Since this
check can be inconvenient at times, it can be turned off
using the <tt>nocheck</tt> modifier.

<p>The following example generates a random subgraph of a full graph.

<p><pre>
<b>module</b> RandomConnections
    <b>parameters</b>: //..
    <b>gates</b>: //..
    <b>submodules</b>: //..
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..n-1, j=0..n-1 <b>do</b>
            node[i].out[j] --&gt; node[j].in[i] <b>if</b> uniform(0,1)&lt;0.3;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>When using <tt>nocheck</tt>, it is the
simple modules' responsibility not to send messages on gates
that are not connected.

<p>
<H2><A NAME="sec127"/>3.6 Networks</H2>
<a name="sec:ch-ned-lang:network"></a>
<!--ned!network definition-->

<p>A <i>network</i> is nothing else than a module type (simple or compound
module) which is a self-contained simulation model itself.

<p>A module type becomes a network by adding the <tt>@isNetwork(true)</tt> property
to it. Examples:

<p><pre>
module FifoNet
{
    parameters: // this is optional
        @isNetwork(true);
    submodules:
        src: Source;
        fifo: Fifo;
        sink: Sink;
    connections:
        src.out --&gt; fifo.in;
        fifo.out --&gt; sink.in;
}
</pre>

<p>Since a compound module with <tt>@isNetwork(true)</tt> occurs very frequently, there
is a shortcut for it: the <tt>network</tt> keyword. Thus, the above example can be
somewhat shortened to:

<p><pre>
network FifoNet
{
    submodules:
        src: Source;
        fifo: Fifo;
        sink: Sink;
    connections:
        src.out --&gt; fifo.in;
        fifo.out --&gt; sink.in;
}
</pre>

<p>There can be several network definitions in your NED file or NED files.
The simulation program that uses those NED files will be
able to run any of them; you typically select the desired one
in the config file (<tt>omnetpp.ini</tt>).

<p>Naturally, only module that has no gates can be a network.

<p>
<H2><A NAME="sec128"/>3.7 Inheritance</H2>

<p>Single inheritance is supported between modules, ie. you can further
specialize the above module:
FIXME TODO

<p><H2><A NAME="sec129"/>3.8 Packages</H2>

<p>To address increasingly common name collisions in NED files,
OMNeT++ 4.0 introduces a package feature for NED. The solution
is roughly modelled after Java's packages, with minor enhancements.

<p>
<H3><A NAME="sec130"/>3.8.1 Packages, imports</H3>

<p>A NED file may contain a package declaration:

<p><pre>
<b>package</b> inet.protocols.transport.tcp;
</pre>

<p>If there is no package declaration, the file is said to be in the
<i>default package</i>.

<p>Names from other NED files can be referred to either by fully qualified
name (<tt>"inet.protocols.network.ip.RoutingTable"</tt>), or by short name
(<tt>"RoutingTable"</tt>) if the name is visible.

<p>Visible names are:
<ul>
  <li> anything from the same package;
  <li> imported names.
</ul>

<p>Import directives also have a similar syntax to Java, but they
are more flexible with wildcards. All of the following are legal:

<p><pre>
<b>import</b> inet.protocols.network.ip.RoutingTable;
<b>import</b> inet.protocols.network.ip.*;
<b>import</b> inet.protocols.network.ip.Ro*Ta*;
<b>import</b> inet.protocols.*.ip.*;
<b>import</b> inet.**.RoutingTable;
</pre>

<p>One asterisk "*" stands for "any character sequence not containing
period"; two asterisks mean "any character sequence which may
contain period". No other wildcards are recognized.

<p>An import not containing wildcard MUST match an existing NED type.
However, it is legal for an import that does contain wildcards
not to match any NED type (although that might generate a warning.)

<p>Inner types may not be referred to outside their enclosing types.

<p>
<H3><A NAME="sec131"/>3.8.2 Directory Structure, package.ned</H3>

<p>Like in Java, the directory of a NED file MUST match the package declaration.
However, it is possible to omit directories at the top which don't
contain any NED files (like the "/org/projectname/" directories in Java).

<p>There is a notion of "NED source folders". If a NED Source Folder is
named "src", then a NED file containing the package declaration
"inet.protocols.transport.tcp" must be in the following folder:

<p><pre>
src/inet/protocols/transport/tcp/
</pre>

<p>If the "inet" and "protocols" directories don't contain any NED files,
they can be omitted:

<p><pre>
src/transport/tcp
</pre>

<p>and the "src" directory must contain a "package.ned" file which declares
what package it corresponds to:

<p><pre>
// file src/package.ned:
package inet.protocols;
</pre>

<p>All NED files under the "src" directory tree must have package
declarations consistent with that.

<p>"package.ned" files are allowed in other folders as well (as long as
their package declarations are consistent with the NED source
directory's "package.ned"), and any file-level comment in them
will be treated as the package's documentation (similar to Java's
package.html).

<p>
<H3><A NAME="sec132"/>3.8.3 Name lookups</H3>

<p><p class="subheading">Base types and submodules</p>

<p>Fully qualified names and simple names are accepted. Simple names
are looked up among the inner types of the enclosing type (compound
module), then using imports, then in the same package.

<p>
<p class="subheading">Parametric module types ("like" submodules)</p>

<p>Lookup of the actual module type for "like" submodules differs for normal
lookups. This lookup ignores the imports in the file altogether.
Instead, it collects all modules that support the given interface
and match the given type name string (i.e. end in the same simple name,
or have the same fully qualified name). The result must be exactly
one module type.

<p>The algorithm for parametric channel types works in the same way.

<p>
<p class="subheading">Network name in the ini file</p>

<p>Simple (unqualified) names are tried with the same package as the
ini file is in (provided it's in a NED directory).

<p>

<p><H3><A NAME="sec133"/>3.8.4 The NEDPATH environment variable</H3>

<p>A simulation may need NED files from several "NED source folders".
When a simulation is launched as a separate application, it will expect
to receive the list of NED source folders to scan in the NEDPATH
environment variable (similar to Java's CLASSPATH). NEDPATH should
contain the source folder names separated by a semicolon (";").
On Unix-like systems, colon (":") will also be accepted as separator.

<p>In the future, zip files may become supported in NEDPATH as well;
then the root folder of the zip file will be treated as a NED source
folder.

<p>
<H3><A NAME="sec134"/>3.8.5 OMNeT++ Projects in Eclipse</H3>

<p>OMNeT++ projects within Eclipse are marked with the "OMNEST/OMNeT++ Nature",
that is, those projects marked with that nature will be recognized as
OMNeT++ projects.

<p>NED source folders can only be located within OMNeT++ projects. (That is,
NED files within non-OMNeT++ projects will be always ignored.)

<p>Which folders in a project are NED source folders is determined by
the ".nedfolders" file in the project root directory. This is a plain
text file, which contains directory names (as relative to the
project root directory), one per line. If the ".nedfolders" file is
missing, then the project root directory will be treated as the (only)
NED source folder.

<p>
<H3><A NAME="sec135"/>3.8.6 Cross-Project Dependencies</H3>

<p>OMNeT++ projects in Eclipse may refer to NED files in other projects.
This feature is supported by making use of the Eclipse Platform's
support for project dependencies. (In the Eclipse Platform, for any
project one can define the list other projects it depends on.)

<p>In one project, one may only refer to NED files in the same project
or dependent projects.

<p>
<H2><A NAME="sec136"/>3.9 Inner types</H2>
FIXME TODO

<p><H2><A NAME="sec137"/>3.10 Interfaces</H2>
FIXME TODO

<p><H2><A NAME="sec138"/>3.11 Metadata annotations</H2>
FIXME TODO

<p>
<H2><A NAME="sec139"/>3.12 Parameters</H2>
<a name="sec:ch-ned-lang:simple-module-param"></a>
<!--module!parameters-->

<p>
Parameters are variables that belong to a module. Simple module
parameters can be queried and used by simple module algorithms.
For example, a module called <tt>TrafficGen</tt> may have a parameter
called <tt>numOfMessages</tt> that determines how many messages it
should generate.

<p>Parameters are identified by names.
By convention, parameter names begin with lower-case letters.

<p>Parameters are declared by listing their names in the
<tt>parameters:</tt> section of a module description.
The parameter type can optionally be specified as <tt>numeric</tt>,
<tt>numeric const</tt> (or simply <tt>const</tt>), <tt>bool</tt>, <tt>string</tt>,
or <tt>xml</tt>. If the parameter type is omitted, <tt>numeric</tt> is assumed.

<p>Example:

<p><pre>
<b>simple</b> TrafficGen
    <b>parameters</b>:
        interarrivalTime,
        numOfMessages : <b>const</b>,
        address : <b>string</b>;
    <b>gates</b>: //...
<b>endsimple</b>
</pre>

<p>Parameters are assigned from NED (when the module is used as a building block
of a larger compound module) or from the config file <tt>omnetpp.ini</tt>.
<tt>omnetpp.ini</tt> is described in Chapter <a href="#sec287">[8]</a>.

<p>
<H3><A NAME="sec140"/>3.12.1 Random parameters and const</H3>
<a name="sec:ch-ned-lang:const"></a>
<!--const-->
<!--module!parameters!const-->

<p>Numeric parameters can be set to return random numbers, uniformly
distributed or from various distributions. For example, setting a
parameter to <tt>truncnormal(2,0.8)</tt> would return a new random number
from the truncated normal distribution with mean 2.0 and standard deviation 0.8
every time the parameter is read from the simple module (from C++ code).
For example, this is useful for specifying interarrival times for generated
packets or jobs.

<p>You may want the initial parameter value to be chosen randomly, but not
to change it afterwards. This can be achieved with declaring the parameter
to be <tt>const</tt>. <tt>const</tt> parameters will be evaluated only once
at the beginning of the simulation then set to a constant value.

<p>It is recommended to mark every parameter with <tt>const</tt> unless
you really want to make use of the random numbers feature.

<p>
<H3><A NAME="sec141"/>3.12.2 XML parameters</H3>
<!--xml-->
<!--module!parameters!xml-->

<p>Sometimes modules need more complex input than simple module parameters
can describe. Then you'd put these parameters into an external config file,
and let the modules read and process the file. You'd pass the file name
to the modules in a string parameter.

<p>These days, XML is increasingly becoming a standard format for configuration
files as well, so you might as well describe your configuration in XML.
From the 3.0 version, OMNeT++ contains built-in support for XML config files.

<p>OMNeT++ wraps the XML parser (LibXML, Expat, etc.), reads and DTD-validates
the file (if the XML document contains a DOCTYPE), caches the file
(so that if you refer to it from several modules, it'll still be loaded
only once), lets you pick parts of the document via an XPath-subset notation,
and presents the contents to you in a DOM-like object tree.

<p>This machinery can be accessed via the NED parameter type <tt>xml</tt>, and the
<tt>xmldoc()</tt> operator. You can point <tt>xml</tt>-type module parameters
to a specific XML file (or to an element inside an XML file) via the
<tt>xmldoc()</tt> operator. You can assign <tt>xml</tt> parameters both from NED
and from <tt>omnetpp.ini</tt>.

<p>

<p>
<H2><A NAME="sec142"/>3.13 Gates</H2>
<a name="sec:ch-ned-lang:simple-module-gates"></a>

<p><!--gate-->
<!--module!simple!gates-->

<p>Gates are the connection points of modules. The starting and
ending points of the connections between modules are gates. OMNeT++
supports simplex (one-directional) connections, so there are
input and output gates. Messages are sent through
output gates and received through input gates.

<p>Gates are identified by their names.
By convention, gate names begin with lower-case letters.

<p>Gate vectors are supported: a gate vector<!--gate!vector-->
contains a number of single gates.

<p>Gates are declared by listing their names in the
<tt>gates:</tt> section of a module description. An
empty bracket pair [] denotes a gate vector<!--gate!vector-->.
Elements of the vector are numbered from zero.

<p>Examples:

<p><pre>
<b>simple</b> NetworkInterface
    <b>parameters</b>: //...
    <b>gates</b>:
        <b>in</b>:  fromPort, fromHigherLayer;
        <b>out</b>: toPort, toHigherLayer;
<b>endsimple</b>

<b>simple</b> RoutingUnit
    <b>parameters</b>: //...
    <b>gates</b>:
        <b>in</b>:  output[];
        <b>out</b>: input[];
<b>endsimple</b>
</pre>

<p>The sizes of gate vectors are given later, when the module is used as
a building block of a compound module type. Thus, every instance of
the module can have gate vectors of different sizes.

<p><H2><A NAME="sec143"/>3.14 Expressions</H2>

<p>NED expressions have a C-like syntax, with

<p><H3><A NAME="sec144"/>3.14.1 Defining new functions</H3>
<!--ned!functions-->
<a name="sec:ch-ned-lang:defining-functions"></a>

<p>To use user-defined functions<!--functions!user-defined-->, one has
to code the function in C++.  The C++ function must take 0, 1, 2, 3, or 4
arguments of type double and return a double. The function must be
registered in one of the C++ files with the <tt>Define_Function()</tt>
macro.

<p>An example function (the following code must appear in one of the C++
sources):

<p>
<pre>
#include &lt;omnetpp.h&gt;

double average(double a, double b)
{
  return (a+b)/2;
}

Define_Function(average, 2);
</pre>

<p>
The number 2 means that the <tt>average()</tt> function has 2
arguments.  After this, the <tt>average()</tt> function can be used in
NED files:

<p>
<pre>
<b>module</b> Compound
    <b>parameter</b>: a,b;
    <b>submodules</b>:
        proc: Processor
            <b>parameters</b>: av = average(a,b);
<b>endmodule</b>
</pre>

<p>
If your function takes parameters that are <tt>int</tt> or <tt>long</tt> or
some other type which is not <tt>double</tt>, you can create wrapper function
that takes all doubles and does the conversion. In this case you have
to register the wrapper function with the <tt>Define_Function2()</tt> macro
which allows a function to be registered with a name different from the
name of the function that implements it. You can do the same
if the return value differs from <tt>double</tt>.

<pre>
#include &lt;omnetpp.h&gt;

long factorial(int k)
{
  ...
}

static double _wrap_factorial(double k)
{
  return factorial((int)k);
}

Define_Function2(factorial, _wrap_factorial, 1);
</pre>
<p>

<p><H2><A NAME="sec145"/>3.15 Submodule type as parameter</H2>
<a name="sec:ch-ned-lang:like"></a>

<p>Sometimes it is convenient to make the name of a submodule type a parameter,
so that one can easily `plug in' any module there.

<p>For example, assume the purpose of your simulation study is
to compare different routing algorithms. Suppose you programmed
the needed routing algorithms as simple modules: <tt>DistVecRoutingNode</tt>,
<tt>AntNetRouting1Node</tt>, <tt>AntNetRouting2Node</tt>, etc.
You have also created the network topology as a compound module
called <tt>RoutingTestNetwork</tt>, which will serve as a testbed for your routing
algorithms. Currently, <tt>RoutingTestNetwork</tt> has <tt>DistVecRoutingNode</tt>
hardcoded (all submodules are of this type), but you want
to be able to switch to other routing algorithms easily.

<p>NED gives you the possibility to add a string-valued parameter,
say <tt>routingNodeType</tt> to the <tt>RoutingTestNetwork</tt> compound module.
Then you can tell NED that types of the submodules inside <tt>RoutingTestNetwork</tt>
are not of any fixed module type, but contained in the <tt>routingNodeType</tt>
parameter. That is all -- now you are free to assign any of
the <tt>"DistVecRoutingNode"</tt>, <tt>"AntNetRouting1Node"</tt> or
<tt>"AntNetRouting2Node"</tt> string constants to this parameter
(you can do that in NED, in the config file (<tt>omnetpp.ini</tt>),
or even enter it interactively),
and your network will use the routing algorithm you chose.

<p>If you specify a wrong value, say <tt>"FooBarRoutingNode"</tt>
when you have no <tt>FooBarRoutingNode</tt> module implemented,
you'll get a runtime error at the beginning of the simulation:
<i>module type definition not found</i>.

<p>Inside the <tt>RoutingTestNetwork</tt> module you assign parameter values
and connect the gates of the routing modules. To provide some degree
of type safety, NED wants to make sure you didn't misspell
parameter or gate names and you used them correctly.
To be able to do such checks, NED requires some help from you:
you have to name an existing module type (say <tt>RoutingNode</tt>)
and promise NED that all modules you're going you specify
in the <tt>routingNodeType</tt> parameter will have (at least) the same
parameters and gates as the <tt>RoutingNode</tt> module.
  <br><ul><font size=-1>[If you like, the above solution somewhat similar to polymorphism
  in object-oriented languages -- <tt>RoutingNode</tt> is like a
  ``base class'', <tt>DistVecRoutingNode</tt> and <tt>AntNetRouting1Node</tt>
  are like ``derived classes'', and the <tt>routingNodeType</tt> parameter
  is like a ``pointer to a base class'' which may be downcast to specific
  types.]</font></ul>

<p>All the above is achieved via the <tt>like</tt> keyword.
The syntax is the following:

<p><pre>
<b>module</b> RoutingTestNetwork
    <b>parameters</b>:
        routingNodeType: <b>string</b>; // should hold the name
                                  // of an existing module type
    <b>gates</b>: //...
    <b>submodules</b>:
        node1: routingNodeType <b>like</b> RoutingNode;
        node2: routingNodeType <b>like</b> RoutingNode;
        //...
    <b>connections nocheck</b>:
        node1.out0 --&gt; node2.in0;
        //...
<b>endmodule</b>
</pre>

<p>The <tt>RoutingNode</tt> module type does not need to be implemented in
C++, because no instance of it is created; it is merely used
to check the correctness of the NED file.

<p>On the other hand, the actual module types that will be substituted
(e.g. <tt>DistVecRoutingNode</tt>, <tt>AntNetRouting1Node</tt>,etc.)
do not need to be declared in the NED files.

<p>The <tt>like</tt> phrase lets you create families
of modules that serve similar purposes and implement the same interface
(they have the same gates and parameters)
and to use them interchangeably in NED files.

<p>
<H2><A NAME="sec146"/>3.16 Parameterized compound modules</H2>

<p><!--module!compound-->

<p>With the help of conditional parameter and gatesize blocks and
conditional connections<!--connection!conditional-->, one can
create complex topologies.

<p>
<H3><A NAME="sec147"/>3.16.1 Examples</H3>

<p><p class="subheading">Example 1: Router</p>

<p>The following example contains a router module with the number of
ports taken as parameter. The compound module is built using three
module types: Application, RoutingModule, DataLink. We assume that
their definition is in a separate NED file which we will import.

<p><pre>
<b>import</b> "modules";

<b>module</b> Router
    <b>parameters</b>:
        rteProcessingDelay, rteBuffersize,
        numOfPorts: <b>const</b>;
    <b>gates</b>:
        <b>in</b>: inputPorts[];
        <b>out</b>: outputPorts[];
    <b>submodules</b>:
        localUser: Application;
        routing: RoutingUnit
            <b>parameters</b>:
                processingDelay = rteProcessingDelay,
                buffersize = rteBuffersize;
            <b>gatesizes</b>:
                input[numOfPorts+1],
                output[numOfPorts+1];
        portIf: PPPNetworkInterface[numOfPorts]
            <b>parameters</b>:
                retryCount = 5,
                windowSize = 2;
    <b>connections</b>:
        <b>for</b> i=0..numOfPorts-1 <b>do</b>
            routing.output[i] --&gt; portIf[i].fromHigherLayer;
            routing.input[i] &lt;-- portIf[i].toHigherLayer;
            portIf[i].toPort --&gt; outputPorts[i];
            portIf[i].fromPort &lt;-- inputPorts[i];
        <b>endfor</b>;
        routing.output[numOfPorts] --&gt; localUser.input;
        routing.input[numOfPorts] &lt;-- localUser.output;
<b>endmodule</b>
</pre>

<p>
<p class="subheading">Example 2: Chain</p>

<p>
For example, one can create a chain<!--chain--> of modules like this:

<p><pre>
<b>module</b> Chain
    <b>parameters</b>: count: <b>const</b>;
    <b>submodules</b>:
        node : Node [count]
            <b>gatesizes</b>:
                in[2], out[2];
            <b>gatesizes</b> <b>if</b> index==0 || index==count-1:
                in[1], out[1];
    <b>connections</b>:
        <b>for</b> i = 0..count-2 <b>do</b>
            node[i].out[i!=0 ? 1 : 0] --&gt; node[i+1].in[0];
            node[i].in[i!=0 ? 1 : 0] &lt;-- node[i+1].out[0];
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>
<p class="subheading">Example 3: Binary Tree</p>

<p>
One can use conditional connections to build a binary tree<!--binary tree-->.
The following NED code loops through all possible node pairs, and
creates the connections needed for a binary tree.

<p><pre>
<b>simple</b> BinaryTreeNode
    <b>gates</b>:
        <b>in</b>: fromupper;
        <b>out</b>: downleft;
        <b>out</b>: downright;
<b>endsimple</b>

<b>module</b> BinaryTree
    <b>parameters</b>:
        height: <b>const</b>;
    <b>submodules</b>:
        node: BinaryTreeNode [ 2^height-1 ];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i = 0..2^height-2, j = 0..2^height-2 <b>do</b>
            node[i].downleft --&gt; node[j].fromupper <b>if</b> j==2*i+1;
            node[i].downright --&gt; node[j].fromupper <b>if</b> j==2*i+2;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>Note that not every gate of the modules will be connected. By default,
an unconnected gate produces a run-time error message when the
simulation is started, but this error message is turned off here with
the <tt>nocheck</tt> modifier.  Consequently, it
is the simple modules' responsibility not to send on a gate which is
not leading anywhere.

<p>An alert reader might notice that there is a better alternative
to the above code. Each node except the ones at the lowest level
of the tree has to be connected to exactly two nodes,
so we can use a single loop to create the connections.

<p><pre>
<b>module</b> BinaryTree2
    <b>parameters</b>:
        height: <b>const</b>;
    <b>submodules</b>:
        node: BinaryTreeNode [ 2^height-1 ];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..2^(height-1)-2 <b>do</b>
            node[i].downleft --&gt; node[2*i+1].fromupper;
            node[i].downright --&gt; node[2*i+2].fromupper;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>

<p><p class="subheading">Example 4: Random graph</p>

<p>Conditional connections can also be used to generate random
topologies<!--topology!random-->.  The following code generates a
random subgraph of a full graph:

<p><pre>
<b>module</b> RandomGraph
    <b>parameters</b>:
        count: <b>const</b>,
        connectedness; // 0.0&lt;x&lt;1.0
    <b>submodules</b>:
        node: Node [count];
            <b>gatesizes</b>: <b>in</b>[count], <b>out</b>[count];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..count-1, j=0..count-1 <b>do</b>
            node[i].out[j] --&gt; node[j].in[i]
                <b>if</b> i!=j && uniform(0,1)&lt;connectedness;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>Note the use of the <tt>nocheck</tt> modifier
here too, to turn off error messages given by the network setup code
for unconnected gates.

<p>
<H3><A NAME="sec148"/>3.16.2 Design patterns for compound modules</H3>

<p><!--module!compound!patterns-->
<!--topology!patterns-->

<p>Several approaches can be used when you want to create complex
topologies which have a regular structure; three of them are
described below.

<p>
<p class="subheading">`Subgraph of a Full Graph'</p>

<p>
This pattern takes a subset of the connections of a full graph.  A
condition is used to ``carve out'' the necessary interconnection from
the full graph:

<p><pre>
for i=0..N-1, j=0..N-1 do
    node[i].out[...] --&gt; node[j].in[...] if condition(i,j);
endfor;
</pre>

<p>The RandomGraph compound module (presented earlier) is an example of
this pattern, but the pattern can generate any graph where an
appropriate <i>condition(i,j)</i> can be formulated. For example,
when generating a tree<!--topology!tree--> structure, the condition
would return whether node <i>j</i> is a child of node <i>i</i> or
vica versa.

<p>Though this pattern is very general, its usage can be prohibitive if
the <i>N</i> number of nodes is high and the graph is sparse (it has
much fewer connections that <i>N<sup>2</sup></i>). The following
two patterns do not suffer from this drawback.

<p>
<p class="subheading">`Connections of Each Node'</p>

<p>The pattern loops through all nodes and creates the necessary
connections for each one. It can be generalized like this:

<p><pre>
for i=0..Nnodes, j=0..Nconns(i)-1 do
    node[i].out[j] --&gt; node[rightNodeIndex(i,j)].in[j];
endfor;
</pre>

<p>The Hypercube<!--topology!hypercube--> compound module (to be
presented later) is a clear example of this approach. BinaryTree can
also be regarded as an example of this pattern where the inner j loop
is unrolled.

<p>The applicability of this pattern depends on how easily the <i>rightNodeIndex(i,j)</i>
function can be formulated.

<p>
<p class="subheading">`Enumerate All Connections'</p>

<p>
A third pattern is to list all connections within a loop:

<p><pre>
for i=0..Nconnections-1 do
    node[leftNodeIndex(i)].out[...] --&gt; node[rightNodeIndex(i)].in[...];
endfor;
</pre>

<p>The pattern can be used if <i>leftNodeIndex(i)</i> and <i>rightNodeIndex(i)</i>
mapping functions can be sufficiently formulated.

<p>The Serial module is an example of this approach where the mapping
functions are extremely simple: <i>leftNodeIndex(i)=i</i> and <i>rightNodeIndex(i)=i+1</i>.
The pattern can also be used to create a random subset of a full
graph with a fixed number of connections.

<p>In the case of irregular structures where none of the above patterns
can be employed, you can resort to specifying constant submodule/gate
vector sizes and explicitly listing all connections, like you
would do it in most existing simulators.

<p>

<p>
<H3><A NAME="sec149"/>3.16.3 Topology templates</H3>
<a name="sec:ch-ned-lang:topology-templates"></a>

<p>
<p class="subheading">Overview</p>

<p>
Topology templates are nothing more than compound modules where one or
more submodule types are left as parameters (using the
<tt>like</tt> phrase of the NED language).  You can
write such modules which implement mesh<!--topology!mesh-->,
hypercube<!--topology!hypercube-->,
butterfly<!--topology!butterfly-->, perfect
shuffle<!--topology!perfect shuffle--> or other topologies, and you
can use them wherever needed in you simulations.  With topology
templates<!--topology!templates-->, you can reuse
<i>interconnection structure</i>.

<p>

<p><p class="subheading">An example: hypercube</p>

<p>
The concept is demonstrated on a network with hypercube interconnection.
When building an N-dimension hypercube, we can exploit the fact
that each node is connected to N others which differ from it
only in one bit of the binary representations of the node indices
(see Fig. <a href="#fig:ch-ned-lang:hypercube-topology">below</a>).

<p>
  <div align=center>
    <img src="usmanFig8.png">
    <center><i>Figure: Hypercube topology</i></center>
    <a name="fig:ch-ned-lang:hypercube-topology"></a>
  </div>

<p>

<p>The hypercube topology<!--topology!hypercube--> template is the
following (it can be placed into a separate file, e.g <tt>hypercube.ned</tt>):

<p>
<pre>
<b>simple</b> Node
    <b>gates</b>:
        <b>out</b>: out[];
        <b>in</b>: in[];
<b>endsimple</b>

<b>module</b> Hypercube
    <b>parameters</b>:
        dim, nodetype;
    <b>submodules</b>:
        node: nodetype[2^dim] <b>like</b> Node
        <b>gatesizes</b>:
            out[dim], in[dim];
    <b>connections</b>:
        <b>for</b> i=0..2^dim-1, j=0..dim-1 <b>do</b>
            node[i].out[j] --&gt; node[i # 2^j].in[j]; // # is bitwise XOR
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>

<p>When you create an actual hypercube, you substitute the name
of an existing module type (e.g. <tt>"Hypercube_PE"</tt>) for the nodetype
parameter. The module type implements the algorithm the user
wants to simulate and it must have the same gates that the Node
type has. The topology template code can be used through importing
the file:

<p>
<pre>
<b>import</b> "hypercube.ned";

<b>simple</b> Hypercube_PE
    <b>gates</b>: <b>out</b>: out[]; <b>in</b>: in[];
<b>endsimple</b>

<b>network</b> hypercube: Hypercube
    <b>parameters</b>:
        dim = 4,
        nodetype = "Hypercube_PE";
<b>endnetwork</b>
</pre>

<p>

<p>If you put the nodetype parameter to the ini file, you can use the
same simulation model to test e.g. several routing algorithms in a
hypercube, each algorithm implemented with a different
simple module type -- you just have to supply
different values to nodetype, such as <tt>"WormholeRoutingNode"</tt>,
<tt>"DeflectionRoutingNode"</tt>, etc.

<p>

<p><H2><A NAME="sec150"/>3.17 Large networks</H2>

<p>There are situations when using hand-written NED files to describe
network topology is inconvenient, for example when
the topology information comes from
an external source<!--topology!external source--> like
a network management program.

<p>In such case, you have two possibilities:

<p><ol>
  <li>generating NED files from data files
  <li>building the network from C++ code
</ol>

<p>The two solutions have different advantages and disadvantages.
The first is more useful in the model development phase, while
the second one is better for writing larger scale, more productized
simulation programs. In the next sections we examine both methods.

<p>

<p><H3><A NAME="sec151"/>3.17.1 Generating NED files</H3>

<p>
Text processing programs like <tt>awk</tt> or <tt>perl</tt> are
excellent tools to read in textual data files and generate NED files
from them<!--ned!file generation-->.  Perl also has extensions to
access SQL databases, so it can also be used if the network topology
is stored in a database.

<p>The advantage is that the necessary <tt>awk</tt> or <tt>perl</tt>
program can be written in a relatively short time, and it is
inexpensive to maintain afterwards: if the structure of the data files
change, the NED-creating program can be easily modified. The
resulting NED files can either be translated by <tt>nedtool</tt>
into C++ and compiled in, or loaded dynamically.

<p>
<H3><A NAME="sec152"/>3.17.2 Building the network from C++ code</H3>

<p>Another alternative is to write C++ code which becomes part of the
simulation executable. The code would read the topology data from data
files or a database, and build the network directly, using
dynamic module creation (to be described later, in section
<a href="#sec197">[4.11]</a>).
The code which you need to write would be similar to the <tt>*_n.cc</tt>
files output by <tt>nedtool</tt>.

<p>Since writing such code is more complex than letting perl generate
NED files, this method is recommended when the simulation program
has to be somewhat more productized, for example when OMNeT++
and the simulation model is embedded into a larger program, e.g.
a network design tool.

<p>
<H2><A NAME="sec153"/>3.18 XML binding for NED files</H2>

<p>To increase interoperability, NED files (and also message definition files)
have an XML representation. Any NED file can be converted to XML, and
any XML file which corresponds to the NED DTD can be converted to NED.
  <br><ul><font size=-1>[DTD stands for Document Type Descriptor, and it defines
  a "grammar" for XML files. More info can be found on the W3C web site,
  www.w3.org.]</font></ul>

<p>XML is well suited for machine processing. For example, stylesheet
transformations (XSLT) can be used to extract information from NED files,
or the other way round, create NED files from external info present in
XML form. One practical application of XML is the <tt>opp_neddoc</tt>
documentation generation tool which is described in Chapter <a href="#sec377">[12]</a>.

<p>The <tt>nedtool</tt> program (which also translates NED to C++ code)
can be used to convert between NED and XML.

<p>Converting a NED file to XML:

<pre>
nedtool -x wireless.ned
</pre>
<p>
It generates <tt>wireless_n.xml</tt>.
Several switches control the exact content and details
of the resulting XML as well as the amount of checks
made on the input.

<p>Converting the XML representation back to NED:

<pre>
nedtool -n wireless.xml
</pre>
<p>
The result is <tt>wireless_n.ned</tt>.

<p>Using nedtool as NED compiler to generate C++ code:

<pre>
nedtool wireless.ned
</pre>
<p>
The resulting code is more compact than the
one created by <tt>nedtool</tt>'s predecessor <tt>nedc</tt>.
As a result, <tt>nedtool</tt>-created <tt>_n.cc</tt>
C++ files compile much faster.

<p>You can generate C++ code from the XML format as well:

<pre>
nedtool wireless.xml
</pre>
<p>


<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec154"/>4 Simple Modules</H1>
<a name="cha:simple-modules"></a>
<!--module!simple-->

<p>
<i>Simple modules</i> are the active components in the model.
Simple modules are programmed in C++, using the OMNeT++ class
library. The following sections contain a short introduction
to discrete event simulation in general, explain how its concepts are
implemented in OMNeT++, and give an overview and practical advice
on how to design and code simple modules.

<p>

<p><H2><A NAME="sec155"/>4.1 Simulation concepts</H2>

<p>This section contains a very brief introduction into how Discrete
Event Simulation (DES) works, in order to introduce terms we'll use
when explaining OMNeT++ concepts<!--simulation!concepts--> and
implementation.

<p>
<H3><A NAME="sec156"/>4.1.1 Discrete Event Simulation</H3>

<p>A <i>Discrete Event System</i> is a system where state changes
(events<!--events-->) happen at discrete instances in time, and events take zero time
to happen. It is assumed that nothing (i.e. nothing interesting)
happens between two consecutive events, that is, no state change takes
place in the system between the events (in contrast to
<i>continuous</i> systems where state changes are continuous). Those
systems that can be viewed as Discrete Event Systems can be modeled
using Discrete Event Simulation<!--discrete event simulation-->.
(Other systems can be modelled e.g. with continuous simulation models.)

<p>For example, computer networks are usually viewed as discrete
event systems. Some of the events are:

<p><ul>
  <li>start of a packet transmission
  <li>end of a packet transmission
  <li>expiry of a retransmission timeout
</ul>

<p>
This implies that between two events such as <i>start of a packet
transmission</i> and <i>end of a packet transmission</i>, nothing
interesting happens. That is, the packet's state remains <i>being
transmitted</i>. Note that the definition of ``interesting'' events and states always
depends on the intent and purposes of the person doing the modeling.
If we were interested in the transmission of individual bits, we would
have included something like <i>start of bit transmission</i> and
<i>end of bit transmission</i> among our events.

<p>
The time when events occur is often called <i>event timestamp</i>
<!--event timestamp-->; with OMNeT++ we'll say
<i>arrival time</i><!--arrival time--> (because in the class
library, the word ``timestamp'' is reserved for a user-settable
attribute in the event class). Time within the model is often called
<i>simulation time</i><!--simulation time-->, <i>model time</i>
<!--model!time--> or <i>virtual time</i><!--virtual time-->
as opposed to real time<!--real time--> or CPU time<!--CPU time-->
which refer to how long the simulation program has been running and
how much CPU time it has consumed.

<p>

<p><H3><A NAME="sec157"/>4.1.2 The event loop</H3>

<p>Discrete event simulation maintains the set of future
events<!--future events--> in a data structure often called
FES<!--FES--> (Future Event Set) or FEL<!--FEL--> (Future Event List).
Such simulators usually work according to the following pseudocode:

<p><pre>
<i>initialize -- this includes building the model and</i>
              <i>inserting initial events to FES</i>

<i>while (FES not empty and simulation not yet complete)</i>
<i>{</i>
    <i>retrieve first event from FES</i>
    <i>t:= timestamp of this event</i>
    <b><i>process event</i></b>
    <i>(processing may insert new events in FES or delete existing ones)</i>
<i>}</i>
<i>finish simulation (write statistical results, etc.)</i>
</pre>

<p>
The first, initialization step usually builds the data structures
representing the simulation model, calls any user-defined
initialization code, and inserts initial events<!--initial events-->
into the FES<!--FES--> to ensure that the simulation can start. Initialization
strategy can differ considerably from one simulator to another.

<p>
The subsequent loop consumes events from the FES<!--FES--> and processes
them. Events are processed in strict timestamp order in order
to maintain causality, that is, to ensure that no event may have
an effect on earlier events.

<p>Processing an event involves calls to user-supplied code. For example,
using the computer network simulation example, processing a ``timeout
expired'' event may consist of re-sending a copy of the network
packet, updating the retry count, scheduling another ``timeout''
event, and so on. The user code may also remove events from the FES<!--FES-->,
for example when canceling timeouts.

<p>The simulation stops when there are no events left (this happens
rarely in practice), or when it isn't necessary for the simulation
to run further because the model time or the CPU time has reached
a given limit, or because the statistics have reached the desired
accuracy. At this time, before the program exits, the user
will typically want to record statistics into output files.

<p>

<p><H3><A NAME="sec158"/>4.1.3 Simple modules in OMNeT++</H3>
<a name="sec:simple-modules-in-opp"></a>

<p>In OMNeT++, events occur inside simple modules<!--module!simple-->.
Simple modules encapsulate C++ code that generates events and reacts to events,
in other words, implements the behaviour of the model.

<p>The user creates simple module types by subclassing the <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>
class, which is part of the OMNeT++ class library.
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, just as <tt><a href="../api/classcCompoundModule.html">cCompoundModule</a></tt>, is derived
from a common base class, <tt><a href="../api/classcModule.html">cModule</a></tt>.

<p><tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, although packed with simulation-related
functionality, doesn't do anything useful by itself -- you have
to redefine some virtual member functions to make it do useful work.

<p>
These member functions are the following:
<ul>
  <li>void <tt>initialize()</tt>
  <li>void <tt>handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)</tt>
  <li>void <tt>activity()</tt>
  <li>void <tt>finish()</tt>
</ul>

<p>In the initialization step, OMNeT++ builds the network: it creates the
necessary simple<!--module!simple--> and compound modules and
connects them according to the NED definitions. OMNeT++ also calls the
<tt>initialize()</tt> functions of all modules.

<p>The <tt>handleMessage()</tt> and <tt>activity()</tt> functions are
called during event processing. This means that the user will
implement the model's behavior in these functions.
<tt>handleMessage()</tt> and <tt>activity()</tt> implement
different event processing strategies: for each simple module, the user
has to redefine exactly one of these functions.

<p><tt>handleMessage()</tt> is a method that is called
by the simulation kernel when the module receives a message.
<tt>activity()</tt> is a coroutine-based<!--coroutine--> solution
which implements the process interaction approach (coroutines are
non-preemptive (i.e. cooperative) threads). Generally, it is recommended
that you prefer <tt>handleMessage()</tt> to <tt>activity()</tt> --
mainly because <tt>activity()</tt> doesn't scale well.
Later in this chapter we'll discuss both methods including their advantages
and disadvantages.

<p>Modules written with <tt>activity()</tt> and <tt>handleMessage()</tt>
can be freely mixed within a simulation model.

<p>The <tt>finish()</tt> functions are called when the simulation
terminates successfully. The most typical use of <tt>finish()</tt>
is the recording of statistics collected during simulation.

<p>

<p><H3><A NAME="sec159"/>4.1.4 Events in OMNeT++</H3>

<p>OMNeT++ uses messages<!--message--> to represent
events<!--events-->. Each event is represented by an instance of the
<tt><a href="../api/classcMessage.html">cMessage</a></tt> class or one its subclasses; there is no separate
event class. Messages are sent from one module to another -- this
means that the place where the ``event will occur'' is the
<i>message's destination module</i>, and the model time when the
event occurs is the <i>arrival time</i><!--arrival time--> of the
message. Events like ``timeout expired'' are implemented by the
module sending a message to itself.

<p>Events are consumed from the FES<!--FES--> in arrival time order, to
maintain causality. More precisely, given two messages, the following
rules apply:
<ol>
<li>the message with <b>earlier arrival time</b> is executed
    first.  If arrival times are equal,
<li>the one with <b>smaller priority value</b> is executed first.
    If priorities are the same,
<li>the one <b>scheduled or sent earlier</b> is executed first.
</ol>

<p><i>Priority</i><!--message!priority--> is a user-assigned integer
attribute of messages.

<p><H3><A NAME="sec160"/>4.1.5 Simulation time</H3>

<p>Simulation time in OMNeT++ is represented by the C++ type <tt>simtime_t</tt>.

<p><tt>simtime_t</tt> is a typedef to <tt><a href="../api/classSimTime.html">SimTime</a></tt> class, which stores simulation
time in a 64-bit integer, using decimal fixed-point representation. The scale
exponent can be between chosen between -18 and 0, and it has global effect.
Some exponents with the ranges they provide are shown in the following table.

<p><div align=center>
  <fontmaroon><em> Unknown LaTeX command </em> \begin </font>tabular<fontmaroon><em>  </em>  </font>

<p>    Exponent & Resolution & Approx. Range <br>
     -18 & <i>10<sup>-18</sup></i>s (1as) & <i>\pm 9.22</i>s <br>
     -15 & <i>10<sup>-15</sup></i>s (1fs) & <i>\pm 153.72</i> minutes <br>
     -12 & <i>10<sup>-12</sup></i>s (1ps) & <i>\pm 106.75</i> days <br>
     -9  & <i>10<sup>-9</sup></i>s (1ns)  & <i>\pm 292.27</i> years <br>
     -6  & <i>10<sup>-6</sup></i>s (1us)  & <i>\pm 292271</i> years <br>
     -3  & <i>10<sup>-3</sup></i>s (1ms)  & <i>\pm 2.9227e8</i> years <br>
     0   & 1s                & <i>\pm 2.9227e11</i> years <br>

<p>  <fontmaroon><em> Unknown LaTeX command </em> \end </font>tabular<fontmaroon><em>  </em>  </font>
</div>

<p>Note that although simulation time cannot be negative, it is still useful to
be able to represent negative numbers, because they often arise
during the evaluation of arithmetic expressions.

<p><fontmaroon><em> Unknown LaTeX command </em> \begin </font>note<fontmaroon><em>  </em>  </font>
   Earlier OMNeT++ used <tt>double</tt> for simulation time, but this was less than
   ideal. In floating point, large values can only be represented with less
   precision, and this caused very real problems in some long simulations.
   Non-associativity (often <i>(x+y)+z \neq x+(y+z)</i>, see~[<a href="#bib-Goldberg91what">Goldberg91what</a>])
   and accumulating rounding errors meant that two <tt>double</tt> simulation
   times could not be reliably compared for equality.

<p>   OMNeT++ can still be compiled with <tt>simtime_t</tt> defined as <tt>double</tt>,
   which can occasionally be useful when porting older simulations.

<p>
The <tt><a href="../api/classSimTime.html">SimTime</a></tt> class performs additions and substractions as 64-bit integer
operations. Integer overflows are checked, and will cause the simulation to
stop with an error message. Other operations (multiplication, division, etc)
are performed in <tt>double</tt>, then converted back to integer.

<p>
<H3><A NAME="sec161"/>4.1.6 FES implementation</H3>

<p>The implementation of the FES<!--FES--> is a crucial factor in the
performance of a discrete event simulator. In OMNeT++, the FES is
implemented with <i>binary heap</i><!--binary heap-->, the most
widely used data structure for this purpose. Heap is also the best
algorithm we know, although exotic data structures like
<i>skiplist</i><!--skiplist--> may perform better than heap in some
cases. In case you're interested, the FES implementation is in the
<tt><a href="../api/classcMessageHeap.html">cMessageHeap</a></tt> class, but as a simulation programmer you won't
ever need to care about that.

<p>

<p>

<p><H2><A NAME="sec162"/>4.2 Packet transmission modeling</H2>
<a name="ch:simple-modules:packet-transmission"></a>

<p><H3><A NAME="sec163"/>4.2.1 Delay, bit error rate, data rate</H3>

<p>Connections can be assigned three parameters, which facilitate
the modeling of communication networks, but can be useful for
other models too:
<ul>
  <li>propagation delay (sec)<!--channel!delay-->
  <li>bit error rate (errors/bit)<!--channel!error-->
  <li>data rate (bits/sec)<!--channel!datarate-->
</ul>

<p>
Each of these parameters is optional. One can specify link parameters
individually for each connection, or define link types (also
called <i>channel</i> <i>types</i>) once and use them throughout the
whole model.

<p>The <i>propagation delay</i> is the amount of time the arrival of
the message is delayed by when it travels through the channel.
Propagation delay is specified in seconds.

<p>The <i>bit error rate</i> has influence on the transmission of messages
through the channel. The bit error rate (<i>ber</i>) is the probability that
a bit is incorrectly transmitted. Thus, the probability that
a message of <i>n</i> bits length is transferred without bit errors is:<br>

<p><i>P<sub>no bit error</sub> = (1 - ber)<sup>length</sup></i>

<p>The message has an error flag which is set in case of transmission
errors.

<p>The <i>data rate</i> is specified in bits/second, and it is used
for transmission delay calculation. The sending time of the message
normally corresponds to the transmission of the first bit, and
the arrival time of the message corresponds to the reception
of the last bit (Fig. <a href="#fig:ch-overview:message-transm">below</a>).

<p>
<div align=center>
<img src="usmanFig4.png">
<center><i>Figure: Message transmission</i></center>
<a name="fig:ch-overview:message-transm"></a>
</div>

<p>
The above model may not be suitable to model all protocols. In Token Ring
and FDDI, stations start to repeat bits before the whole frame arrives;
in other words, frames ``flow through'' the stations, being delayed only a few bits.
In such cases, the data rate modeling feature of OMNeT++ cannot be used.

<p>If a message travels along a path, passing through successive links and
compound modules, the model behaves as if each module waited until the
last bit of the message arrives and only started its transmission
afterwards.
(Fig. <a href="#fig:ch-overview:msg-multiple-ch">below</a>).

<p>
<div align=center>
<img src="usmanFig5.png">
<center><i>Figure: Message sending over multiple channels</i></center>
<a name="fig:ch-overview:msg-multiple-ch"></a>
</div>

<p>
Since the above effect is usually not the desired one, typically
you will want to assign data rate to only one connection in the
path.

<p>
<H3><A NAME="sec164"/>4.2.2 Multiple transmissions on links</H3>

<p>If a data rate<!--data rate--> is specified for a connection, a message
will have a certain nonzero transmission time<!--transmission
  time-->, depending on the length of the connection. This implies that
a message that is passsing through an output gate, ``reserves'' the gate
for a given period (``it is being transmitted'').

<p>
  <div align=center>
    <img src="usmanFig9.png">
    <center><i>Figure: Connection with a data rate</i></center>
    <a name="fig:ch-simple-modules:conn-w-data-rate"></a>
  </div>

<p>
While a message is under transmission, other messages have to wait
until the transmission is completed. The module sends another message while the
gate is busy, a runtime error will be thrown.

<p>The OMNeT++ class library provides functions to check
whether a certain output gate is transmitting and find out when when
it finishes transmission.

<p>If the connection with a data rate is not directly connected
to the simple module's output gate but is the second
one in the path, you have to check the second gate's busy
condition<!--gate!busy condition-->.

<p>
   In OMNeT++ versions prior to 4.0, sending on a busy gate was permitted, and
   messages got implicitly queued up. The behaviour of the simulation kernel
   was changed because in practice, sending on a busy gate was more often result
   of a programming error than calculated behaviour.

<p>

<p><p class="subheading">Implementation of message sending</p>

<p>Message sending is implemented like this: the arrival time<!--arrival time-->
and the bit error<!--bit error--> flag of a message are calculated right inside
the <tt>send()</tt> call, then the message gets inserted into the FES<!--FES-->
with the calculated arrival time. The message does <i>not</i> get scheduled
individually for each link. This implementation was chosen because of its
run-time efficiency.

<p>
   The consequence of this implementation is that any change in the
   channel's parameters (delay, bit rate, bit error rate) will only affect
   messages <i>sent</i> after the change. Messages already under way will not
   be influenced by the change.

<p>   This is not a huge problem in practice, but if it is important to model
   channels with changing parameters, the solution is to insert simple modules
   into the path to ensure strict scheduling.

<p>

<p><p class="subheading">The approach of some other simulators</p>

<p>Note that some simulators (e.g. OPNET) assign <i>packet queues</i>
to input gates (ports), and messages sent are buffered at the
destination module (or the remote end of the link) until they are
received by the destination module. With that approach, events and
messages are separate entities, that is, a <i>send</i> operation
includes placing the message in the packet queue <i>and</i> scheduling
an event, which signals the arrival of the packet. In some implementations,
output gates also have packet queues where packets will be buffered until
the channel is ready (available for transmission).

<p>OMNeT++ gates<!--gate--> don't have associated queues. The place
where sent but not yet received messages are buffered in the
FES<!--FES-->.  OMNeT++'s approach is potentially faster
than the solution mentioned above because it doesn't have the
enqueue/dequeue overhead and also spares an event creation. The
drawback is, that changes to channel parameters do not take effect
immediately.

<p>In OMNeT++ one can implement <i>point-to-point transmitter</i> modules
with packet queues if needed. For example, the INET Framework
follows this approach.

<p>

<p>
<H2><A NAME="sec165"/>4.3 Defining simple module types</H2>

<p><H3><A NAME="sec166"/>4.3.1 Overview</H3>

<p>As mentioned before <a href="#sec158">[4.1.3]</a>, a simple module<!--module!simple-->
is nothing more than a C++ class which has to be subclassed from
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, with one or more virtual member functions redefined
to define its behavior.

<p>The class has to be registered with OMNeT++ via the <tt>Define_Module()</tt> macro.
The <tt>Define_Module()</tt> line should always be put into <tt>.cc</tt> or <tt>.cpp</tt>
files and not header file (<tt>.h</tt>), because the compiler generates code from it.
      <br><ul><font size=-1>[For completeness, there is also a <tt>Define_Module_Like()</tt>
                macro, but its use is discouraged and might even be removed in
                future OMNeT++ releases.]</font></ul>

<p>The following <tt>HelloModule</tt> is about the simplest simple module one could write.
(We could have left out the <tt>initialize()</tt> method as well to make it even smaller,
but how would it say Hello then?) Note <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> as base class,
and the <tt>Define_Module()</tt> line.

<pre>
// file: HelloModule.cc
#include &lt;omnetpp.h&gt;

class HelloModule : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

// register module class with OMNeT++
Define_Module(HelloModule);

void HelloModule::initialize()
{
    ev &lt;&lt; "Hello World!\n";
}

void HelloModule::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    delete msg; // just discard everything we receive
}
</pre>
<p>
In order to be able to refer to this simple<!--module!simple--> module type
in NED files, we also need an associated NED declaration which might
look like this:

<p><pre>
// file: HelloModule.ned
<b>simple</b> HelloModule
    <b>gates</b>:
        <b>in:</b> in;
<b>endsimple</b>
</pre>

<p>
<H3><A NAME="sec167"/>4.3.2 Constructor</H3>

<p>Simple modules are never instantiated by the user directly, but rather by
the simulation kernel. This implies that one cannot write arbitrary
constructors: the signature must be what is expected by the simulation kernel.
Luckily, this contract is very simple: the constructor must be public, and must take
no arguments:

<pre>
  public:
    HelloModule();  // constructor takes no arguments
</pre>
<p>
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> itself has two constructors:
<ol>
  <li><tt><a href="../api/classcSimpleModule.html">cSimpleModule</a>()</tt> -- one without arguments
  <li><tt><a href="../api/classcSimpleModule.html">cSimpleModule</a>(size_t stacksize)</tt> -- one that accepts the coroutine
        stack size<!--module!stack size--><!--stack!size-->
</ol>

<p>The first version should be used with <tt>handleMessage()</tt> simple modules,
and the second one with <tt>activity()</tt> modules.
(With the latter, the <tt>activity()</tt> method of the module class
runs as a coroutine<!--coroutine--> which needs a separate CPU stack,
usually of 16..32K. This will be discussed in detail later.)
Passing zero stack size to the latter constructor also selects <tt>handleMessage()</tt>.

<p>Thus, the following constructor definitions are all OK, and select
<tt>handleMessage()</tt> to be used with the module:

<pre>
HelloModule::HelloModule() {...}
HelloModule::HelloModule() : <a href="../api/classcSimpleModule.html">cSimpleModule</a>() {...}
</pre>
<p>
It is also OK to omit the constructor altogether, because the
compiler-generated one is suitable too.

<p>The following constructor definition selects <tt>activity()</tt> to be used
with the module, with 16K of coroutine stack:

<pre>
HelloModule::HelloModule() : <a href="../api/classcSimpleModule.html">cSimpleModule</a>(16384) {...}
</pre>
<p>

<p>    The <tt>Module_Class_Members()</tt> macro, already deprecated in OMNeT++ 3.2,
    has been removed in the 4.0 version. When porting older simulation models,
    occurrences of this macro can simply be removed from the source code.

<p>

<p>
<H3><A NAME="sec168"/>4.3.3 Constructor and destructor vs initialize() and finish()</H3>

<p>The <tt>initialize()</tt> and <tt>finish()</tt> methods will be discussed
in a later section in detail, but because their apparent similarity
to the constructor and the destructor is prone to cause some confusion,
we'll briefly cover them here.

<p>The constructor gets called when the module is created, as part of the
model setup process. At that time, everything is just being built,
so there isn't a lot things one can do from the constructor.
In contrast, <tt>initialize()</tt> gets called just before the
simulation starts executing, when everything else has been set up
already.

<p><tt>finish()</tt> is for recording statistics, and it only gets called
when the simulation has terminated normally. It does not get called when
the simulations stops with an error message. The destructor always
gets called at the end, no matter how the simulation stopped, but
at that time it is fair to assume that the simulation model has been
halfway demolished already.

<p>Based on the above, the following conventions exist for these four methods:

<p><dl>

<p><li> Constructor:

<p>Set pointer members of the module class to <tt>NULL</tt>; postpone all other
initialization tasks to <tt>initialize()</tt>.

<p><li> <tt>initialize()</tt>:

<p>Perform all initialization tasks: read module parameters, initialize
class variables, allocate dynamic data structures with <tt>new</tt>;
also allocate and initialize self-messages (timers) if needed.

<p><li> <tt>finish()</tt>:

<p>Record statistics. Do <b>not</b> <tt>delete</tt> anything or cancel timers --
all cleanup must be done in the destructor.

<p><li> Destructor:

<p>Delete everything which was allocated by <tt>new</tt> and is still held
by the module class. With self-messages (timers), use the
<tt>cancelAndDelete(msg)</tt> function! It is almost always wrong
to just delete a self-message from the destructor, because it might be
in the scheduled events list. The <tt>cancelAndDelete(msg)</tt> function
checks for that first, and cancels the message before deletion if necessary.

<p></dl>

<p>
<H3><A NAME="sec169"/>4.3.4 "Garbage collection" and compatibility</H3>
<a name="sec:garbage-collection"></a>

<p>OMNeT++ versions before the 3.2 release had a feature which often was,
informally and also somewhat incorrectly, called <i>"garbage
collection"</i> (GC). The purpose of this feature was to mitigate the need for
writing destructors, and often constructors as well by providing automatic
cleanup at the end of the simulation. (It did not do anything during
simulation, as the name might suggest.)

<p>OMNeT++ (all versions) keep track of user-allocated simulation objects
(typically: messages) and their ownerships. What the <i>"garbage
collection"</i> feature did was that during the cleanup of the model, after
each module destructor finished, it checked whether there were simulations
objects left that were apparently owned by that module but not deallocated
by the destructor -- and if it found such objects, it invoked <tt>delete</tt>
on them.

<p>It worked out nicely in 90 percent of cases, but occasionally it resulted
in spurious crashes which were hard to debug for users not familiar
with OMNeT++ internals or lacking advanced C++ skills.
    <br><ul><font size=-1>[These crashes occurred due to lack of information available
              to the GC mechanism, e.g. C++ provides no way to detect
              from the pointer whether an object is part of an array, or is
              inside a struct or class. The solution was to use pointers:
              pointer array, pointer as class member, etc.]</font></ul>

<p>Starting from OMNeT++ 3.2, this cleanup-time GC mechanism has been disabled by default
(<tt>perform-gc=</tt> configuration option, see <a href="#"></a>),
and it generally not recommended to turn it back on. It does not do any harm
to run any simulation model without GC (apart from the memory leak).

<p>It is expected that existing modules will be updated sooner or later, by adding
proper constructors and destructors. To catalyse this process, OMNeT++ dumps the
list of unreleased objects at the end of the simulation. This dump can also be
turned off in the configuration (<tt>print-undisposed=</tt> configuration option,
see <a href="#"></a>).

<p>

<p><H3><A NAME="sec170"/>4.3.5 An example</H3>

<p>The following code is a bit longer but actually useful simple module
implementation. It demonstrates several of the above concepts, plus
some others which will be explained in later sections:
<ol>
  <li>constructor, initialize and destructor conventions
  <li>using messages for timers
  <li>accessing module parameters
  <li>recording statistics at the end of the simulation
  <li>documenting the programmer's assumptions using ASSERT()
</ol>

<pre>
// file: FFGenerator.h

#include &lt;omnetpp.h&gt;

/**
 * Generates messages or jobs; see NED file for more info.
 */
class FFGenerator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  private:
    <a href="../api/classcMessage.html">cMessage</a> *sendMessageEvent;
    long numSent;

  public:
    FFGenerator();
    virtual ~FFGenerator();

  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
    virtual void finish();
};
</pre>
<p>
<pre>
// file: FFGenerator.cc

#include "FFGenerator.cc"

// register module class with OMNeT++
Define_Module(FFGenerator);

FFGenerator::FFGenerator()
{
    sendMessageEvent = NULL;
}

void FFGenerator::initialize()
{
    numSent = 0;
    sendMessageEvent = new <a href="../api/classcMessage.html">cMessage</a>("sendMessageEvent");
    scheduleAt(0.0, sendMessageEvent);
}

void FFGenerator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    ASSERT(msg==sendMessageEvent);

    <a href="../api/classcMessage.html">cMessage</a> *m = new <a href="../api/classcMessage.html">cMessage</a>("packet");
    m-&gt;setLength(par("msgLength"));
    send(m, "out");
    numSent++;

    double deltaT = (double)par("sendIaTime");
    scheduleAt(simTime()+deltaT, sendMessageEvent);
}

void FFGenerator::finish()
{
    recordScalar("packets sent", numSent);
}

FFGenerator::~FFGenerator()
{
    cancelAndDelete(sendMessageEvent);
}
</pre>

<p>The corresponding NED declaration:

<p><pre>
// file: FFGenerator.ned
<b>simple</b> FFGenerator
{
    <b>parameters</b>:
        <b>volatile double</b> sendIaTime;
    <b>gates</b>:
        <b>output</b> out;
}
</pre>

<p>

<p>
<H3><A NAME="sec171"/>4.3.6 Using global variables</H3>
<!--global variables-->

<p>If possible, avoid using global variables, including
static class members. They are prone to cause several problems.
First, they are not reset to their initial values (to zero)
when you rebuild the simulation in Tkenv, or start another run
in Cmdenv. This may produce surprising results.
Second, they prevent you from running your simulation in parallel.
When using parallel simulation, each partition of your model
(may) run in a separate process, having its own copy of the
global variables. This is usually not what you want.

<p>The solution is to encapsulate the variables into simple modules
as private or protected data members, and expose them via public methods.
Other modules can then call these public methods to get or set the values.
Calling methods of other modules will be discussed in section
<a href="#sec196">[4.10]</a>.
Examples of such modules are the <tt>Blackboard</tt> in the <i>Mobility Framework</i>,
and <tt>InterfaceTable</tt> and <tt>RoutingTable</tt> in the <i>INET Framework</i>.

<p>

<p><H2><A NAME="sec172"/>4.4 Adding functionality to <a href="../api/classcSimpleModule.html">cSimpleModule</a></H2>

<p>This section discusses <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>'s four previously
mentioned member functions, intended to be redefined by the user:
<tt>initialize()</tt>, <tt>handleMessage()</tt>, <tt>activity()</tt>
and <tt>finish()</tt>, plus a fifth, less frequently used one,
<tt>handleParameterChange</tt>.

<p>

<p><H3><A NAME="sec173"/>4.4.1 handleMessage()</H3>

<p><p class="subheading">Function called for each event</p>

<p>
The idea is that at each event<!--event--> (message arrival) we
simply call a user-defined function. This function,
<tt>handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)</tt> is a
virtual member function of <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> which does
nothing by default -- the user has to redefine it in subclasses
and add the message processing code.

<p>The <tt>handleMessage()</tt> function will be called for every message
that arrives at the module. The function should process the message
and return immediately after that. The simulation time is potentially
different in each call. No simulation time elapses within a call
to <tt>handleMessage()</tt>.

<p>The event loop inside the simulator handles both <tt>activity()</tt>
and <tt>handleMessage()</tt> simple modules, and it corresponds
to the following pseudocode:

<p><pre>
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    m:= module containing this event
    if (m works with handleMessage())
        <b>m-&gt;handleMessage( event )</b>
    else // m works with activity()
        transferTo( m )
}
</pre>

<p>Modules with <tt>handleMessage()</tt> are NOT started automatically:
the simulation kernel creates starter messages<!--starter messages-->
only for modules with <tt>activity()</tt>. This means that you have to
schedule self-messages<!--self-message--> from the
<tt>initialize()</tt> function if you want a <tt>handleMessage()</tt>
simple module to start working ``by itself'', without first receiving
a message from other modules.

<p>
<p class="subheading">Programming with handleMessage()</p>

<p>
To use the <tt>handleMessage()</tt> mechanism in a
simple module, you must specify <i>zero
  stack size</i><!--zero stack size--> for the module. This is
important, because this tells OMNeT++ that you want to use
<tt>handleMessage()</tt> and not <tt>activity()</tt>.

<p>Message/event related functions you can use in <tt>handleMessage()</tt>:

<p><ul>
  <li><tt>send()</tt> family of functions -- to send messages to other modules
  <li><tt>scheduleAt()</tt> -- to schedule an event (the module ``sends a message to itself'')
  <li><tt>cancelEvent()</tt> -- to delete an event scheduled with <tt>scheduleAt()</tt>
</ul>

<p>You cannot use the <tt>receive()</tt> family and
<tt>wait()</tt> functions in <tt>handleMessage()</tt>, because they are
coroutine-based by nature, as explained in the section about
<tt>activity()</tt>.

<p>You have to add data members to the module class for every piece
of information you want to preserve. This information cannot
be stored in local variables of <tt>handleMessage()</tt> because they
are destroyed when the function returns. Also, they cannot be
stored in static variables in the function (or the class), because
they would be shared between all instances of the class.

<p>
Data members to be added to the module class will typically include
things like:

<p><ul>
  <li>state (e.g. IDLE/BUSY, CONN_DOWN/CONN_ALIVE/...)
  <li>other variables which belong to the state of the module: retry
    counts, packet queues, etc.
  <li>values retrieved/computed once and then stored: values of module
    parameters, gate indices, routing information, etc.
  <li>pointers of message objects created once and then reused for
    timers, timeouts, etc.
  <li>variables/objects for statistics collection
</ul>

<p>You can initialize these variables from the <tt>initialize()</tt>
function.  The constructor<!--module!constructor--> is not a very good place
for this purpose, because it is called in the network setup phase when
the model is still under construction, so a lot of information you may
want to use is not yet available.

<p>Another task you have to do in <tt>initialize()</tt> is to schedule
initial event(s)<!--events!initial--> which trigger the first call(s)
to <tt>handleMessage()</tt>.  After the first call,
<tt>handleMessage()</tt> must take care to schedule further events for
itself so that the ``chain'' is not broken. Scheduling events is not
necessary if your module only has to react to messages coming from
other modules.

<p><tt>finish()</tt> is normally used to record statistics information
accumulated in data members of the class at the end of the simulation.

<p>
<p class="subheading">Application area</p>

<p>
<tt>handleMessage()</tt> is in most cases a better choice than <tt>activity()</tt>:

<p><ol>
  <li>When you expect the module to be used in large simulations,
      involving several thousand modules. In such cases, the module stacks
      required by <tt>activity()</tt> would simply consume too much memory.
  <li>For modules which maintain little or no state information,
      such as packet sinks, <tt>handleMessage()</tt> is more convenient to program.
  <li>Other good candidates are modules with a large state space and
      many arbitrary state transition possibilities (i.e. where there
      are many possible subsequent states for any state). Such algorithms
      are difficult to program with <tt>activity()</tt>, or the result is code
      which is better suited for <tt>handleMessage()</tt> (see rule of thumb
      below). Most communication protocols are like this.
</ol>

<p>
<p class="subheading">Example 1: Protocol models</p>

<p>Models of protocol layers in a communication network tend to have
a common structure on a high level because fundamentally they all have to react
to three types of events: to messages arriving from higher layer protocols
(or apps), to messages arriving from lower layer protocols (from the network),
and to various timers and timeouts (that is, self-messages).

<p>This usually results in the following source code pattern:

<pre>
class FooProtocol : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    // state variables
    // ...

    virtual void processMsgFromHigherLayer(<a href="../api/classcMessage.html">cMessage</a> *packet);
    virtual void processMsgFromLowerLayer(FooPacket *packet);
    virtual void processTimer(<a href="../api/classcMessage.html">cMessage</a> *timer);

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

// ...

void FooProtocol::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    if (msg-&gt;isSelfMessage())
        processTimer(msg);
    else if (msg-&gt;arrivedOn("fromNetw"))
        processMsgFromLowerLayer(check_and_cast&lt;FooPacket *&gt;(msg));
    else
        processMsgFromHigherLayer(msg);
}
</pre>
<p>
The functions <tt>processMsgFromHigherLayer()</tt>, <tt>processMsgFromLowerLayer()</tt>
and <tt>processTimer()</tt> are then usually split further: there are separate
methods to process separate packet types and separate timers.

<p>
<p class="subheading">Example 2: Simple traffic generators and sinks</p>

<p>
The code for simple packet generators and sinks programmed with <tt>handleMessage()</tt> might
be as simple as the following pseoudocode:

<pre>
PacketGenerator::handleMessage(msg)
{
    create and send out a new packet;
    schedule msg again to trigger next call to handleMessage;
}

PacketSink::handleMessage(msg)
{
    delete msg;
}
</pre>
<p>
Note that <i>PacketGenerator</i> will need to redefine <tt>initialize()</tt>
to create <i>m</i> and schedule the first event.

<p>The following simple module generates packets with exponential
inter-arrival time. (Some details in the source haven't been
discussed yet, but the code is probably understandable nevertheless.)

<p>
<pre>
class Generator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  public:
    Generator() : <a href="../api/classcSimpleModule.html">cSimpleModule</a>()
  protected:
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(Generator);

void Generator::initialize()
{
    // schedule first sending
    scheduleAt(simTime(), new <a href="../api/classcMessage.html">cMessage</a>);
}

void Generator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    // generate & send packet
    <a href="../api/classcMessage.html">cMessage</a> *pkt = new <a href="../api/classcMessage.html">cMessage</a>;
    send(pkt, "out");
    // schedule next call
    scheduleAt(simTime()+exponential(1.0), msg);
}
</pre>

<p>

<p><p class="subheading">Example 3: Bursty traffic generator</p>

<p>
A bit more realistic example is to rewrite our Generator to create
packet bursts, each consisting of <tt>burstLength</tt> packets.

<p>We add some data members to the class:
<ul>
<li><tt>burstLength</tt> will store the parameter that specifies how many
    packets a burst must contain,
<li><tt>burstCounter</tt> will count in how many packets are left to be sent
    in the current burst.
</ul>

<p>The code:

<p><pre>
class BurstyGenerator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    int burstLength;
    int burstCounter;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    // init parameters and state variables
    burstLength = par("burstLength");
    burstCounter = burstLength;
    // schedule first packet of first burst
    scheduleAt(simTime(), new <a href="../api/classcMessage.html">cMessage</a>);
}

void BurstyGenerator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    // generate & send packet
    <a href="../api/classcMessage.html">cMessage</a> *pkt = new <a href="../api/classcMessage.html">cMessage</a>;
    send(pkt, "out");
    // if this was the last packet of the burst
    if (--burstCounter == 0)
    {
        // schedule next burst
        burstCounter = burstLength;
        scheduleAt(simTime()+exponential(5.0), msg);
    }
    else
    {
        // schedule next sending within burst
        scheduleAt(simTime()+exponential(1.0), msg);
    }
}
</pre>

<p>

<p><p class="subheading">Pros and Cons of using <tt>handleMessage()</tt></p>

<p>
Pros:
<ul>
  <li>consumes less memory: no separate stack needed for simple modules
  <li>fast: function call is faster than switching between coroutines<!--coroutine-->
</ul>

<p>Cons:
<ul>
  <li>local variables cannot be used to store state information
  <li>need to redefine <tt>initialize()</tt>
</ul>

<p>Usually, <tt>handleMessage()</tt> should be preferred to <tt>activity()</tt>.

<p>
<p class="subheading">Other simulators</p>

<p>
Many simulation packages use a similar approach, often topped with
something like a state machine<!--finite state machine-->
(FSM<!--FSM-->) which hides the underlying function calls. Such
systems are:
<ul>
  <li>OPNET<i><sup>TM</sup></i> which uses FSM's designed using a graphical editor;
  <li>NetSim++ clones OPNET's approach;
  <li>SMURPH (University of Alberta) defines a (somewhat eclectic)
      language to describe FSMs, and uses a precompiler to turn it
      into C++ code;
  <li>Ptolemy (UC Berkeley) uses a similar method.
</ul>

<p>OMNeT++'s FSM<!--FSM--> support is described in the next section.

<p>

<p><H3><A NAME="sec174"/>4.4.2 activity()</H3>

<p><p class="subheading">Process-style description</p>

<p>With <tt>activity()</tt>, you can code the simple
module much like you would code an operating system process or a
thread. You can wait for an incoming message (event) at any point of
the code, you can suspend the execution for some time (model time!),
etc. When the <tt>activity()</tt> function exits, the module is
terminated.  (The simulation can continue if there are other modules
which can run.)

<p>
The most important functions you can use in <tt>activity()</tt> are
(they will be discussed in detail later):
<ul>
<li><tt>receive()</tt> -- to receive messages (events)
<li><tt>wait()</tt> -- to suspend execution<!--suspend execution-->
    for some time (model time)
<li><tt>send()</tt> family of functions -- to send messages to other
    modules
<li><tt>scheduleAt()</tt> -- to schedule an event (the module ``sends
    a message to itself'')
<li><tt>cancelEvent()</tt> -- to delete an event scheduled with
    scheduleAt()
<li><tt>end()</tt> -- to finish execution of this module (same as
    exiting the <tt>activity()</tt> function)
</ul>

<p>The <tt>activity()</tt> function normally contains an infinite loop,
with at least a <tt>wait()</tt> or <tt>receive()</tt> call in its body.

<p>

<p><p class="subheading">Application area</p>

<p>Generally you should prefer <tt>handleMessage()</tt> to <tt>activity()</tt>.
The main problem with <tt>activity()</tt> is that it doesn't scale because
every module needs a separate coroutine stack. It has also been observed
that <tt>activity()</tt> does not encourage a good programming style.

<p>There is one scenario where <tt>activity()</tt>'s process-style
description is convenient: when the process has many
states but transitions are very limited, ie. from any state the
process can only go to one or two other states.  For example, this is
the case when programming a network application, which uses a single
network connection.  The pseudocode of the application which talks to
a transport layer protocol might look like this:

<p><pre>
<i>activity()</i>
{
    while(true)
    {
        open connection by sending OPEN command to transport layer
        receive reply from transport layer
        if (open not successful)
        {
            wait(some time)
            continue // loop back to while()
        }

        while(there's more to do)
        {
            send data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
            receive data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
        }
        close connection by sending CLOSE command to transport layer
        if (close not successful)
        {
            // handle error
        }
        wait(some time)
    }
}
</pre>

<p>If you have to handle several connections simultaneously, you may
dynamically create them as instances of the simple module above.
Dynamic module creation will be discussed later.

<p>There are situations when you certainly <i>do not want</i> to use <tt>activity()</tt>.
If your <tt>activity()</tt> function contains no <tt>wait()</tt> and it has
only one <tt>receive()</tt> call at the top of an infinite loop,
there's no point in using <tt>activity()</tt> and the code should be written
with <tt>handleMessage()</tt>.
The body of the infinite loop would then become the body to <tt>handleMessage()</tt>,
state variables inside <tt>activity()</tt> would become data members in
the module class, and you'd initialize them in <tt>initialize()</tt>.

<p>Example:

<pre>
void Sink::activity()
{
    while(true)
    {
        msg = receive();
        delete msg;
    }
}
</pre>
<p>
should rather be programmed as:

<pre>
void Sink::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    delete msg;
}
</pre>
<p>

<p>
<p class="subheading">Activity() is run as a coroutine</p>

<p>
<tt>activity()</tt> is run in a coroutine<!--coroutine-->.
Coroutines are a sort of threads which are scheduled
non-preemptively (this is also called cooperative
multitasking<!--multitasking!cooperative-->). From one coroutine you
can switch to another coroutine by a
<tt>transferTo(otherCoroutine)</tt> call. Then this
coroutine is suspended and <i>otherCoroutine</i> will run. Later,
when <i>otherCoroutine</i> does a
<tt>transferTo(firstCoroutine)</tt> call, execution of
the first coroutine will resume from the point of the
<tt>transferTo(otherCoroutine)</tt> call.  The full state
of the coroutine, including local variables are preserved while the
thread of execution is in other coroutines.  This implies that each
coroutine must have its own processor stack<!--stack-->, and
<tt>transferTo()</tt> involves a switch from one processor stack to
another.

<p>
Coroutines<!--coroutine--> are at the heart of OMNeT++, and the
simulation programmer doesn't ever need to call <tt>transferTo()</tt>
or other functions in the coroutine library, nor does he need to care
about the coroutine library implementation. It is important to
understand, however, how the event loop found in discrete event simulators
works with coroutines.

<p>
When using coroutines, the event loop<!--event loop--> looks like
this (simplified):

<p>
<pre>
<i>while (FES not empty and simulation not yet complete)</i>
{
    retrieve first event from FES
    t:= timestamp of this event
    <b>transferTo(module containing the event)</b>
}
</pre>

<p>

<p>That is, when the module has an event<!--event-->, the simulation
kernel transfers the control to the module's coroutine. It is expected
that when the module ``decides it has finished the processing of the
event'', it will transfer the control back to the simulation kernel by
a <tt>transferTo(main)</tt> call. Initially,
simple<!--module!simple--> modules using <tt>activity()</tt> are
``booted'' by events (<i>''starter messages''</i><!--starter messages-->)
inserted into the FES<!--FES--> by the simulation kernel before the
start of the simulation.

<p>
How does the coroutine know it has ``finished processing the event''?
The answer: <i>when it requests another event</i>.  The functions
which request events from the simulation kernel are the
<tt>receive()</tt> and <tt>wait()</tt>, so their
implementations contain a <tt>transferTo(main)</tt> call
somewhere.

<p>
Their pseudocode, as implemented in OMNeT++:

<p>
<pre>
receive()
{
    transferTo(main)
    retrieve current event
    return the event // remember: events = messages
}

wait()
{
    create event e
    schedule it at (current sim. time + wait interval)
    transferTo(main)
    retrieve current event
    if (current event is not e) {
        error
    }
    delete e  // note: actual impl. reuses events
    return
}
</pre>

<p>

<p>Thus, the <tt>receive()</tt> and <tt>wait()</tt> calls are
special points in the <tt>activity()</tt> function, because
they are where

<p><ul>
  <li>simulation time elapses in the module, and
  <li>other modules get a chance to execute.
</ul>

<p>
<p class="subheading">Starter messages</p>

<p>
Modules written with <tt>activity()</tt> need starter
messages<!--starter messages--> to ``boot''.  These starter messages
are inserted into the FES<!--FES--> automatically by OMNeT++ at the
beginning of the simulation, even before the <tt>initialize()</tt>
functions are called.

<p>
<p class="subheading">Coroutine stack size</p>

<p>
The simulation programmer needs to define the processor stack size<!--coroutine!stack size-->
for coroutines. This cannot be automated.

<p>16 or 32 kbytes is usually a good choice, but you may need more if the
module uses recursive functions or has local variables, which occupy a
lot of stack space. OMNeT++ has a built-in mechanism that will usually
detect if the module stack is too small and overflows<!--stack!overflow-->.
OMNeT++ can also tell you how much stack space a module actually uses<!--stack!usage-->,
so you can find out if you overestimated the stack needs.

<p>
<p class="subheading">initialize() and finish() with activity()</p>

<p>
Because local variables of <tt>activity()</tt> are preserved across
events, you can store everything (state information, packet buffers,
etc.) in them. Local variables can be initialized at the top of the
<tt>activity()</tt> function, so there isn't much need to use
<tt>initialize()</tt>.

<p>
You do need <tt>finish()</tt>, however, if you want to write statistics at
the end of the simulation. Because <tt>finish()</tt> cannot access
the local variables of <tt>activity()</tt>, you have to put the variables
and objects containing the statistics into the module class.
You still don't need <tt>initialize()</tt> because class members can also
be initialized at the top of <tt>activity()</tt>.

<p>
Thus, a typical setup looks like this in pseudocode:

<p>
<pre>
<i>class MySimpleModule...</i>
{
    ...
    variables for statistics collection
    activity();
    finish();
};

MySimpleModule::activity()
{
    declare local vars and initialize them
    initialize statistics collection variables

    while(true)
    {
        ...
    }
}

MySimpleModule::finish()
{
    record statistics into file
}
</pre>

<p>
<p class="subheading">Pros and Cons of using <tt>activity()</tt></p>

<p>
Pros:
<ul>
   <li><tt>initialize()</tt> not needed, state can be stored in local
       variables of <tt>activity()</tt>
   <li>process-style description is a natural programming model in some cases
</ul>

<p>Cons:
<ul>
   <li>limited scalability: coroutine stacks can unacceptably increase the
       memory requirements of the simulation program if you have several
       thousands or ten thousands of simple modules;
   <li>run-time overhead: switching between coroutines is somewhat slower
       than a simple function call
   <li>does not enforce a good programming style: using <tt>activity()</tt>
       tends to lead to unreliable, spaghetti code
</ul>

<p>In most cases, cons outweigh pros and it is a better idea to use
<tt>handleMessage()</tt> instead.

<p>
<p class="subheading">Other simulators</p>

<p>
Coroutines are used by a number of other simulation packages:
<ul>
<li>All simulation software which inherits from SIMULA (e.g. C++SIM)
    is based on coroutines, although all in all the programming
    model is quite different.
<li>The simulation/parallel programming language Maisie and its successor
    PARSEC (from UCLA) also use coroutines (although implemented
    with ``normal'' preemptive threads). The philosophy
    is quite similar to OMNeT++. PARSEC, being ``just''
    a programming language, it has a more elegant syntax but far fewer
    features than OMNeT++.
<li>Many Java-based simulation libraries are based on Java
    threads.
</ul>

<p>

<p>
<H3><A NAME="sec175"/>4.4.3 initialize() and finish()</H3>

<p><p class="subheading">Purpose</p>

<p>
<tt>initialize()</tt> -- to provide place for any user setup code

<p><tt>finish()</tt> -- to provide place where the user can record statistics
after the simulation has completed

<p>
<p class="subheading">When and how they are called</p>

<p>
The <tt>initialize()</tt> functions of the modules are invoked
<i>before</i> the first event is processed, but <i>after</i> the
initial events (starter messages<!--starter messages-->) have been
placed into the FES<!--FES--> by the simulation kernel.

<p>
Both simple and compound modules have <tt>initialize()</tt> functions.
A compound module's <tt>initialize()</tt> function runs
<i>before</i> that of its submodules.

<p>
The <tt>finish()</tt> functions are called when the event
loop<!--event loop--> has terminated, and only if it terminated
normally (i.e. not with a runtime error).  The calling order is the
reverse of the order of <tt>initialize()</tt>: first submodules, then the
encompassing compound module. (The bottom line is that at the moment
there is no ``official'' possibility to redefine <tt>initialize()</tt>
and <tt>finish()</tt> for compound modules; the unofficial way is to
write into the nedtool-generated C++ code. Future versions of OMNeT++ will
support adding these functions to compound modules.)

<p>This is summarized in the following pseudocode:

<p>
<pre>
<i>perform simulation run:</i>
    build network
      (i.e. the system module and its submodules recursively)
    insert starter messages for all submodules using activity()
    do callInitialize() on system module
        <i>enter event loop // (described earlier)</i>
    if (event loop terminated normally) // i.e. no errors
        do callFinish() on system module
    clean up

callInitialize()
{
    call to user-defined initialize() function
    if (module is compound)
        for (each submodule)
            do callInitialize() on submodule
}

callFinish()
{
    if (module is compound)
        for (each submodule)
            do callFinish() on submodule
    call to user-defined finish() function
}
</pre>

<p>

<p><p class="subheading">initialize() vs. constructor</p>

<p>
Usually you should not put simulation-related code into the
simple module constructor<!--module!constructor-->. This is because
modules often need to investigate their surroundings (maybe
the whole network) at the beginning of the simulation and save the
collected info into internal tables.  Code like that cannot be placed
into the constructor since the network is still being set up when the
constructor is called.

<p>
<p class="subheading">finish() vs. destructor</p>

<p>
Keep in mind that <tt>finish()</tt> is not always called, so it isn't a
good place for cleanup code which should run every time the module is
deleted. <tt>finish()</tt> is only a good place for writing statistics,
result post-processing and other operations  which are supposed to run only on
successful completion. Cleanup code should go into the
destructor<!--module!destructor-->.

<p>
<p class="subheading">Multi-stage initialization</p>

<p>
In simulation models, when one-stage
initialization<!--initialization--> provided by <tt>initialize()</tt>
is not sufficient, one can use multi-stage
initialization<!--initialization!multi-stage-->.  Modules have two
functions which can be redefined by the user:

<pre>
void initialize(int stage);
int numInitStages() const;
</pre>
<p>
At the beginning of the simulation, <tt>initialize(0)</tt>
is called for <i>all</i> modules, then <tt>initialize(1)</tt>,
<tt>initialize(2)</tt>, etc. You can think of it like
initialization takes place in several ``waves''. For each module,
<tt>numInitStages()</tt> must be redefined to return the number of init
stages required, e.g. for a two-stage init, <tt>numInitStages()</tt>
should return 2, and <tt>initialize(int stage)</tt> must be implemented to
handle the <i>stage=0</i> and <i>stage=1</i> cases.
  <br><ul><font size=-1>[Note <tt>const</tt> in the <tt>numInitStages()</tt> declaration.
  If you forget it, by C++ rules you create a <i>different</i> function
  instead of redefining the existing one in the base class, thus the
  existing one will remain in effect and return 1.]</font></ul>

<p>The <tt>callInitialize()</tt> function performs the full multi-stage initialization
for that module and all its submodules.

<p>If you do not redefine the multi-stage initialization functions, the
default behavior is single-stage initialization: the default
<tt>numInitStages()</tt> returns 1, and the default <tt>initialize(int stage)</tt>
simply calls <tt>initialize()</tt>.

<p>
<p class="subheading">``End-of-Simulation'' event</p>

<p>
The task of <tt>finish()</tt> is solved in several simulators
by introducing a special <i>end-of-simulation</i><!--end-of-simulation--> event.
This is not a very good practice because the simulation programmer has to
code the models (often represented as FSMs) so that they can <i>always</i>
properly respond to end-of-simulation events, in whichever state they are. This
often makes program code unnecessarily complicated.

<p>This can also be witnessed in the design of the PARSEC<!--PARSEC-->
simulation language (UCLA). Its predecessor Maisie used
end-of-simulation events, but -- as documented in the PARSEC manual --
this has led to awkward programming in many cases, so for PARSEC
end-of-simulation events were dropped in favour of <tt>finish()</tt>
(called <tt>finalize()</tt> in PARSEC).

<p>
<H3><A NAME="sec176"/>4.4.4 handleParameterChange()</H3>

<p>The <tt>handleParameterChange()</tt> method was added in OMNeT++ 3.2,
and it gets called by the simulation kernel when a module parameter changes.
The method signature is the following:

<pre>
void handleParameterChange(const char *parname);
</pre>
<p>
The user can redefine this method to let the module react to runtime parameter
changes. A typical use is to re-read the changed parameter, and update
the module state if needed. For example, if a timeout value changes,
one can restart or modify running timers.

<p>The primary motivation for this functionality was to facilitate
the implementation of <i>scenario manager</i> modules which
can be programmed to change parameters at certain simulation times.
Such modules can be very convenient in studies involving transient behaviour.

<p>The following example shows a queue module, which supports
runtime change of its <tt>serviceTime</tt> parameter:

<pre>
void Queue::handleParameterChange(const char *parname)
{
    if (strcmp(parname, "serviceTime")==0)
    {
        // queue service time parameter changed, re-read it
        serviceTime = par("serviceTime");

        // if there any job being serviced, modify its service time
        if (endServiceMsg-&gt;isScheduled())
        {
            cancelEvent(endServiceMsg);
            scheduleAt(simTime()+serviceTime, endServiceMsg);
        }
    }
}
</pre>
<p>

<p>

<p><H3><A NAME="sec177"/>4.4.5 Reusing module code via subclassing</H3>

<p>It is often needed to have several variants of a simple module.
A good design strategy is to create a simple module class with
the common functionality, then subclass from it to create the
specific simple module types.

<p>
An example:

<pre>
class ModifiedTransportProtocol : public TransportProtocol
{
  protected:
    virtual void recalculateTimeout();
};

Define_Module(ModifiedTransportProtocol);

void ModifiedTransportProtocol::recalculateTimeout()
{
    //...
}
</pre>
<p>

<p><H2><A NAME="sec178"/>4.5 Finite State Machines in OMNeT++</H2>

<p><p class="subheading">Overview</p>

<p>
Finite State Machines<!--finite state machine--> (FSMs)<!--FSM-->
can make life with <tt>handleMessage()</tt> easier. OMNeT++ provides a
class and a set of macros to build FSMs. OMNeT++'s FSMs work very much
like OPNET's or SDL's.

<p>
The key points are:
<ul>
<li>There are two kinds of states:
    <i>transient</i><!--transient states--> and
    <i>steady</i><!--steady states-->. At each event (that is, at
    each call to <tt>handleMessage()</tt>), the FSM transitions out of
    the current (<i>steady</i>) state, undergoes a series of state
    changes (runs through a number of <i>transient</i> states), and
    finally arrives at another <i>steady</i> state. Thus between two
    events, the system is always in one of the steady states.
    Transient states are therefore not really a must -- they exist
    only to group actions to be taken during a transition in a
    convenient way.
<li>You can assign program code to handle entering and leaving a state
    (known as entry/exit code)<!--entry code--><!--exit code-->.
    Staying in the same state is handled as leaving and re-entering
    the state.
<li>Entry code should not modify the state (this is verified by
    OMNeT++).  State changes (transitions) must be put into the exit
    code.
</ul>

<p>OMNeT++'s FSMs <i>can</i> be nested<!--FSM!nested-->. This means
that any state (or rather, its entry or exit code) may contain a
further full-fledged <tt>FSM_Switch()</tt> (see below). This allows you
to introduce sub-states and thereby bring some structure into the
state space if it would become too large.

<p>
<p class="subheading">The FSM API</p>

<p>
FSM state is stored in an object of type <tt><a href="../api/classcFSM.html">cFSM</a></tt>. The possible states
are defined by an enum; the enum is also a place to define, which
state is transient and which is steady. In the following example, SLEEP
and ACTIVE are steady states and SEND is transient (the numbers
in parentheses must be unique within the state type and they are used
for constructing the numeric IDs for the states):

<pre>
enum {
  INIT = 0,
  SLEEP = FSM_Steady(1),
  ACTIVE = FSM_Steady(2),
  SEND = FSM_Transient(1),
};
</pre>
<p>

<p>
The actual FSM is embedded in a switch-like statement,
<tt>FSM_Switch()</tt>, where you have cases for entering and leaving
each state:

<p>
<pre>
FSM_Switch(fsm)
{
  case FSM_Exit(<i>state1</i>):
    //...
    break;
  case FSM_Enter(<i>state1</i>):
    //...
    break;
  case FSM_Exit(<i>state2</i>):
    //...
    break;
  case FSM_Enter(<i>state2</i>):
    //...
    break;
  //...
};
</pre>

<p>
State transitions<!--state transition--> are done via calls to
<tt>FSM_Goto()</tt>, which simply stores the new state in the
<tt><a href="../api/classcFSM.html">cFSM</a></tt> object:

<p><pre>
FSM_Goto(fsm,<i>newState</i>);
</pre>

<p>The FSM starts from the state with the numeric code 0; this state
is conventionally named INIT.

<p>
<p class="subheading">Debugging FSMs</p>

<p>FSMs can log their state transitions <tt>ev</tt><!--ev-->,
with the output looking like this:

<pre>
...
FSM GenState: leaving state SLEEP
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SEND
FSM GenState: leaving state SEND
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SLEEP
...
</pre>
<p>
To enable the above output, you have to <tt>#define FSM_DEBUG</tt><!--FSM_DEBUG-->
before including <tt>omnetpp.h</tt>.

<p><pre>
#define FSM_DEBUG    // enables debug output from FSMs
#include &lt;omnetpp.h&gt;
</pre>

<p>The actual logging is done via the <tt>FSM_Print()</tt> macro.
It is currently defined as follows, but you can change the
output format by undefining <tt>FSM_Print()</tt> after including
<tt>omnetpp.ini</tt> and providing a new definition instead.

<pre>
#define FSM_Print(fsm,exiting)
  (ev &lt;&lt; "FSM " &lt;&lt; (fsm).name()
      &lt;&lt; ((exiting) ? ": leaving state " : ": entering state ")
      &lt;&lt; (fsm).stateName() &lt;&lt; endl)
</pre>
<p>

<p><p class="subheading">Implementation</p>

<p>
The <tt>FSM_Switch()</tt> is a macro. It expands to a <tt>switch()</tt>
statement embedded in a <tt>for()</tt> loop which repeats until the
FSM<!--FSM--> reaches a steady state. (The actual code is rather
scary, but if you're dying to see it, it is in <tt>cfsm.h</tt>.)

<p>Infinite loops are avoided by counting state transitions: if
an FSM goes through 64 transitions without reaching a steady
state, the simulation will terminate with an error message.

<p>
<p class="subheading">An example</p>

<p>
Let us write another bursty generator. It will have two
states, SLEEP and ACTIVE. In the SLEEP state, the module does
nothing. In the ACTIVE state, it sends messages with a given
inter-arrival time. The code was taken from the Fifo2 sample
simulation.

<p>
<pre>
#define FSM_DEBUG
#include &lt;omnetpp.h&gt;

class BurstyGenerator : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    // parameters
    double sleepTimeMean;
    double burstTimeMean;
    double sendIATime;
    <a href="../api/classcPar.html">cPar</a> *msgLength;

    // FSM and its states
    <a href="../api/classcFSM.html">cFSM</a> fsm;
    enum {
      INIT = 0,
      SLEEP = FSM_Steady(1),
      ACTIVE = FSM_Steady(2),
      SEND = FSM_Transient(1),
    };

    // variables used
    int i;
    <a href="../api/classcMessage.html">cMessage</a> *startStopBurst;
    <a href="../api/classcMessage.html">cMessage</a> *sendMessage;

    // the virtual functions
    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(BurstyGenerator);

void BurstyGenerator::initialize()
{
    fsm.setName("fsm");
    sleepTimeMean = par("sleepTimeMean");
    burstTimeMean = par("burstTimeMean");
    sendIATime = par("sendIATime");
    msgLength = &par("msgLength");
    i = 0;
    WATCH(i); // always put watches in initialize()
    startStopBurst = new <a href="../api/classcMessage.html">cMessage</a>("startStopBurst");
    sendMessage = new <a href="../api/classcMessage.html">cMessage</a>("sendMessage");
    scheduleAt(0.0,startStopBurst);
}

void BurstyGenerator::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
  FSM_Switch(fsm)
 {
    case FSM_Exit(INIT):
      // transition to SLEEP state
      FSM_Goto(fsm,SLEEP);
      break;
    case FSM_Enter(SLEEP):
      // schedule end of sleep period (start of next burst)
      scheduleAt(simTime()+exponential(sleepTimeMean),
                 startStopBurst);
    break;
    case FSM_Exit(SLEEP):
      // schedule end of this burst
      scheduleAt(simTime()+exponential(burstTimeMean),
                 startStopBurst);
      // transition to ACTIVE state:
      if (msg!=startStopBurst) {
        error("invalid event in state ACTIVE");
      }
      FSM_Goto(fsm,ACTIVE);
      break;
    case FSM_Enter(ACTIVE):
      // schedule next sending
      scheduleAt(simTime()+exponential(sendIATime), sendMessage);
    break;
    case FSM_Exit(ACTIVE):
      // transition to either SEND or SLEEP
      if (msg==sendMessage) {
        FSM_Goto(fsm,SEND);
      } else if (msg==startStopBurst) {
        cancelEvent(sendMessage);
        FSM_Goto(fsm,SLEEP);
      } else {
        error("invalid event in state ACTIVE");
      }
      break;
    case FSM_Exit(SEND):
    {
      // generate and send out job
      char msgname[32];
      sprintf( msgname, "job-%d", ++i);
      ev &lt;&lt; "Generating " &lt;&lt; msgname &lt;&lt; endl;
      <a href="../api/classcMessage.html">cMessage</a> *job = new <a href="../api/classcMessage.html">cMessage</a>(msgname);
      job-&gt;setLength( (long) *msgLength );
      job-&gt;setTimestamp();
      send( job, "out" );
      // return to ACTIVE
      FSM_Goto(fsm,ACTIVE);
      break;
    }
  }
}
</pre>

<p>

<p>

<p><H2><A NAME="sec179"/>4.6 Sending and receiving messages</H2>
<a name="ch:simple-modules:sending-and-receiving"></a>

<p>On an abstract level, an OMNeT++ simulation model is a set of
simple modules that communicate with each other via message passing.
The essence of simple modules is that they create, send, receive,
store, modify, schedule and destroy messages -- everything else
is supposed to facilitate this task, and collect statistics
about what was going on.

<p>Messages in OMNeT++ are instances of the <tt><a href="../api/classcMessage.html">cMessage</a></tt> class or
one of its subclasses. Message objects are created using the C++
<tt>new</tt> operator and destroyed using the <tt>delete</tt> operator
when they are no longer needed. During their lifetimes,
messages travel between modules via gates and connections
(or are sent directly, bypassing the connections), or
they are scheduled by and delivered to modules,
representing internal events of that module.

<p>Messages are described in detail in chapter <a href="#sec205">[5]</a>.
At this point, all we need to know about them is that they are
referred to as <tt><a href="../api/classcMessage.html">cMessage</a> *</tt> pointers. Message objects
can be given descriptive names (a <tt>const char *</tt> string)
that often helps in debugging the simulation. The message
name string can be specified in the constructor, so it
should not surprise you if you see something like
<tt>new <a href="../api/classcMessage.html">cMessage</a>("token")</tt> in the examples below.

<p>

<p><H3><A NAME="sec180"/>4.6.1 Sending messages</H3>

<p>Once created, a message object can be sent through an
output gate<!--output!gate--> using one of the following functions:

<pre>
send(<a href="../api/classcMessage.html">cMessage</a> *msg, const char *gateName, int index=0);
send(<a href="../api/classcMessage.html">cMessage</a> *msg, int gateId);
send(<a href="../api/classcMessage.html">cMessage</a> *msg, <a href="../api/classcGate.html">cGate</a> *gate);
</pre>
<p>
In the first function, the argument <tt>gateName</tt> is the name of
the gate the message has to be sent through. If this gate is
a vector gate, <tt>index</tt> determines though which particular output
gate this has to be done; otherwise, the <tt>index</tt> argument is not
needed.

<p>The second and third functions use the gate Id and the pointer to the gate
object. They are faster than the first one because they don't have to
search through the gate array.

<p>Examples:

<pre>
send(msg, "outGate");
send(msg, "outGates", i); // send via outGates[i]
</pre>
<p>
The following code example creates and sends messages
every 5 simulated seconds:

<pre>
int outGateId = findGate("outGate");
while(true)
{
  send(new <a href="../api/classcMessage.html">cMessage</a>("packet"), outGateId);
  wait(5);
}
</pre>
<p>

<p><p class="subheading">Modeling packet transmissions</p>

<p>If you're sending messages over a link that has (nonzero) data rate,
it is modeled as described earlier in this manual, in
section <a href="#sec162">[4.2]</a>.

<p>If you want to have full control over the transmission process,
you'll probably need the <tt>isBusy()</tt> and <tt>transmissionFinishes()</tt>
member functions of <tt><a href="../api/classcGate.html">cGate</a></tt>. They are described in section
<a href="#sec193">[4.8.3]</a>.

<p>

<p><H3><A NAME="sec181"/>4.6.2 Broadcasts and retransmissions</H3>

<p>When you implement broadcasts or retransmissions, two frequently
occurring tasks in protocol simulation, you might feel tempted
to use the same message in multiple <tt>send()</tt> operations.
Do not do it -- you cannot send the same message object multiple times.
The solution in such cases is duplicating the message.

<p><p class="subheading">Broadcasting messages</p>

<p>In your model, you may need to broadcast a message to several destinations.
Broadcast can be implemented in a simple module by sending out copies
of the same message, for example on every gate of a gate vector.
As described above, you cannot use the same message pointer for
in all <tt>send()</tt> calls -- what you have to do instead is
create copies (duplicates) of the message object and send them.

<p>Example:

<pre>
for (int i=0; i&lt;n; i++)
{
    <a href="../api/classcMessage.html">cMessage</a> *copy = (<a href="../api/classcMessage.html">cMessage</a> *) msg-&gt;dup();
    send(copy, "out", i);
}
delete msg;
</pre>
<p>
You might have noticed that copying the message for the last gate is
redundant (we could send out the original message),
so it can be optimized out like this:

<pre>
for (int i=0; i&lt;n-1; i++)   // note n-1 instead of n
{
    <a href="../api/classcMessage.html">cMessage</a> *copy = (<a href="../api/classcMessage.html">cMessage</a> *) msg-&gt;dup();
    send(copy, "out", i);
}
send(msg, "out", n-1);  // send original on last gate
</pre>
<p>

<p><p class="subheading">Retransmissions</p>

<p>Many communication protocols involve retransmissions of packets (frames).
When implementing retransmissions, you cannot just hold a pointer
to the same message object and send it again and again -- you'd get
the <i>not owner of message</i> error on the first resend.

<p>Instead, whenever it comes to (re)transmission, you should create and
send copies of the message, and retain the original.
When you are sure there will not be any more retransmission,
you can delete the original message.

<p>Creating and sending a copy:

<pre>
// (re)transmit packet:
<a href="../api/classcMessage.html">cMessage</a> *copy = (<a href="../api/classcMessage.html">cMessage</a> *) packet-&gt;dup();
send(copy, "out");
</pre>
<p>
and finally (when no more retransmissions will occur):

<pre>
delete packet;
</pre>
<p>

<p><p class="subheading">Why?</p>

<p>A message is like any real world object -- it cannot be at two places
at the same time. Once you've sent it, the message object
no longer belongs to the module: it is taken over by the simulation kernel,
and will eventually be delivered to the destination module.
The sender module should not even refer to its pointer any more.
Once the message arrived in the destination module, that module
will have full authority over it -- it can send it on,
destroy it immediately, or store it for further handling.
The same applies to messages that have been scheduled -- they
belong to the simulation kernel until they are delivered back to
the module.

<p>To enforce the rules above, all message sending functions
check that you actually own the message you are about to send.
If the message is with another module, it is currently scheduled or
in a queue etc., you'll get a runtime error: <i>not owner of message</i>.
  <br><ul><font size=-1>[The feature does not increase runtime overhead significantly, because
  it uses the object ownership<!--ownership--> management (described in
  Section <a href="#sec273">[6.12]</a>);
  it merely checks that the owner of the message is the module that
  wants to send it.]</font></ul>

<p>

<p><H3><A NAME="sec182"/>4.6.3 Delayed sending</H3>

<p>It is often needed to model a delay (processing time, etc.) immediately
followed by message sending. In OMNeT++, it is possible to implement
it like this:

<pre>
wait( someDelay );
send( msg, "outgate" );
</pre>
<p>

<p>If the module needs to react to messages that arrive during the delay,
<tt>wait()</tt> cannot be used and the timer mechanism described in
Section <a href="#sec186">[4.6.7]</a>, ``Self-messages'', would
need to be employed.

<p>
There is also a more straightforward method than those mentioned above:
delayed sending<!--delayed sending-->. Delayed sending can be achieved
by using one of these functions:

<pre>
sendDelayed(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, const char *gateName, int index);
sendDelayed(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, int gateId);
sendDelayed(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, <a href="../api/classcGate.html">cGate</a> *gate);
</pre>
<p>
The arguments are the same as for <tt>send()</tt>, except for the extra <i>delay</i>
parameter. The effect of the function is the same as if the module
had kept the message for the delay interval and sent it afterwards.
That is, the sending time of the message will be the current
simulation time (time at the <tt>sendDelayed()</tt> call) plus the delay.
The delay value must be non-negative.

<p>Example:

<pre>
sendDelayed(msg, 0.005, "outGate");
</pre>
<p>

<p>
<H3><A NAME="sec183"/>4.6.4 Direct message sending</H3>

<p>Sometimes it is necessary or convenient to ignore gates/connections
and send a message directly to a remote destination module. The <tt>sendDirect()</tt>
function does that:

<pre>
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, <a href="../api/classcModule.html">cModule</a> *mod, int gateId)
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, <a href="../api/classcModule.html">cModule</a> *mod, const char *gateName, int index=-1)
sendDirect(<a href="../api/classcMessage.html">cMessage</a> *msg, double delay, <a href="../api/classcGate.html">cGate</a> *gate)
</pre>
<p>
In addition to the message and a delay, it also takes the destination module
and gate. The gate should be an <i>input</i> gate and should not be connected.
In other words, the module needs dedicated gates for receiving via <tt>sendDirect()</tt>.
(Note: For leaving a gate unconnected in a compound module, you'll need to specify
<tt>connections nocheck:</tt> instead of plain <tt>connections:</tt> in the NED file.)

<p>An example:

<pre>
<a href="../api/classcModule.html">cModule</a> *destinationModule = parentModule()-&gt;submodule("node2");
double delay = truncnormal(0.005, 0.0001);
sendDirect(new <a href="../api/classcMessage.html">cMessage</a>("packet"), delay, destinationModule, "inputGate");
</pre>
<p>
At the destination module, there is no difference between messages received
directly and those received over connections.

<p>

<p><H3><A NAME="sec184"/>4.6.5 Receiving messages</H3>

<p><b>With activity() only!</b> The message receiving functions can
only be used in the <tt>activity()</tt> function,
<tt>handleMessage()</tt> gets received messages in its argument list.

<p>Messages are received using the <tt>receive()</tt> function.
<tt>receive()</tt> is a member of <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>.

<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = receive();
</pre>
<p>
The <tt>receive()</tt> function accepts an optional <i>timeout</i>
parameter<!--receive!timeout-->. (This is a <i>delta</i>, not an
absolute simulation time.) If an appropriate message doesn't arrive
within the timeout period, the function returns a NULL pointer.
    <br><ul><font size=-1>[Putaside-queue and the functions <tt>receiveOn()</tt>,
    <tt>receiveNew()</tt>, and <tt>receiveNewOn()</tt> were deprecated
    in OMNeT++ 2.3 and removed in OMNeT++ 3.0.]</font></ul>

<pre>
simtime_t timeout = 3.0;
<a href="../api/classcMessage.html">cMessage</a> *msg = receive( timeout );

if (msg==NULL)
{
    ...   // handle timeout
}
else
{
    ...  // process message
}
</pre>
<p>

<p>
<H3><A NAME="sec185"/>4.6.6 The wait() function</H3>

<p><b>With activity() only!</b> The <tt>wait()</tt> function's implementation
contains a <tt>receive()</tt> call which cannot be used in <tt>handleMessage()</tt>.

<p>The <tt>wait()</tt> function suspends the execution of the module for
a given amount of simulation time (a <i>delta</i>).

<pre>
wait( delay );
</pre>
<p>
In other simulation software, <tt>wait()</tt> is often called <i>hold</i>.
Internally, the <tt>wait()</tt> function is implemented by a
<tt>scheduleAt()</tt> followed by a <tt>receive()</tt>.
The <tt>wait()</tt> function is very convenient in modules that do not need
to be prepared for arriving messages, for example message generators.
An example:

<pre>
for(;;)
{
  // wait for a (potentially random amount of) time, specified
  // in the interArrivalTime module parameter
  wait( par("interArrivalTime") );

  // generate and send message
  ...
}
</pre>
<p>
It is a runtime error if a message arrives during the wait interval.
If you expect messages to arrive during the wait period, you can
use the <tt>waitAndEnqueue()</tt> function. It takes a pointer to a queue object
(of class <tt><a href="../api/classcQueue.html">cQueue</a></tt>, described in chapter <a href="#sec222">[6]</a>)
in addition to the wait interval. Messages that arrive during the
wait interval will be accumulated in the queue, so you can
process them after the <tt>waitAndEnqueue()</tt> call returned.

<pre>
<a href="../api/classcQueue.html">cQueue</a> queue("queue");
...
waitAndEnqueue(waitTime, &queue);
if (!queue.empty())
{
  // process messages arrived during wait interval
  ...
}
</pre>
<p>

<p><H3><A NAME="sec186"/>4.6.7 Modeling events using self-messages</H3>
<a name="sec:ch-simple-modules:self-messages"></a>

<p>In most simulation models it is necessary to implement timers,
or schedule events that occur at some point in the future.
For example, when a packet is sent by a communications protocol model,
it has to schedule an event that would occur when a timeout expires,
because it will have to resent the packet then.
As another example, suppose you want to write a model of a server which
processes jobs from a queue. Whenever it begins processing
a job, the server model will want to schedule an event to occur
when the job finishes processing, so that it can begin processing
the next job.

<p>In OMNeT++ you solve such tasks by letting the simple module
send a message to itself; the message would be delivered
to the simple module at a later point of time. Messages used
this way are called self-messages<!--self-message-->.
Self-messages are used to model events which occur within the module.

<p><p class="subheading">Scheduling an event</p>

<p>The module can send a message to itself using the <tt>scheduleAt()</tt> function.
<tt>scheduleAt()</tt> accepts an <i>absolute</i> simulation time,
usually calculated as <tt>simTime()</tt>+<i>delta</i>:

<pre>
scheduleAt(absoluteTime, msg);
scheduleAt(simtime()+delta, msg);
</pre>
<p>
Self-messages are delivered to the module in the same way as other
messages (via the usual receive calls or <tt>handleMessage()</tt>);
the module may call the <tt>isSelfMessage()</tt> member of any received
message to determine if it is a self-message.

<p>As an example, here's how you could implement your own <tt>wait()</tt>
function in an <tt>activity()</tt> simple module, if the simulation kernel
didn't provide it already:


<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>();
scheduleAt(simtime()+waitTime, msg);
<a href="../api/classcMessage.html">cMessage</a> *recvd = receive();
if (recvd!=msg)
   // hmm, some other event occurred meanwhile: error!
...
</pre>
<p>
You can determine if a message is currently in the FES<!--FES-->
by calling its <tt>isScheduled()</tt> member:

<pre>
if (msg-&gt;isScheduled())
  // currently scheduled
else
  // not scheduled
</pre>
<p>

<p><p class="subheading">Re-scheduling an event</p>

<p>If you want to reschedule an event which is currently scheduled to a different
simulation time, first you have to cancel it using <tt>cancelEvent()</tt>.

<p>
<p class="subheading">Cancelling an event</p>

<p>Scheduled self-messages can be cancelled<!--self-message!cancelling-->
<!--message!cancelling--> (removed from the FES<!--FES-->).
This is particularly useful because self-messages are often used
to model timers.

<pre>
cancelEvent( msg );
</pre>
<p>
The <tt>cancelEvent()</tt> function takes a pointer to the message to
be cancelled, and also returns the same pointer. After having it
cancelled, you may delete the message or reuse it in the next
<tt>scheduleAt()</tt> calls. <tt>cancelEvent()</tt> gives an error if
the message is not in the FES<!--FES-->.

<p>
<p class="subheading">Implementing timers</p>

<p>The following example shows how to implement timers:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *timeoutEvent = new <a href="../api/classcMessage.html">cMessage</a>("timeout");

scheduleAt(simTime()+10.0, timeoutEvent);
//...

<a href="../api/classcMessage.html">cMessage</a> *msg = receive();
if (msg == timeoutEvent)
{
  // timeout expired
}
else
{
  // other message has arrived, timer can be cancelled now:
  delete cancelEvent(timeoutEvent);
}
</pre>
<p>

<p>

<p>
<H3><A NAME="sec187"/>4.6.8 Stopping the simulation</H3>

<p><p class="subheading">Normal termination</p>

<p>
You can finish the simulation with the <tt>endSimulation()</tt> function:

<p>
<tt>endSimulation()</tt>;

<p>
Typically you don't need <tt>endSimulation()</tt> because you
can specify simulation time and CPU time limits<!--simulation time
  limits--> in the ini file (see later).

<p>
<p class="subheading">Stopping on errors</p>

<p>
If you want your simulation to stop if it detects an error condition,
you can call the <tt>error()</tt> member function of <tt><a href="../api/classcModule.html">cModule</a></tt>.
It is used like <tt>printf()</tt>:

<pre>
if (windowSize&lt;1)
  error("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>

<p>Do not include a newline (``\n'') or punctuation (period
or exclamation mark) in the error text, as it will be added by OMNeT++.

<p>

<p>

<p><H2><A NAME="sec188"/>4.7 Accessing module parameters</H2>
<a name="ch:simple-modules:parameters"></a>

<p>Module parameters can be accessed<!--module!accessing parameters-->
by calling the <tt>par()</tt> member function of <tt><a href="../api/classcModule.html">cModule</a></tt>:

<pre>
<a href="../api/classcPar.html">cPar</a>& delayPar = par("delay");
</pre>
<p>
The <tt><a href="../api/classcPar.html">cPar</a></tt> class is a general value-storing object. It supports
type casts to numeric types, so parameter values can be read
like this:

<pre>
int numTasks = par("numTasks");
double processingDelay = par("processingDelay");
</pre>
<p>
If the parameter is a random variable or its value can change
during execution, it is best to store a reference to it and re-read
the value each time it is needed:

<pre>
<a href="../api/classcPar.html">cPar</a>& waitTime = par("waitTime");
for(;;)
{
  //...
  wait( (simtime_t)waitTime );
}
</pre>
<p>
If the <tt>wait_time</tt> parameter was given a random value (e.g. <tt>exponential(1.0)</tt>)
in the NED source or the ini file, the above code results in
a different delay each time.

<p>Parameter values can also be changed from the program, during
execution. If the parameter was taken by reference
<!--module!parameters!by reference--> (with a
<tt>ref</tt> modifier in the NED file), other modules
will also see the change.  Thus, parameters taken by reference can be
used as a means of module communication<!--module!communication-->.

<p>An example:

<pre>
par("waitTime") = 0.12;
</pre>
<p>
Or:

<pre>
<a href="../api/classcPar.html">cPar</a>& waitTime = par("waitTime");
waitTime = 0.12;
</pre>
<p>
The <tt><a href="../api/classcPar.html">cPar</a></tt> class is discussed in more detail in section
<a href="#sec243">[6.6]</a>.

<p>
<H3><A NAME="sec189"/>4.7.1 Emulating parameter arrays</H3>

<p>As of version 3.2, OMNeT++ does not support parameter arrays,
but in practice they can be emulated using string parameters.
One can assign the parameter a string which contains all values
in a textual form (for example, <tt>"0 1.234 3.95 5.467"</tt>), then
parse this string in the simple module.

<p>The <tt><a href="../api/classcStringTokenizer.html">cStringTokenizer</a></tt> class can be quite helpful for this
purpose. The constructor accepts a string, which it regards as
a sequence of tokens (words) separated by delimiter characters
(by default, spaces). Then, calling the <tt>nextToken()</tt> method
several times will return the tokens one by one. After the
last token, it returns <tt>NULL</tt>.

<p>For example, you can parse a string containing a sequence of integers
into a vector using the following code:

<pre>
const char *str = "34 42 13 46 72 41"; // input
std::vector&lt;int&gt; numbers;  // array to hold the result

<a href="../api/classcStringTokenizer.html">cStringTokenizer</a> tokenizer(str);
const char *token;
while ((token = tokenizer.nextToken())!=NULL)
    numbers.push_back(atoi(token));   // convert and store
</pre>
<p>
The class also has a <tt>hasMoreTokens()</tt> method, so the above
code can also be written as

<pre>
...
<a href="../api/classcStringTokenizer.html">cStringTokenizer</a> tokenizer(str);
while (tokenizer.hasMoreTokens())
    numbers.push_back(atoi(tokenizer.nextToken()));
</pre>
<p>
For converting <tt>long</tt>s and <tt>double</tt>s, replace <tt>atoi()</tt>
with <tt>atol()</tt> and <tt>atof()</tt>, respectively.

<p>For storing the tokens in a string vector, the <tt><a href="../api/classcStringTokenizer.html">cStringTokenizer</a></tt>
class has a convenience function named <tt>asVector()</tt>, so conversion
can be done in just one line of code:

<pre>
const char *str = "34 42 13 46 72 41";
std::vector&lt;std::string&gt; strVec = <a href="../api/classcStringTokenizer.html">cStringTokenizer</a>(str).asVector();
</pre>
<p>

<p>
<H2><A NAME="sec190"/>4.8 Accessing gates and connections</H2>
<a name="ch:simple-modules:gates"></a>

<p><H3><A NAME="sec191"/>4.8.1 Gate objects</H3>

<p>
Module gates<!--gate--> are <tt><a href="../api/classcGate.html">cGate</a></tt> objects. Gate objects
know whether, and to which gate they are connected. They can also be
queried on the parameters of the link (delay, data rate, etc.)

<p>The <tt>gate()</tt> member function of <tt><a href="../api/classcModule.html">cModule</a></tt> returns a
pointer to a <tt><a href="../api/classcGate.html">cGate</a></tt> object, and an overloaded form of the
function lets you access elements of a vector gate:

<pre>
<a href="../api/classcGate.html">cGate</a> *outgate = gate("out");
<a href="../api/classcGate.html">cGate</a> *outvec5gate = gate("outvec",5);
</pre>
<p>
For gate vectors<!--gate!vector-->, the first form returns the first gate in the
vector (at index 0).

<p>The <tt>isVector()</tt> member function can be used to determine if a
gate belongs to a gate vector or not.

<p>Given a gate pointer, you can use the <tt>size()</tt> and
<tt>index()</tt> member functions of <tt><a href="../api/classcGate.html">cGate</a></tt> to determine the
size of the gate vector<!--gate!vector size--> and the
index<!--gate!vector index--> of the gate within the vector:

<pre>
int size2 = outvec5gate-&gt;size(); // --&gt; size of outvec[]
int index = outvec5gate-&gt;index(); // --&gt; 5 (it is gate 5 in the vector)
</pre>
<p>
Instead of <tt>gate-&gt;size()</tt>, you can also call the <tt>gateSize()</tt>
method of <tt><a href="../api/classcModule.html">cModule</a></tt>, which does the same:

<pre>
int size2 = gateSize("out");
</pre>
<p>
For non-vector gates, <tt>size()</tt> returns 1 and <tt>index()</tt> returns 0.

<p>Zero-size gate vectors are represented with a placeholder gate whose
<tt>size()</tt> method returns zero and cannot be connected.

<p>The <tt>type()</tt> member function returns a character, 'I' for input
gates and 'O' for output gates:

<pre>
char type = outgate-&gt;type() // --&gt; 'O'
</pre>
<p>

<p><p class="subheading">Gate IDs</p>

<p>Module gates (input and output, single and vector) are stored in an
array within their modules. The gate's position in the array is called
the <i>gate ID</i>. The gate ID<!--gate!id--> is returned by the <tt>id()</tt>
member function:

<pre>
int id = outgate-&gt;id();
</pre>
<p>
For a module with input gates <tt>fromApp</tt> and <tt>in[3]</tt> and output gates
of <tt>toApp</tt> and <tt>status</tt>, the array may look like this:

<p><table border>
<TR> <TD align=center>

<b>ID</b> </TD> <TD align=center> <b>dir</b> </TD> <TD align=center> <b>name[index]</b></TD></TR>
<TR> <TD align=center> 0 </TD> <TD align=center> <i>input</i> </TD> <TD align=center> <tt>fromApp</tt> </TD></TR>
<TR> <TD align=center> 1 </TD> <TD align=center> <i>output</i> </TD> <TD align=center> <tt>toApp</tt> </TD></TR>
<TR> <TD align=center> 2 </TD> <TD align=center colspan=2><i>empty</i></TD></TR>
<TR> <TD align=center> 3 </TD> <TD align=center> <i>input</i> </TD> <TD align=center> <tt>in[0]</tt></TD></TR>
<TR> <TD align=center> 4 </TD> <TD align=center> <i>input</i> </TD> <TD align=center> <tt>in[1]</tt></TD></TR>
<TR> <TD align=center> 5 </TD> <TD align=center> <i>input</i> </TD> <TD align=center> <tt>in[2]</tt></TD></TR>
<TR> <TD align=center> 6 </TD> <TD align=center> <i>output</i> </TD> <TD align=center> <tt>status</tt></TD></TR>
</table>

<p>The array may have empty slots. Gate vectors are guaranteed to
occupy contiguous IDs, thus it is legal to calculate the
ID of <i>gate[k]</i> as <tt>gate("gate",0).id()+k</tt>.

<p>Message sending and receiving functions accept both gate names
and gate IDs; the functions using gate IDs are a bit faster.
Gate IDs do not change during execution, so it is often worth
retrieving them in advance and using them instead of gate names.

<p>You can also obtain gate IDs with the <tt>findGate()</tt>
member of <tt><a href="../api/classcModule.html">cModule</a></tt>:

<pre>
int id1 = findGate("out");
int id2 = findGate("outvect",5);
</pre>
<p>

<p>
<H3><A NAME="sec192"/>4.8.2 Connection parameters</H3>

<p>Connection attributes (propagation delay, transmission data rate,
bit error rate) are represented by the channel object, which
is available via the source gate of the connection.

<pre>
<a href="../api/classcChannel.html">cChannel</a> *chan = outgate-&gt;channel();
</pre>
<p>
<tt><a href="../api/classcChannel.html">cChannel</a></tt> is a small base class. All interesting attributes are
part of its subclass <tt><a href="../api/classcBasicChannel.html">cBasicChannel</a></tt>, so you have to cast the pointer
before getting to the delay, error and data rate values.

<pre>
<a href="../api/classcBasicChannel.html">cBasicChannel</a> *chan = check_and_cast&lt;<a href="../api/classcBasicChannel.html">cBasicChannel</a> *&gt;(outgate-&gt;channel());
double d = chan-&gt;delay();
double e = chan-&gt;error();
double r = chan-&gt;datarate();
</pre>
<p>
You can also change the channel attributes with the corresponding
<tt>setXXX()</tt> functions. Note, however, that (as it was explained in
section <a href="#sec162">[4.2]</a>)
changes will not affect messages already sent, even if they have not
begun transmission yet.

<p>

<p><H3><A NAME="sec193"/>4.8.3 Transmission state</H3>
<a name="ch:simple-modules:cgate-transmission-state"></a>

<p>The <tt>isBusy()</tt> member function returns whether the gate
is currently transmitting, and if so, the
<tt>transmissionFinishes()</tt> member function
returns the simulation time when the gate is going to finish
transmitting. (If the gate in not currently transmitting,
<tt>transmissionFinishes()</tt> returns the simulation time
when it finished its last transmission.)

<p>The semantics have been described in section
<a href="#sec162">[4.2]</a>.

<p>An example:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *packet = new <a href="../api/classcMessage.html">cMessage</a>("DATA");
packet-&gt;setByteLength(1024);  // 1K

if (gate("TxGate")-&gt;isBusy()) // if gate is busy, wait until it
{                             // becomes free
  wait( gate("TxGate")-&gt;transmissionFinishes() - simTime());
}
send( packet, "TxGate");
</pre>
<p>
If the connection with a data rate is not directly connected
to the simple module's output gate but is the second
one in the path, you have to check the second gate's busy
condition<!--gate!busy condition-->. You could use the following
code:

<pre>
if (gate("mygate")-&gt;toGate()-&gt;isBusy())
  //...
</pre>
<p>
Note that if data rates change<!--data rate change--> during the
simulation, the changes will affect only the messages that are
<i>sent</i> after the change.

<p>

<p><H3><A NAME="sec194"/>4.8.4 Connectivity</H3>

<p>The <tt>isConnected()</tt> member function returns whether
the gate is connected. If the gate is an output gate, the gate to
which it is connected is obtained by the <tt>toGate()</tt>
member function. For input gates, the function is
<tt>fromGate()</tt>.


<pre>
<a href="../api/classcGate.html">cGate</a> *gate = gate("somegate");
if (gate-&gt;isConnected())
{
  <a href="../api/classcGate.html">cGate</a> *othergate = (gate-&gt;type()=='O') ?
                     gate-&gt;toGate() : gate-&gt;fromGate();

  ev &lt;&lt; "gate is connected to: " &lt;&lt; othergate-&gt;fullPath() &lt;&lt; endl;
}
else
{
  ev &lt;&lt; "gate not connected" &lt;&lt; endl;
}
</pre>
<p>

<p>An alternative to <tt>isConnected()</tt> is to check the return value
of <tt>toGate()</tt> or <tt>fromGate()</tt>. The following code is fully equivalent
to the one above:

<pre>
<a href="../api/classcGate.html">cGate</a> *gate = gate("somegate");
<a href="../api/classcGate.html">cGate</a> *othergate = (gate-&gt;type()=='O') ?
                   gate-&gt;toGate() : gate-&gt;fromGate();
if (othergate)
  ev &lt;&lt; "gate is connected to: " &lt;&lt; othergate-&gt;fullPath() &lt;&lt; endl;
else
  ev &lt;&lt; "gate not connected" &lt;&lt; endl;
</pre>
<p>
To find out to which simple module a given output
gate leads finally<!--gate!destination-->, you would have to walk
along the path like this (the <tt>ownerModule()</tt> member function
returns the module to which the gate belongs):

<pre>
<a href="../api/classcGate.html">cGate</a> *gate = gate("out");
while (gate-&gt;toGate()!=NULL)
{
  gate = gate-&gt;toGate();
}

<a href="../api/classcModule.html">cModule</a> *destmod = gate-&gt;ownerModule();
</pre>
<p>

<p>but luckily, there are two convenience functions which do that:
<tt>sourceGate()</tt> and
<tt>destinationGate()</tt>.

<p>

<p>

<p><H2><A NAME="sec195"/>4.9 Walking the module hierarchy</H2>
<a name="ch:simple-modules:walking-module-hieararchy"></a>

<p><p class="subheading">Module vectors</p>

<p>
If a module is part of a module vector<!--module!vector-->, the
<tt>index()</tt> and <tt>size()</tt> member functions can be used to
query its index and the vector size:

<pre>
ev &lt;&lt; "This is module [" &lt;&lt; module-&gt;index() &lt;&lt;
      "] in a vector of size [" &lt;&lt; module-&gt;size() &lt;&lt; "].\n";
</pre>
<p>

<p><p class="subheading">Module IDs</p>

<p>
Each module in the network has a unique ID that is returned by the
<tt>id()</tt> member function. The module ID<!--module!id--> is used
internally by the simulation kernel to identify modules.

<pre>
int myModuleId = id();
</pre>
<p>
If you know the module ID, you can ask the simulation object
(a global variable) to get back the module pointer:

<pre>
int id = 100;
<a href="../api/classcModule.html">cModule</a> *mod = simulation.module( id );
</pre>
<p>

<p>Module IDs are guaranteed to be unique, even when modules are
created and destroyed dynamically. That is, an ID which once
belonged to a module which was deleted is never issued to another
module later.

<p>
<p class="subheading">Walking up and down the module hierarchy</p>

<p>
The surrounding compound module can be accessed by the
<tt>parentModule()</tt> member function:

<pre>
<a href="../api/classcModule.html">cModule</a> *parent = parentModule();
</pre>
<p>
For example, the parameters of the parent module are accessed
like this:

<pre>
double timeout = parentModule()-&gt;par( "timeout" );
</pre>
<p>

<p><tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>findSubmodule()</tt> and <tt>submodule()</tt>
member functions make it possible to look up the module's submodules
by name<!--module!submodule!lookup--> (or name+index if the submodule
is in a module vector). The first one returns the numeric module ID of
the submodule, and the latter returns the module pointer.  If the
submodule is not found, they return -1 or NULL, respectively.

<pre>
int submodID = compoundmod-&gt;findSubmodule("child",5);
<a href="../api/classcModule.html">cModule</a> *submod = compoundmod-&gt;submodule("child",5);
</pre>
<p>

<p>The <tt>moduleByRelativePath()</tt> member function can be used to find
a submodule nested deeper than one level below. For example,

<pre>
compoundmod-&gt;moduleByRelativePath("child[5].grandchild");
</pre>
<p>
would give the same results as

<pre>
compoundmod-&gt;submodule("child",5)-&gt;submodule("grandchild");
</pre>
<p>
(Provided that <tt>child[5]</tt> does exist, because otherwise the second
version would crash with an access violation because of the NULL
pointer dereference.)

<p>
The <tt><a href="../api/classcSimulation.html">cSimulation</a></tt>::<tt>moduleByPath()</tt> function is similar
to <tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>moduleByRelativePath()</tt> function, and it
starts the search at the top-level module.

<p>
<p class="subheading">Iterating over submodules</p>

<p>
To access all modules within a compound module,
use <tt><a href="../api/classcSubModIterator.html">cSubModIterator</a></tt>.

<p>For example:

<pre>
for (<a href="../api/classcSubModIterator.html">cSubModIterator</a> iter(*parentModule()); !iter.end(); iter++)
{
  ev &lt;&lt; iter()-&gt;fullName();
}
</pre>
<p>
(<tt>iter()</tt> is pointer to the current module the iterator is at.)

<p>
The above method can also be used to iterate along a module
vector<!--module!vector!iteration-->, since the <tt>name()</tt>
function returns the same for all modules:

<pre>
for (<a href="../api/classcSubModIterator.html">cSubModIterator</a> iter(*parentModule()); !iter.end(); iter++)
{
  if (iter()-&gt;isName(name())) // if iter() is in the same
                              // vector as this module
  {
    int itsIndex = iter()-&gt;index();
    // do something to it
  }
}
</pre>
<p>

<p><p class="subheading">Walking along links</p>

<p>
To determine the module at the other end of a connection, use
<tt><a href="../api/classcGate.html">cGate</a></tt>'s <tt>fromGate()</tt>, <tt>toGate()</tt> and
<tt>ownerModule()</tt> functions. For example:

<pre>
<a href="../api/classcModule.html">cModule</a> *neighbour = gate( "outputgate" )-&gt;toGate()-&gt;ownerModule();
</pre>
<p>

<p>For input gates, you would use <tt>fromGate()</tt> instead of <tt>toGate()</tt>.

<p>
<H2><A NAME="sec196"/>4.10 Direct method calls between modules</H2>
<a name="ch:simple-modules:direct-method-calls"></a>
<!--method calls!between modules-->

<p>In some simulation models, there might be modules which are too
tightly coupled for message-based communication to be efficient.
In such cases, the solution might be calling one simple module's public
C++ methods from another module.

<p>Simple modules are C++ classes, so normal C++ method calls will
work. Two issues need to be mentioned, however:

<p><ul>
  <li> how to get a pointer to the object representing the module;
  <li> how to let the simulation kernel know that a method call across modules
     is taking place.
</ul>

<p>Typically, the called module is in the same compound module as the caller,
so the <tt>parentModule()</tt> and <tt>submodule()</tt> methods of
<tt><a href="../api/classcModule.html">cModule</a></tt> can be used to get a <tt><a href="../api/classcModule.html">cModule</a>*</tt> pointer to the
called module. (Further ways to obtain the pointer are described
in the section <a href="#sec195">[4.9]</a>.)
The <tt><a href="../api/classcModule.html">cModule</a>*</tt> pointer then has to be cast to the actual C++ class
of the module, so that its methods become visible.

<p>This makes the following code:

<pre>
<a href="../api/classcModule.html">cModule</a> *calleeModule = parentModule()-&gt;submodule("callee");
Callee *callee = check_and_cast&lt;Callee *&gt;(calleeModule);
callee-&gt;doSomething();
</pre>
<p>
The <tt>check_and_cast&lt;&gt;()</tt> template function on the second line
is part of OMNeT++. It does a standard C++ <tt>dynamic_cast</tt>,
and checks the result: if it is NULL, <tt>check_and_cast</tt> raises an OMNeT++ error.
Using <tt>check_and_cast</tt> saves you from writing error checking
code: if <tt>calleeModule</tt> from the first line is NULL because
the submodule named <tt>"callee"</tt> was not found, or if that
module is actually not of type <tt>Callee</tt>, an error gets thrown
from <tt>check_and_cast</tt>.

<p>The second issue is how to let the simulation kernel know that
a method call across modules is taking place. Why is this necessary
in the first place? First, the simulation kernel always has to know which
module's code is currently executing, in order to several internal
mechanisms to work correctly. (One such mechanism is ownership handling.)
Second, the Tkenv simulation GUI can animate method calls,
but to be able to do that, it has to know about them.

<p>The solution is to add the <tt>Enter_Method()</tt> or <tt>Enter_Method_Silent()</tt>
macro at the top of the methods that may be invoked from other
modules. These calls perform context switching, and, in case of
<tt>Enter_Method()</tt>, notify the simulation GUI so that animation
of the method call can take place. <tt>Enter_Method_Silent()</tt>
does not animate the call. <tt>Enter_Method()</tt> expects a
<tt>printf()</tt>-like argument list -- the resulting string will
be displayed during animation.

<pre>
void Callee::doSomething()
{
    Enter_Method("doSomething()");
    ...
}
</pre>
<p>

<p>
<H2><A NAME="sec197"/>4.11 Dynamic module creation</H2>
<a name="ch:simple-modules:dynamic-module-creation"></a>
<!--module!dynamic creation-->

<p><H3><A NAME="sec198"/>4.11.1 When do you need dynamic module creation</H3>

<p>In some situations you need to dynamically create and maybe destroy
modules. For example, when simulating a mobile network,
you may create a new module whenever a new user enters
the simulated area, and dispose of them when they leave the area.

<p>As another example, when implementing a server or a transport
protocol, it might be convenient to dymically create modules
to serve new connections, and dispose of them when the connection
is closed. (You would write a manager module that receives connection
requests and creates a module for each connection.
The Dyna example simulation does something like this.)

<p>Both simple and compound modules can be created dynamically.
If you create a compound module, all its submodules will be created
recursively.

<p>It is often convenient to use direct message sending with dynamically
created modules.

<p>Once created and started, dynamic modules aren't any different from
``static'' modules; for example, one could also delete static modules
during simulation (though it is rarely useful.)

<p>
<H3><A NAME="sec199"/>4.11.2 Overview</H3>

<p>
To understand how dynamic module creation works, you have to know a
bit about how normally OMNeT++ instantiates modules. Each module type
(class) has a corresponding factory object of the class
<tt><a href="../api/classcModuleType.html">cModuleType</a></tt>. This object is created under the hood by the
<tt>Define_Module()</tt> macro, and it has a factory
function<!--factory function--> which can instantiate the module
class (this function basically only consists of a <tt>return new
<i>module-class</i>(...)</tt> statement).

<p>The <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object can be looked up by its name
string (which is the same as the module class name). Once you have its
pointer, it is possible to call its factory method and create an
instance of the corresponding module class -- without having to
include the C++ header file containing module's class declaration
into your source file.

<p>The <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object also knows what gates and
parameters the given module type has to have. (This info comes from
compiled NED code.)

<p>Simple modules can be created in one step. For a compound module, the
situation is more complicated, because its internal structure
(submodules, connections) may depend on parameter values and gate
vector sizes. Thus, for compound modules it is generally required to
first create the module itself, second, set parameter values and gate
vector sizes, and then call the method that creates its submodules and
internal connections.

<p>As you know already, simple modules with <tt>activity()</tt> need a
starter message<!--starter messages-->. For statically created
modules, this message is created automatically by OMNeT++, but for
dynamically created modules, you have to do this explicitly by calling
the appropriate functions.

<p>Calling <tt>initialize()</tt> has to take place after insertion of the
starter messages, because the initializing code may insert new messages
into the FES<!--FES-->, and these messages should be processed
<i>after</i> the starter message.



<p><H3><A NAME="sec200"/>4.11.3 Creating modules</H3>

<p>The first step, finding the factory object:

<pre>
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = findModuleType("WirelessNode");
</pre>
<p>

<p><p class="subheading">Simplified form</p>

<p><tt><a href="../api/classcModuleType.html">cModuleType</a></tt> has a
<tt>createScheduleInit(const char *name, <a href="../api/classcModule.html">cModule</a> *parentmod)</tt>
convenience function to get a module up and running in one step.

<pre>
mod = modtype-&gt;createScheduleInit("node",this);
</pre>
<p>
It does <tt>create()</tt> + <tt>buildInside()</tt> +
<tt>scheduleStart(now)</tt> + <tt>callInitialize()</tt>.

<p>This method can be used for both simple and compound modules.
Its applicability is somewhat limited, however:
because it does everything in one step, you do not have the chance to
set parameters or gate sizes, and to connect gates before
<tt>initialize()</tt> is called.
(<tt>initialize()</tt> expects all parameters and gates to
be in place and the network fully built when it is called.)
Because of the above limitation, this function is mainly useful
for creating basic simple modules.


<p class="subheading">Expanded form</p>

<p>
If the previous simple form cannot be used. There are 5 steps:
<ol>
  <li>find factory object
  <li>create module
  <li>set up parameters and gate sizes (if needed)
  <li>call function that builds out submodules and finalizes the
    module
  <li>call function that creates activation message(s) for the new
    simple module(s)
</ol>
Each step (except for Step 3.) can be done with one line of code.

<p>

<p>See the following example, where Step 3 is omitted:

<pre>
// find factory object
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = findModuleType("WirelessNode");

// create (possibly compound) module and build its submodules (if any)
<a href="../api/classcModule.html">cModule</a> *module = moduleType-&gt;create("node", this);
module-&gt;buildInside();

// create activation message
module-&gt;scheduleStart( simTime() );
</pre>
<p>
If you want to set up parameter values or gate vector sizes (Step 3.),
the code goes between the <tt>create()</tt> and
<tt>buildInside()</tt> calls:

<pre>
// create
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = findModuleType("WirelessNode");
<a href="../api/classcModule.html">cModule</a> *module = moduleType-&gt;create("node", this);

// set up parameters and gate sizes before we set up its submodules
module-&gt;par("address") = ++lastAddress;
module-&gt;setGateSize("in", 3);
module-&gt;setGateSize("out", 3);

// create internals, and schedule it
module-&gt;buildInside();
module-&gt;scheduleStart(simTime());
</pre>
<p>

<p><H3><A NAME="sec201"/>4.11.4 Deleting modules</H3>

<p>
To delete a module dynamically<!--module!dynamic deletion-->:

<pre>
module-&gt;deleteModule();
</pre>
<p>
If the module was a compound module, this involves recursively
destroying all its submodules. A simple module can also delete itself;
in this case, the <tt>deleteModule()</tt> call does not return to the
caller.

<p>Currently, you cannot safely delete a
compound<!--module!compound!deletion--> module from a simple module
in it; you must delegate the job to a module outside the compound
module.

<p>
<H3><A NAME="sec202"/>4.11.5 Module deletion and finish()</H3>

<p>When you delete a module <i>during simulation</i>, its <tt>finish()</tt>
function is not called automatically (<tt>deleteModule()</tt> doesn't do it.)
How the module was created doesn't play any role here:
<tt>finish()</tt> gets called for <i>all</i> modules -- at the end of the
simulation. If a module doesn't live that long, <tt>finish()</tt> is not
invoked, but you can still manually invoke it.

<p>You can use the <tt>callFinish()</tt> function to arrange <tt>finish()</tt>
to be called. It is usually not a good idea to invoke <tt>finish()</tt>
directly. If you're deleting a compound module, <tt>callFinish()</tt> will
recursively invoke <tt>finish()</tt> for all submodules, and if you're deleting
a simple module from another module, <tt>callFinish()</tt> will do the context
switch for the duration of the call.
  <br><ul><font size=-1>[The <tt>finish()</tt> function is even made <tt>protected</tt>
  in <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, in order to discourage its invocation from
  other modules.]</font></ul>

<p>Example:

<pre>
mod-&gt;callFinish();
mod-&gt;deleteModule();
</pre>
<p>

<p><H3><A NAME="sec203"/>4.11.6 Creating connections</H3>
<!--connection!creating-->

<p>Connections can be created using <tt><a href="../api/classcGate.html">cGate</a></tt>'s <tt>connectTo()</tt>
method.
  <br><ul><font size=-1>[The earlier <tt>connect()</tt> global functions that
  accepted two gates have been deprecated, and may be removed
  from further OMNeT++ releases.]</font></ul>
<tt>connectTo()</tt> should be invoked on the source gate
of the connection, and expects the destination gate pointer as
an argument:

<pre>
srcGate-&gt;connectTo(destGate);
</pre>
<p>
The <i>source</i> and <i>destination</i> words correspond
to the direction of the arrow in NED files.

<p>As an example, we create two modules and connect them in both directions:

<pre>
<a href="../api/classcModuleType.html">cModuleType</a> *moduleType = findModuleType("TicToc");
<a href="../api/classcModule.html">cModule</a> *a = modtype-&gt;createScheduleInit("a",this);
<a href="../api/classcModule.html">cModule</a> *b = modtype-&gt;createScheduleInit("b",this);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"));
b-&gt;gate("out")-&gt;connectTo(a-&gt;gate("in"));
</pre>
<p>
<tt>connectTo()</tt> also accepts a channel object as an
additional, optional argument. Channels are subclassed from
<tt><a href="../api/classcChannel.html">cChannel</a></tt>. Almost always you'll want use an instance of
<tt><a href="../api/classcBasicChannel.html">cBasicChannel</a></tt> as channel -- this is the one that supports
delay<!--channel!delay-->, bit error rate <!--channel!error-->
and data rate<!--channel!datarate-->. The channel object will
be owned by the source gate of the connection, and you cannot
reuse the same channel object with several connections.

<p><tt><a href="../api/classcBasicChannel.html">cBasicChannel</a></tt> has <tt>setDelay()</tt>, <tt>setError()</tt>
and <tt>setDatarate()</tt> methods to set up the channel attributes.

<p>An example that sets up a channel with a delay:

<pre>
<a href="../api/classcBasicChannel.html">cBasicChannel</a> *channel = new <a href="../api/classcBasicChannel.html">cBasicChannel</a>("channel");
channel-&gt;setDelay(0.001);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"), channel); // a,b are modules
</pre>
<p>

<p><H3><A NAME="sec204"/>4.11.7 Removing connections</H3>
<!--connection!removing-->

<p>The <tt>disconnect()</tt> method of <tt><a href="../api/classcGate.html">cGate</a></tt> can be
used to remove connections. This method has to be invoked
on the <i>source</i> side of the connection. It also destroys
the channel object associated with the connection, if one has been set.

<pre>
srcGate-&gt;disconnect();
</pre>
<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec205"/>5 Messages</H1>
<a name="cha:messages"></a>

<p><H2><A NAME="sec206"/>5.1 Messages and packets</H2>

<p><H3><A NAME="sec207"/>5.1.1 The <a href="../api/classcMessage.html">cMessage</a> class</H3>

<p><tt><a href="../api/classcMessage.html">cMessage</a></tt> is a central class in OMNeT++. Objects of <tt><a href="../api/classcMessage.html">cMessage</a></tt> and
subclasses may model a number of things: events<!--events-->;
messages; packets, frames, cells, bits or signals travelling
in a network; entities travelling in a system and so on.


<p class="subheading">Attributes</p>

<p>
A <tt><a href="../api/classcMessage.html">cMessage</a></tt> object has number of attributes. Some are used by
the simulation kernel, others are provided just for the convenience
of the simulation programmer. A more-or-less complete list:

<p><ul>
  <li>The <i>name</i> attribute is a string (<tt>const char *</tt>),
    which can be freely used by the simulation programmer. The message
    name appears in many places in Tkenv (for example, in animations),
    and it is generally very useful to choose a descriptive name.
    This attribute is inherited from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> (see section
    <a href="#sec224">[6.1.1]</a>).
  <li>The <i>message kind</i> attribute is supposed to carry some message
    type information. Zero and positive values can be freely used
    for any purpose. Negative values are reserved for use by the
    OMNeT++ simulation library.
  <li>The <i>length</i> attribute (understood in bits) is used to compute
    transmission delay when the message travels through a connection
    that has an assigned data rate.
  <li>The <i>bit error flag</i> attribute is set to true by the simulation
    kernel with a probability of <i>1-(1-<i>ber</i>)<sup><i>length</sup></i></i> when the
    message is sent through a connection that has an assigned bit
    error rate (<i>ber</i>).
  <li>The <i>priority</i> attribute is used by the simulation kernel to
    order messages in the message queue (FES<!--FES-->) that have the same
    arrival time values.
  <li>The <i>time stamp</i> attribute is not used by the simulation kernel;
    you can use it for purposes such as noting the time when the
    message was enqueued or re-sent.
  <li>Other attributes and data members make simulation programming
    easier, they will be discussed later: <i>parameter list</i>, <i>encapsulated
      message</i>, <i>control info</i> and <i>context pointer</i>.
  <li>A number of read-only attributes store information about the
    message's (last) sending/scheduling: <i>source/destination module
      and gate</i>, <i>sending (scheduling) and arrival time</i>. They are
    mostly used by the simulation kernel while the message is in
    the FES<!--FES-->, but the information is still in the message object when
    a module receives the message.
</ul>

<p>
<p class="subheading">Basic usage</p>

<p>
The <tt><a href="../api/classcMessage.html">cMessage</a></tt> constructor accepts several arguments.
Most commonly, you would create a message using an <i>object name</i>
(a <tt>const char *</tt> string) and a <i>message kind</i> (<tt>int</tt>):

<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>("MessageName", msgKind);
</pre>
<p>
Both arguments are optional and initialize to the null string (<tt>""</tt>)
and 0, so the following statements are also valid:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>();
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>("MessageName");
</pre>
<p>
It is a good idea to <i>always</i> use message names -- they can be
extremely useful when debugging or demonstrating your simulation.

<p>Message kind is usually initialized with a symbolic constant
(e.g. an <i>enum</i> value) which signals what the message object
represents in the simulation (i.e. a data packet, a jam signal, a job, etc.)
Please use <i>positive values or zero</i> only as message kind --
negative values are reserved for use by the simulation kernel.

<p>
The <tt><a href="../api/classcMessage.html">cMessage</a></tt> constructor accepts further arguments too
(<i>length</i>, <i>priority</i>, <i>bit error flag</i>),
but for readability of the code it is best to set them explicitly
via the <tt>set...()</tt> methods described below.
Length and priority are integers, and the bit error flag is boolean.

<p><!--message!data members-->

<p>Once a message has been created, its data members can be changed by the following functions:

<pre>
msg-&gt;setKind( kind );
msg-&gt;setLength( length );
msg-&gt;setByteLength( lengthInBytes );
msg-&gt;setPriority( priority );
msg-&gt;setBitError( err );
msg-&gt;setTimestamp();
msg-&gt;setTimestamp( simtime );
</pre>
<p>
With these functions the user can set the message
kind<!--message!kind-->, the message length<!--message@length-->,
the priority<!--message!priority-->, the error
flag<!--message!error flag--> and the time stamp<!--message!time
  stamp-->. The <tt>setTimeStamp()</tt> function without any argument
sets the time stamp to the current simulation time.
<tt>setByteLength()</tt> sets the same length field as <tt>setLength()</tt>,
only the parameters gets internally multiplied by 8.

<p>The values can be obtained by the following functions:

<pre>
int k       = msg-&gt;kind();
int p       = msg-&gt;priority();
int l       = msg-&gt;length();
int lb      = msg-&gt;byteLength();
bool b      = msg-&gt;hasBitError();
simtime_t t = msg-&gt;timestamp();
</pre>
<p>
<tt>byteLength()</tt> also reads the length field as <tt>length()</tt>,
but the result gets divided by 8 and rounded up.

<p>
<p class="subheading">Duplicating messages</p>
<!--message!duplication-->

<p>It is often necessary to duplicate a message (for example, sending
one and keeping a copy). This can be done in the same way as
for any other OMNeT++ object:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *copy = (<a href="../api/classcMessage.html">cMessage</a> *) msg-&gt;dup();
</pre>
<p>
or

<pre>
<a href="../api/classcMessage.html">cMessage</a> *copy = new <a href="../api/classcMessage.html">cMessage</a>( *msg );
</pre>
<p>

<p>The two are equivalent. The resulting message is an exact copy
of the original, including message parameters (<tt><a href="../api/classcPar.html">cPar</a></tt> or other
object types) and encapsulated messages.

<p>
<H3><A NAME="sec208"/>5.1.2 Self-messages</H3>

<p><p class="subheading">Using a message as self-message</p>

<p>Messages are often used to represent events internal to a module,
such as a periodically firing timer on expiry of a timeout.
A message is termed <i>self-message</i> when it is used
in such a scenario -- otherwise self-messages are normal messages,
of class <tt><a href="../api/classcMessage.html">cMessage</a></tt> or a class derived from it.

<p>When a message is delivered to a module by the simulation kernel,
you can call the <tt>isSelfMessage()</tt> method to determine if it is
a self-message; it other words, if it was scheduled with
<tt>scheduleAt()</tt> or was sent with one of the
<tt>send...()</tt> methods. The <tt>isScheduled()</tt> method
returns true if the message is currently scheduled. A scheduled
message can also be cancelled (<tt>cancelEvent()</tt>).

<p><pre>
bool <tt>isSelfMessage()</tt>;
bool <tt>isScheduled()</tt>;
</pre>

<p>The following methods return the time of creating and scheduling the message
as well as its arrival time. While the message is scheduled, arrival
time is the time it will be delivered to the module.

<p><pre>
simtime_t <tt>creationTime()</tt>
simtime_t <tt>sendingTime()</tt>;
simtime_t <tt>arrivalTime()</tt>;
</pre>

<p><p class="subheading">Context pointer</p>

<p><tt><a href="../api/classcMessage.html">cMessage</a></tt> contains a <tt>void*</tt> pointer which is
set/returned by the <tt>setContextPointer()</tt> and
<tt>contextPointer()</tt> functions:

<pre>
void *context =...;
msg-&gt;setContextPointer( context );
void *context2 = msg-&gt;contextPointer();
</pre>
<p>

<p>It can be used for any purpose by the simulation programmer.
It is not used by the simulation kernel, and it is treated as
a mere pointer (no memory management is done on it).

<p>Intended purpose: a module which schedules several self-messages
(timers) will need to identify a self-message when it arrives back to
the module, ie. the module will have to determine which timer went off
and what to do then. The context pointer<!--context pointer--> can be
made to point at a data structure kept by the module which can carry
enough ``context'' information about the event.

<p>

<p><H3><A NAME="sec209"/>5.1.3 Modelling packets</H3>

<p><p class="subheading">Arrival gate and time</p>

<p>The following methods can tell where the message came from and
where it arrived (or will arrive if it is currently scheduled or under way.)

<p><pre>
int <tt>senderModuleId()</tt>;
int <tt>senderGateId()</tt>;
int <tt>arrivalModuleId()</tt>;
int <tt>arrivalGateId()</tt>;
</pre>

<p>The following methods are just convenience functions which build
on the ones above.

<p><pre>
<a href="../api/classcModule.html">cModule</a> *<tt>senderModule()</tt>;
<a href="../api/classcGate.html">cGate</a> *<tt>senderGate()</tt>;
<a href="../api/classcGate.html">cGate</a> *<tt>arrivalGate()</tt>;
</pre>

<p>And there are further convenience functions to tell whether
the message arrived on a specific gate given with id or
name+index.

<p><pre>
bool <tt>arrivedOn</tt>(int id);
bool <tt>arrivedOn</tt>(const char *gname, int gindex=0);
</pre>

<p>The following methods return message creation time and the last sending
and arrival times.

<p><pre>
simtime_t <tt>creationTime()</tt>
simtime_t <tt>sendingTime()</tt>;
simtime_t <tt>arrivalTime()</tt>;
</pre>

<p><p class="subheading">Control info</p>

<p>One of the main application areas of OMNeT++ is the simulation of
telecommunication networks. Here, protocol layers are usually
implemented as modules which exchange packets. Packets themselves
are represented by messages subclassed from <tt><a href="../api/classcMessage.html">cMessage</a></tt>.

<p>However, communication between protocol layers requires sending
additional information to be attached to packets. For example,
a TCP implementation sending down a TCP packet to IP will want
to specify the destination IP address and possibly
other parameters. When IP passes up a packet to TCP after
decapsulation from the IP header, it'll want to let TCP know
at least the source IP address.

<p>This additional information is represented by <i>control info</i>
objects in OMNeT++. Control info objects have to be subclassed from
<tt><a href="../api/classcObject.html">cObject</a></tt> (a small footprint base class with
no data members), and attached to the messages representing
packets. <tt><a href="../api/classcMessage.html">cMessage</a></tt> has the following methods for this
purpose:

<p><pre>
void <tt>setControlInfo(<a href="../api/classcObject.html">cObject</a> *controlInfo)</tt>;
<a href="../api/classcObject.html">cObject</a> *<tt>controlInfo()</tt>;
<a href="../api/classcObject.html">cObject</a> *<tt>removeControlInfo()</tt>;
</pre>

<p>When a "command" is associated with the message sending (such as
TCP OPEN, SEND, CLOSE, etc), the message kind field (<tt>kind()</tt>,
<tt>setKind()</tt> methods of <tt><a href="../api/classcMessage.html">cMessage</a></tt>) should carry the command code.
When the command doesn't involve a data packet (e.g.
TCP CLOSE command), a dummy packet (empty <tt><a href="../api/classcMessage.html">cMessage</a></tt>) can be sent.

<p>

<p><p class="subheading">Identifying the protocol</p>

<p>In OMNeT++ protocol models, the protocol type is usually represented
in the message subclass. For example, instances of class
<tt>IPv6Datagram</tt> represent IPv6 datagrams and <tt>EthernetFrame</tt>
represents Ethernet frames) and/or in the message kind value.
The PDU type is usually represented as a field inside the message class.

<p>The C++ <tt>dynamic_cast</tt> operator can be used to determine
if a message object is of a specific protocol.

<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = receive();
if (dynamic_cast&lt;IPv6Datagram *&gt;(msg) != NULL)
{
    IPv6Datagram *datagram = (IPv6Datagram *)msg;
    ...
}
</pre>
<p>

<p><H3><A NAME="sec210"/>5.1.4 Encapsulation</H3>

<p><p class="subheading">Encapsulating packets</p>

<p>It is often necessary to encapsulate a
message<!--message!encapsulation--> into another when you're modeling
layered protocols of computer networks. Although you can encapsulate
messages by adding them to the parameter list, there's a better way.

<p>
The <tt>encapsulate()</tt> function encapsulates a message
into another one. The length of the message will grow by the length of
the encapsulated message. An exception: when the encapsulating (outer)
message has zero length, OMNeT++ assumes it is not a real packet but
some out-of-band signal, so its length is left at zero.

<pre>
<a href="../api/classcMessage.html">cMessage</a> *userdata = new <a href="../api/classcMessage.html">cMessage</a>("userdata");

userdata-&gt;setByteLength(2048);  // 2K
<a href="../api/classcMessage.html">cMessage</a> *tcpseg = new <a href="../api/classcMessage.html">cMessage</a>("tcp");
tcpseg-&gt;setByteLength(24);
tcpseg-&gt;encapsulate(userdata);
ev &lt;&lt; tcpseg-&gt;byteLength() &lt;&lt; endl; // --&gt; 2048+24 = 2072
</pre>
<p>
A message can only hold one encapsulated message at a time. The
second <tt>encapsulate()</tt> call will result in an error. It is also
an error if the message to be encapsulated isn't owned by the
module.

<p>You can get back the encapsulated message by <tt>decapsulate()</tt>:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *userdata = tcpseg-&gt;decapsulate();
</pre>
<p>
<tt>decapsulate()</tt> will decrease the length of the message accordingly,
except if it was zero. If the length would become negative, an
error occurs.

<p>The <tt>encapsulatedMsg()</tt> function returns a pointer to the encapsulated
message, or <tt>NULL</tt> if no message was encapsulated.

<p><p class="subheading">Reference counting</p>

<p>Since the 3.2 release, OMNeT++ implements reference counting of
encapsulated messages, meaning that if you <tt>dup()</tt> a message
that contains an encapsulated message, then the encapsulated message will
not be duplicated, only a reference count incremented. Duplication of
the encapsulated message is deferred until <tt>decapsulate()</tt>
actually gets called. If the outer message gets deleted without its
<tt>decapsulate()</tt> method ever being called, then the reference
count of the encapsulated message simply gets decremented. The
encapsulated message is deleted when its reference count reaches
zero.

<p>Reference counting can significantly improve performance, especially
in LAN and wireless scenarios. For example, in the simulation of a
broadcast LAN or WLAN, the IP, TCP and higher layer packets won't
get duplicated (and then discarded without being used) if the
MAC address doesn't match in the first place.

<p>The reference counting mechanism works transparently. However, there
is one implication: <b>one must not change anything in a message
that is encapsulated into another!</b> That is,
<tt>encapsulatedMsg()</tt> should be viewed as if it returned a
pointer to a read-only object (it returns a <tt>const</tt> pointer
indeed), for quite obvious reasons: the encapsulated message may be
shared between several messages, and any change would affect those
other messages as well.

<p>
<p class="subheading">Encapsulating several messages</p>

<p>The <tt><a href="../api/classcMessage.html">cMessage</a></tt> class doesn't directly support adding more than one
messages to a message object, but you can subclass <tt><a href="../api/classcMessage.html">cMessage</a></tt>
and add the necessary functionality. (It is recommended that you
use the message definition syntax <a href="#sec212">[5.2]</a>
and customized messages <a href="#sec218">[5.2.6]</a>
to be described later on in this chapter -- it can spare you some work.)

<p>You can store the messages in a fixed-size or a dynamically allocated
array, or you can use STL classes like <tt>std::vector</tt> or <tt>std::list</tt>.
There is one additional ``trick'' that you might not expect: your message
class has to <b>take ownership</b> of the inserted messages, and
<b>release</b> them when they are removed from the message. These are
done via the <tt>take()</tt> and <tt>drop()</tt> methods. Let us see
an example which assumes you have added to the class an <tt>std::list</tt> member
called <tt>messages</tt> that stores message pointers:

<pre>
void MessageBundleMessage::insertMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    take(msg);  // take ownership
    messages.push_back(msg);  // store pointer
}

void MessageBundleMessage::removeMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    messages.remove(msg);  // remove pointer
    drop(msg);  // release ownership
}
</pre>
<p>
You will also have to provide an <tt>operator=()</tt> method to
make sure your message objects can be copied and duplicated
properly -- this is something often needed in simulations
(think of broadcasts and retransmissions!). Section
<a href="#sec268">[6.11]</a> contains more info
about the things you need to take care of when deriving new classes.

<p>

<p><H3><A NAME="sec211"/>5.1.5 Attaching parameters and objects</H3>

<p>If you want to add parameters or objects to a message, the preferred
way to do that is via message definitions, described in chapter
<a href="#sec212">[5.2]</a>.

<p>
<p class="subheading">Attaching objects</p>

<p>The <tt><a href="../api/classcMessage.html">cMessage</a></tt> class has an internal <tt><a href="../api/classcArray.html">cArray</a></tt> object which can
carry objects<!--message!attaching objects-->. Only objects
that are derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> (most OMNeT++ classes are so) can be attached.
The <tt>addObject()</tt>, <tt>getObject()</tt>, <tt>hasObject()</tt>,
<tt>removeObject()</tt> methods use the object name
as the key to the array. An example:

<pre>
<a href="../api/classcLongHistogram.html">cLongHistogram</a> *pklenDistr = new <a href="../api/classcLongHistogram.html">cLongHistogram</a>("pklenDistr");
msg-&gt;addObject( pklenDistr );
...
if (msg-&gt;hasObject("pklenDistr"))
{
   <a href="../api/classcLongHistogram.html">cLongHistogram</a> *pklenDistr =
       (<a href="../api/classcLongHistogram.html">cLongHistogram</a> *) msg-&gt;getObject("pklenDistr");
   ...
}
</pre>
<p>
You should take care that names of the attached objects do not
clash with each other or with <tt><a href="../api/classcPar.html">cPar</a></tt> parameter names
(see next section).
If you do not attach anything to the message and do not call the
<tt>parList()</tt> function, the internal <tt><a href="../api/classcArray.html">cArray</a></tt> object
will not be created.
This saves both storage and execution time.

<p>You can attach non-object types (or non-<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> objects) to
the message<!--message!attaching non-object types--> by using
<tt><a href="../api/classcPar.html">cPar</a></tt>'s <tt>void*</tt> pointer 'P') type (see later in the description
of <tt><a href="../api/classcPar.html">cPar</a></tt>). An example:

<pre>
struct conn_t *conn = new conn_t; // conn_t is a C struct
msg-&gt;addPar("conn") = (void *) conn;
msg-&gt;par("conn").configPointer(NULL,NULL,sizeof(struct conn_t));
</pre>
<p>

<p>

<p><p class="subheading">Attaching parameters</p>

<p>The preferred way of extending messages with new data fields is to use
message definitions (see section <a href="#sec212">[5.2]</a>).

<p>The old, deprecated way of adding new fields to messages is via
attaching <tt><a href="../api/classcPar.html">cPar</a></tt> objects.
There are several downsides of this approach, the worst being
large memory and execution time overhead. <tt><a href="../api/classcPar.html">cPar</a></tt>'s are
heavy-weight and fairly complex objects themselves.
It has been reported that using <tt><a href="../api/classcPar.html">cPar</a></tt> message parameters
might account for a large part of execution time, sometimes as much as 80%.
Using <tt><a href="../api/classcPar.html">cPar</a></tt>s is also error-prone because <tt><a href="../api/classcPar.html">cPar</a></tt> objects
have to be added dynamically and individually to each message object.
In contrast, subclassing benefits from static type checking:
if you mistype the name of a field in the C++ code, already the compiler
can detect the mistake.

<p>
However, if you still need to use cPars, here's a short summary
how you can do it. You add a new parameter to the message with the
<tt>addPar()</tt> member function, and get back a reference
to the parameter object with the <tt>par()</tt> member function.
<tt>hasPar()</tt> tells you if the message has a
given parameter or not.
Message parameters can be accessed also by index in the parameter
array. The <tt>findPar()</tt> function returns the index of a parameter
or -1 if the parameter cannot be found. The parameter can then be
accessed using an overloaded <tt>par()</tt> function.

<p>Example:

<pre>
msg-&gt;addPar("destAddr");
msg-&gt;par("destAddr") = 168;
...
long destAddr = msg-&gt;par("destAddr");
</pre>
<p>


<p><H2><A NAME="sec212"/>5.2 Message definitions</H2>
<a name="ch:messages:message-definitions"></a>

<p><H3><A NAME="sec213"/>5.2.1 Introduction</H3>

<p>In practice, you'll need to add various fields to <tt><a href="../api/classcMessage.html">cMessage</a></tt> to
make it useful. For example, if you're modelling packets in communication
networks, you need to have a way to store protocol header fields in message
objects. Since the simulation library is written in C++, the natural way
of extending <tt><a href="../api/classcMessage.html">cMessage</a></tt> is via subclassing it.
However, because for each field you need to write at least
three things (a private data member, a getter and a setter method),
and the resulting class has to integrate with the simulation framework,
writing the necessary C++ code can be a tedious and time-consuming task.

<p>OMNeT++ offers a more convenient way called <i>message definitions</i>.
Message definitions provide a very compact syntax to describe
message contents. C++ code is automatically generated from message
definitions, saving you a lot of typing.

<p>A common source of complaint about code generators in general is
lost flexibility: if you have a different idea how the generated
code should look like, there's little you can do about it.
In OMNeT++, however, there's nothing to worry about: you can
customize the generated class to any extent you like.
Even if you decide to heavily customize the generated class,
message definitions still save you a great deal of manual work.

<p>The subclassing approach for adding message parameters was originally
suggested by Nimrod Mesika.

<p>
<p class="subheading">The first message class</p>

<p>Let us begin with a simple example. Suppose that you need message objects to
carry source and destination addresses as well as a hop count. You could write
a <tt>mypacket.msg</tt> file with the following contents:

<p><pre>
<b>message</b> MyPacket
{
    <b>fields</b>:
       <b>int</b> srcAddress;
       <b>int</b> destAddress;
       <b>int</b> hops = 32;
};
</pre>

<p>The task of the <i>message subclassing compiler</i> is to generate C++ classes
you can use from your models as well as ``reflection'' classes that allow
Tkenv to inspect these data stuctures.

<p>If you process <tt>mypacket.msg</tt> with the message subclassing compiler, it will
create the following files for you: <tt>mypacket_m.h</tt> and <tt>mypacket_m.cc</tt>.
<tt>mypacket_m.h</tt> contains the declaration of the <tt>MyPacket</tt> C++ class, and
it should be included into your C++ sources where you need to handle
<tt>MyPacket</tt> objects.

<p>The generated <tt>mypacket_m.h</tt> will contain the following class declaration:

<pre>
class MyPacket : public <a href="../api/classcMessage.html">cMessage</a> {
    ...
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    ...
};
</pre>
<p>
So in your C++ file, you could use the <tt>MyPacket</tt> class like this:

<pre>
#include "mypacket_m.h"

...
MyPacket *pkt = new MyPacket("pkt");
pkt-&gt;setSrcAddress( localAddr );
...
</pre>
<p>
The <tt>mypacket_m.cc</tt> file contains implementation of the generated <tt>MyPacket</tt>
class, as well as ``reflection'' code that allows you to inspect these data
stuctures in the Tkenv GUI. The <tt>mypacket_m.cc</tt> file should be compiled and
linked into your simulation. (If you use the <tt>opp_makemake</tt> tool
to generate your makefiles, the latter will be automatically taken care of.)

<p>
<p class="subheading">What is message subclassing <i>not?</i></p>

<p>There might be some confusion around the purpose and
concept of message definitions, so it seems to be a good idea
to deal with them right here.

<p>It is <i><b>not:</b></i>

<p><ul>
  <li><i>... an attempt to reproduce the functionality of C++ with another
     syntax.</i> Do not look for complex C++ types, templates, conditional compilation, etc.
     Also, it defines <i>data</i> only (or rather: an interface to access
     data) -- not any kind of active behaviour.
  <li><i>... a generic class generator.</i> This is meant for defining message
     contents, and data structure you put in messages.
     Defining methods is not supported on purpose.
     Also, while you can probably (ab)use the syntax to
     generate classes and structs used internally in simple modules,
     this is probably not a good idea.
</ul>

<p>The goal is to define the <i>interface</i> (getter/setter methods) of messages
rather than their implementations in C++. A simple and straightforward
implementation of fields is provided -- if you'd like a different internal
representation for some field, you can have it by customizing the class.

<p>There are questions you might ask:

<p><ul>
  <li><i>Why doesn't it support <tt>std::vector</tt> and other STL classes?</i>
     Well, it does. Message definitions focus on the interface
     (getter/setter methods) of the classes, optionally leaving the implementation
     to you -- so you can implement fields (dynamic array fields)
     using <tt>std::vector</tt>.
     (This aligns with the idea behind STL -- it was designed to be
     <i>nuts and bolts</i> for C++ programs).
  <li><i>Why does it support C++ data types and not octets,
     bytes, bits, etc..?</i>
     That would restrict the scope of message definitions to networking,
     and OMNeT++ wants to support other application areas as well.
     Furthermore, the set of necessary concepts to be supported is
     probably not bounded, there would always be new data types to
     be adopted.
  <li><i>Why no embedded classes?</i> Good question. As it does not
     conflict with the above principles, it might be added someday.
</ul>

<p>

<p>The following sections describe the message syntax and features in detail.

<p>
<H3><A NAME="sec214"/>5.2.2 Declaring enums</H3>

<p>An <tt>enum {..}</tt> generates a normal C++ enum, plus creates an object
which stores text representations of the constants. The latter makes it possible
to display symbolic names in Tkenv.
An example:

<p><pre>
<b>enum</b> ProtocolTypes
{
   IP = 1;
   TCP = 2;
};
</pre>

<p>Enum values need to be unique.

<p>

<H3><A NAME="sec215"/>5.2.3 Message declarations</H3>

<p><p class="subheading">Basic use</p>

<p>You can describe messages with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
    <b>fields</b>:
        <b>int</b> sourceAddress;
        <b>int</b> destAddress;
        <b>bool</b> hasPayload;
};
</pre>

<p>Processing this description with the message compiler will produce
a C++ header file with a generated class, <tt>FooPacket</tt>.
<tt>FooPacket</tt> will be a subclass of <tt><a href="../api/classcMessage.html">cMessage</a></tt>.

<p>For each field in the above description, the generated class will have
a protected data member, a getter and a setter method. The names of the
methods will begin with <tt>get</tt> and <tt>set</tt>,
followed by the field name with its first letter converted to uppercase.
Thus, <tt>FooPacket</tt> will contain the following methods:

<pre>
virtual int getSourceAddress() const;
virtual void setSourceAddress(int sourceAddress);

virtual int getDestAddress() const;
virtual void setDestAddress(int destAddress);

virtual bool getHasPayload() const;
virtual void setHasPayload(bool hasPayload);
</pre>
<p>
Note that the methods are all declared <tt>virtual</tt> to give you the possibility
of overriding them in subclasses.

<p>Two constructors will be generated: one that optionally accepts object name and
(for <tt><a href="../api/classcMessage.html">cMessage</a></tt> subclasses) message kind, and a copy constructor:

<pre>
FooPacket(const char *name=NULL, int kind=0);
FooPacket(const FooPacket& other);
</pre>
<p>
Appropriate assignment operator (<tt>operator=()</tt>) and <tt>dup()</tt> methods will
also be generated.

<p>Data types for fields are not limited to <tt>int</tt> and <tt>bool</tt>. You can use the
following primitive types (i.e. primitive types as defined in the C++ language):

<p><ul>
   <li> <tt>bool</tt>
   <li> <tt>char</tt>, <tt>unsigned char</tt>
   <li> <tt>short</tt>, <tt>unsigned short</tt>
   <li> <tt>int</tt>, <tt>unsigned int</tt>
   <li> <tt>long</tt>, <tt>unsigned long</tt>
   <li> <tt>double</tt>
</ul>

<p>Field values are initialized to zero.

<p>
<p class="subheading">Initial values</p>

<p>You can initialize field values with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
        <b>int</b> sourceAddress = 0;
        <b>int</b> destAddress = 0;
        <b>bool</b> hasPayload = false;
};
</pre>

<p>Initialization code will be placed in the constructor of the generated class.

<p>
<p class="subheading">Enum declarations</p>

<p>You can declare that an <tt>int</tt> (or other integral type) field
takes values from an enum. The message compiler can than generate code
that allows Tkenv display the symbolic value of the field.

<p>Example:

<p><pre>
<b>message</b> FooPacket
{
  <b>fields</b>:
      <b>int</b> payloadType <b>enum</b>(PayloadTypes);
};
</pre>

<p>The enum has to be declared separately in the message file.

<p>
<p class="subheading">Fixed-size arrays</p>

<p>You can specify fixed size arrays:

<p><pre>
<b>message</b> FooPacket
{
    <b>fields</b>:
        <b>long</b> route[4];
};
</pre>

<p>The generated getter and setter methods will have an extra <tt>k</tt> argument,
the array index:

<pre>
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
</pre>
<p>
If you call the methods with an index that is out of bounds, an exception
will be thrown.

<p>
<p class="subheading">Dynamic arrays</p>

<p>If the array size is not known in advance, you can declare the field
to be a dynamic array:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>long</b> route[];
};
</pre>

<p>In this case, the generated class will have two extra methods in addition
to the getter and setter methods: one for setting the array size, and another
one for returning the current array size.

<pre>
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
virtual unsigned getRouteArraySize() const;
virtual void setRouteArraySize(unsigned n);
</pre>
<p>
The <tt>set...ArraySize()</tt> method internally allocates a new array. Existing
values in the array will be preserved (copied over to the new array.)

<p>The default array size is zero. This means that you need to call the
<tt>set...ArraySize()</tt> before you can start filling array elements.

<p>
<p class="subheading">String members</p>

<p>You can declare string-valued fields with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>string</b> hostName;
};
</pre>

<p>The generated getter and setter methods will return and accept <tt>const char*</tt>
pointers:

<pre>
virtual const char *getHostName() const;
virtual void setHostName(const char *hostName);
</pre>
<p>
The generated object will have its own copy of the string.

<p>NOTE: a string member is different from a character array,
which is treated as an array of any other type. For example,

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>char</b> chars[10];
};
</pre>

<p>will generate the following methods:

<pre>
virtual char getChars(unsigned k);
virtual void setChars(unsigned k, char a);
</pre>
<p>

<p><H3><A NAME="sec216"/>5.2.4 Inheritance, composition</H3>

<p>So far we have discussed how to add fields of primitive types
(<tt>int</tt>, <tt>double</tt>, <tt>char</tt>, ...) to <tt><a href="../api/classcMessage.html">cMessage</a></tt>.
This might be sufficient for simple models, but if you have
more complex models, you'll probably need to:

<p><ul>
  <li> set up a hierarchy of message (packet) classes, that is,
    not only subclass from <tt><a href="../api/classcMessage.html">cMessage</a></tt> but also from your
    own message classes;
  <li> use not only primitive types as fields, but also structs,
    classes or typedefs. Sometimes you'll want to use a C++ type
    present in an already existing header file, another time you'll
    want a struct or class to be generated by the message
    compiler so that you can benefit from Tkenv inspectors.
</ul>

<p>The following section describes how to do this.

<p>
<p class="subheading">Inheritance among message classes</p>

<p>By default, messages are subclassed from <tt><a href="../api/classcMessage.html">cMessage</a></tt>. However, you can
explicitly specify the base class using the <tt>extends</tt> keyword:

<p><pre>
<b>message</b> FooPacket <b>extends</b> FooBase
{
    <b>fields</b>:
        ...
};
</pre>

<p>For the example above, the generated C++ code will look like:

<pre>
class FooPacket : public FooBase { ... };
</pre>
<p>
Inheritance also works for structs and classes (see next sections
for details).

<p>

<p><p class="subheading">Defining classes</p>

<p>Until now we have used the <tt>message</tt> keyword to define classes, which
implies that the base class is <tt><a href="../api/classcMessage.html">cMessage</a></tt>, either directly or indirectly.

<p>But as part of complex messages, you'll need structs and other classes
(rooted or not rooted in <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>) as building blocks.
Classes can be created with the <tt>class</tt> class keyword;
structs we'll cover in the next section.

<p>The syntax for defining classes is almost the same as defining messages,
only the <tt>class</tt> keyword is used instead of <tt>message</tt>.

<p>Slightly different code is generated for classes that are rooted in
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> than for those which are not.
If there is no <tt>extends</tt>, the generated class will not be
derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>, thus it will not have <tt>name()</tt>,
<tt>className()</tt>, etc. methods.
To create a class with those methods, you have to explicitly write
<tt>extends <a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>.

<p><pre>
<b>class</b> MyClass <b>extends</b> <a href="../api/classcOwnedObject.html">cOwnedObject</a>
{
    <b>fields</b>:
        ...
};
</pre>

<p>

<p><p class="subheading">Defining plain C structs</p>

<p>You can define C-style structs to be used as fields in message classes,
``C-style'' meaning ``containing only data and no methods''.
(Actually, in the C++ a struct can have methods,
and in general it can do anything a class can.)

<p>The syntax is similar to that of defining messages:

<p><pre>
<b>struct</b> MyStruct
{
    <b>fields</b>:
        <b>char</b> array[10];
        <b>short</b> version;
};
</pre>

<p>However, the generated code is different. The generated struct has
no getter or setter methods, instead the fields are represented
by public data members. For the definition above, the
following code is generated:

<pre>
// generated C++
struct MyStruct
{
    char array[10];
    short version;
};
</pre>
<p>
A struct can have primitive types or other structs as fields. It cannot
have string or class as field.

<p>Inheritance is supported for structs:

<p><pre>
<b>struct</b> Base
{
    ...
};

<b>struct</b> MyStruct extends Base
{
    ...
};
</pre>

<p>But because a struct has no member functions, there are limitations:

<p><ul>
   <li> dynamic arrays are not supported (no place for the array allocation code)
   <li> ``generation gap'' or abstract fields (see later) cannot be used,
      because they would build upon virtual functions.
</ul>

<p>
<p class="subheading">Using structs and classes as fields</p>

<p>In addition to primitive types, you can also use other structs or objects
as a field. For example, if you have a struct named <tt>IPAddress</tt>,
you can write the following:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       IPAddress src;
};
</pre>

<p>The <tt>IPAddress</tt> structure must be known in advance to the message compiler;
that is, it must either be a struct or class defined earlier in the message
description file, or it must be a C++ type with its header file
included via <tt>cplusplus {{...}}</tt> and its type announced
(see Announcing C++ types).

<p>The generated class will contain an <tt>IPAddress</tt> data member
(that is, <b>not</b> a pointer to an <tt>IPAddress</tt>).
The following getter and setter methods will be generated:

<pre>
virtual const IPAddress& getSrc() const;
virtual void setSrc(const IPAddress& src);
</pre>
<p>

<p><p class="subheading">Pointers</p>

<p>Not supported yet.

<p>

<p><H3><A NAME="sec217"/>5.2.5 Using existing C++ types</H3>

<p>
<p class="subheading">Announcing C++ types</p>

<p>If you want to use one of your own types (a class, struct or typedef,
declared in a C++ header) in a message definition, you have to
announce those types to the message compiler. You also have to make sure
that your header file gets included into the generated <tt>_m.h</tt> file
so that the C++ compiler can compile it.

<p>Suppose you have an <tt>IPAddress</tt> structure, defined in an <tt>ipaddress.h</tt>
file:

<pre>
// ipaddress.h
struct IPAddress {
    int byte0, byte1, byte2, byte3;
};
</pre>
<p>
To be able to use <tt>IPAddress</tt> in a message definition, the message
file (say <tt>foopacket.msg</tt>) should contain the following lines:

<p><pre>
<b>cplusplus</b> {{
#include "ipaddress.h"
}};

<b>struct</b> IPAddress;
</pre>

<p>The effect of the first three lines is simply that the <tt>#include</tt>
statement will be copied into the generated <tt>foopacket_m.h</tt>
file to let the C++ compiler know about the <tt>IPAddress</tt> class.
The message compiler itself will not try to make sense of the
text in the body of the <tt>cplusplus {{ ... }}</tt> directive.

<p>The next line, <tt>struct IPAddress</tt>, tells the message compiler that
<tt>IPAddress</tt> is a C++ struct. This information will (among others)
affect the generated code.

<p>Classes can be announced using the <tt>class</tt> keyword:

<p><pre>
<b>class</b> cSubQueue;
</pre>

<p>The above syntax assumes that the class is derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
either directly or indirectly. If it is not, the <tt>noncobject</tt>
keyword should be used:

<p><pre>
<b>class</b> <b>noncobject</b> IPAddress;
</pre>

<p>The distinction between classes derived and not derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
is important because the generated code differs at places.
The generated code is set up so that if you incidentally
forget the <tt>noncobject</tt> keyword (and thereby mislead the
message compiler into thinking that your class is rooted in
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> when in fact it is not), you'll get a C++ compiler
error in the generated header file.

<p>
<H3><A NAME="sec218"/>5.2.6 Customizing the generated class</H3>
<a name="sec:ch-messages:customizing-generated-class"></a>

<p>
<p class="subheading">The Generation Gap pattern</p>

<p>Sometimes you need the generated code to do something
more or do something differently than the version generated
by the message compiler.
For example, when setting a integer field named <tt>payloadLength</tt>,
you might also need to adjust the packet length. That is,
the following default (generated) version of the
<tt>setPayloadLength()</tt> method is not suitable:

<pre>
void FooPacket::setPayloadLength(int payloadLength)
{
    this-&gt;payloadLength = payloadLength;
}
</pre>
<p>
Instead, it should look something like this:

<pre>
void FooPacket::setPayloadLength(int payloadLength)
{
    int diff = payloadLength - this-&gt;payloadLength;
    this-&gt;payloadLength = payloadLength;
    setLength(length() + diff);
}
</pre>
<p>
According to common belief, the largest drawback of generated code
is that it is difficult or impossible to fulfill such wishes.
Hand-editing of the generated files is worthless, because
they will be overwritten and changes will be lost
in the code generation cycle.

<p>However, object oriented programming offers a solution.
A generated class can simply be customized by subclassing
from it and redefining whichever methods need to be
different from their generated versions. This practice
is known as the <i>Generation Gap</i> design pattern.
It is enabled with the <tt>@customize</tt> property set on the
message:

<p><pre>
<b>message</b> FooPacket
{
   @customize(true);
   <b>int</b> payloadLength;
};
</pre>

<p>If you process the above code with the message compiler,
the generated code will contain a <tt>FooPacket_Base</tt> class
instead of <tt>FooPacket</tt>. Then you would subclass
<tt>FooPacket_Base</tt> to produce <tt>FooPacket</tt>,
while doing your customizations by redefining the necessary methods.

<pre>
class FooPacket_Base : public <a href="../api/classcMessage.html">cMessage</a>
{
  protected:
    int src;
    // make constructors protected to avoid instantiation
    FooPacket_Base(const char *name=NULL);
    FooPacket_Base(const FooPacket_Base& other);
  public:
    ...
    virtual int getSrc() const;
    virtual void setSrc(int src);
};
</pre>
<p>
There is a minimum amount of code you have to write
for <tt>FooPacket</tt>, because not everything can be
pre-generated as part of <tt>FooPacket_Base</tt>, e.g.
constructors cannot be inherited. This minimum
code is the following (you'll find it the generated C++ header
too, as a comment):

<pre>
class FooPacket : public FooPacket_Base
{
  public:
    FooPacket(const char *name=NULL) : FooPacket_Base(name) {}
    FooPacket(const FooPacket& other) : FooPacket_Base(other) {}
    FooPacket& operator=(const FooPacket& other)
        {FooPacket_Base::operator=(other); return *this;}
    virtual <a href="../api/classcObject.html">cObject</a> *dup() {return new FooPacket(*this);}
};

Register_Class(FooPacket);
</pre>
<p>
Note that it is important that you redefine <tt>dup()</tt> and
provide an assignment operator (<tt>operator=()</tt>).

<p>So, returning to our original example about payload length
affecting packet length, the code you'd write is the following:

<pre>
class FooPacket : public FooPacket_Base
{
    // here come the mandatory methods: constructor,
    // copy contructor, operator=(), dup()
    // ...

    virtual void setPayloadLength(int newlength);
}

void FooPacket::setPayloadLength(int newlength)
{
    // adjust message length
    setLength(length()-getPayloadLength()+newlength);

    // set the new length
    FooPacket_Base::setPayloadLength(newlength);
}
</pre>
<p>

<p>
<p class="subheading">Abstract fields</p>

<p>The purpose of abstract fields is to let you to override
the way the value is stored inside the class,
and still benefit from inspectability in Tkenv.

<p>For example, this is the situation when you want to store a bitfield
in a single <tt>int</tt> or <tt>short</tt>, and still you want
to present bits as individual packet fields.
It is also useful for implementing computed fields.

<p>You can declare any field to be abstract with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   @customize(true);
   <b>abstract</b> <b>bool</b> urgentBit;
};
</pre>

<p>For an <tt>abstract</tt> field, the message compiler generates
no data member, and generated getter/setter methods will be pure
virtual:

<pre>
virtual bool getUrgentBit() const = 0;
virtual void setUrgentBit(bool urgentBit) = 0;
</pre>
<p>

<p>Usually you'll want to use abstract fields together with
the Generation Gap pattern, so that you can immediately
redefine the abstract (pure virtual) methods and
supply your implementation.

<p>

<p><H3><A NAME="sec219"/>5.2.7 Using STL in message classes</H3>

<p>


<p>

<p>
You may want to use STL <tt>vector</tt> or <tt>stack</tt> classes in your message classes.
This is possible using abstract fields. After all, <tt>vector</tt> and <tt>stack</tt>
are representations of a <i>sequence</i> -- same abstraction as dynamic-size vectors.
That is, you can declare the field as <tt>abstract T fld[]</tt>, and provide
an underlying implementation using <tt>vector&lt;T&gt;</tt>. You can also add methods
to the message class that invoke <tt>push_back()</tt>, <tt>push()</tt>, <tt>pop()</tt>, etc.
on the underlying STL object.

<p>See the following message declaration:

<p><pre>
<b>struct</b> Item
{
    <b>fields</b>:
        <b>int</b> a;
        <b>double</b> b;
}

<b>message</b> STLMessage
{
   @customize(true);
   <b>abstract</b> Item foo[]; // will use vector&lt;Item&gt;
   <b>abstract</b> Item bar[]; // will use stack&lt;Item&gt;
}
</pre>

<p>If you compile the above, in the generated code you'll only find a couple of
abstract methods for <tt>foo</tt> and <tt>bar</tt>, no data members or anything concrete.
You can implement everything as you like. You can write the following C++ file
then to implement <tt>foo</tt> and <tt>bar</tt> with <tt>std::vector</tt> and <tt>std::stack</tt>:

<pre>
#include &lt;vector&gt;
#include &lt;stack&gt;
#include "stlmessage_m.h"


class STLMessage : public STLMessage_Base
{
  protected:
    std::vector&lt;Item&gt; foo;
    std::stack&lt;Item&gt; bar;

  public:
    STLMessage(const char *name=NULL, int kind=0) : STLMessage_Base(name,kind) {}
    STLMessage(const STLMessage& other) : STLMessage_Base(other.name()) {operator=(other);}
    STLMessage& operator=(const STLMessage& other) {
        if (&other==this) return *this;
        STLMessage_Base::operator=(other);
        foo = other.foo;
        bar = other.bar;
        return *this;
    }
    virtual <a href="../api/classcObject.html">cObject</a> *dup() {return new STLMessage(*this);}

    // foo methods
    virtual void setFooArraySize(unsigned int size) {}
    virtual unsigned int getFooArraySize() const {return foo.size();}
    virtual Item& getFoo(unsigned int k) {return foo[k];}
    virtual void setFoo(unsigned int k, const Item& afoo) {foo[k]=afoo;}
    virtual void addToFoo(const Item& afoo) {foo.push_back(afoo);}

    // bar methods
    virtual void setBarArraySize(unsigned int size) {}
    virtual unsigned int getBarArraySize() const {return bar.size();}
    virtual Item& getBar(unsigned int k) {throw new cRuntimeException("sorry");}
    virtual void setBar(unsigned int k, const Item& bar) {throw new cRuntimeException("sorry");}
    virtual void barPush(const Item& abar) {bar.push(abar);}
    virtual void barPop() {bar.pop();}
    virtual Item& barTop() {return bar.top();}
};

Register_Class(STLMessage);
</pre>
<p>
Some additional notes:

<p><ol>
  <li><tt>setFooArraySize()</tt>, <tt>setBarArraySize()</tt> are redundant.
  <li><tt>getBar(int k)</tt> cannot be implemented in a straightforward way
     (<tt>std::stack</tt> does not support accessing elements by index).
     It could still be implemented in a less efficient way using STL iterators,
     and efficiency does not seem to be major problem because only Tkenv
     is going to invoke this function.
  <li><tt>setBar(int k, const Item&amp;)</tt> could not be implemented, but this
     is not particularly a problem. The exception will materialize in a
     Tkenv error dialog when you try to change the field value.
</ol>

<p>You may regret that the STL <tt>vector</tt>/<tt>stack</tt> are not directly exposed.
Well you could expose them (by adding a <tt>vector&lt;Item&gt;&amp; getFoo() {return foo;}</tt>
method to the class) but this is probably not a good idea.
STL itself was purposefully designed with a low-level approach, to provide
``nuts and bolts'' for C++ programming, and STL is better used in other classes
for internal representation of data.

<p>

<p><H3><A NAME="sec220"/>5.2.8 Summary</H3>

<p>This section attempts to summarize the possibilities.

<p>You can generate:

<p><ul>
  <li>  classes rooted in <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
  <li>  messages (default base class is <tt><a href="../api/classcMessage.html">cMessage</a></tt>)
  <li>  classes not rooted in <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
  <li>  plain C structs
</ul>

<p>The following data types are supported for fields:

<p><ul>
  <li>  primitive types: <tt>bool</tt>, <tt>char</tt>, <tt>short</tt>,
    <tt>int</tt>, <tt>long</tt>, <tt>unsigned short</tt>, <tt>unsigned int</tt>,
    <tt>unsigned long</tt>, <tt>double</tt>
  <li>  <tt>string</tt>, a dynamically allocated string, presented as <tt>const char *</tt>
  <li>  fixed-size arrays of the above types
  <li>  structs, classes (both rooted and not rooted in <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>),
    declared with the message syntax or externally in C++ code
  <li>  variable-sized arrays of the above types (stored as a dynamically
    allocated array plus an integer for the array size)
</ul>

<p>Further features:

<p><ul>
  <li>  fields initialize to zero (except struct members)
  <li>  fields initializers can be specified (except struct members)
  <li>  assigning <tt>enum</tt>s to variables of integral types.
  <li>  inheritance
  <li>  customizing the generated class via subclassing (<i>Generation Gap</i> pattern)
  <li>  abstract fields (for nonstandard storage and calculated fields)
</ul>

<p>Generated code (all generated methods are <tt>virtual</tt>, although
this is not written out in the following table):

<p><table border>
<TR> <TD align=left>

<p>
<b>Field declaration</b>
    </TD> <TD align=left>
<b>Generated code</b>
</TD></TR>
<TR> <TD align=left>
primitive types
<pre>
double field;
</pre>
     </TD> <TD align=left>
<pre>
double getField();
void setField(double d);
</pre>
</TD></TR>
<TR> <TD align=left>
string type
<pre>
string field;
</pre>
     </TD> <TD align=left>
<pre>
const char *getField();
void setField(const char *);
</pre>
</TD></TR>
<TR> <TD align=left>
fixed-size arrays
<pre>
double field[4];
</pre>
     </TD> <TD align=left>
<pre>
double getField(unsigned k);
void setField(unsigned k, double d);
unsigned getFieldArraySize();
</pre>

<p></TD></TR>
<TR> <TD align=left>
dynamic arrays
<pre>
double field[];
</pre>
     </TD> <TD align=left>
<pre>
void setFieldArraySize(unsigned n);
unsigned getFieldArraySize();
double getField(unsigned k);
void setField(unsigned k, double d);
</pre>
</TD></TR>
<TR> <TD align=left>
customized class
<pre>
class Foo {
  @customize(true);
</pre>
     </TD> <TD align=left>
<pre>
class Foo_Base { ... };
</pre>
and you have to write:
<pre>
class Foo : public Foo_Base {
   ...
};
</pre>
</TD></TR>
<TR> <TD align=left>
abstract fields
<pre>
abstract double field;
</pre>
     </TD> <TD align=left>
<pre>
double getField() = 0;
void setField(double d) = 0;
</pre>
</TD></TR>
<TR> <TD align=left>
</table>

<p>
<p class="subheading">Example simulations</p>

<p>Several of the example simulations (Token Ring, Dyna, Hypercube)
use message definitions. For example, in Dyna you'll find this:

<p><ul>
 <li> <tt>dynapacket.msg</tt> defines <tt>DynaPacket</tt> and <tt>DynaDataPacket</tt>;
 <li> <tt>dynapacket_m.h</tt> and <tt>dynapacket_m.cc</tt> are produced
   by the message subclassing compiler from it, and they contain
   the generated <tt>DynaPacket</tt> and <tt>DynaDataPacke</tt>t
   C++ classes (plus code for Tkenv inspectors);
 <li> other model files (<tt>client.cc</tt>, <tt>server.cc</tt>, ...)
   use the generated message classes
</ul>

<p>

<p><H3><A NAME="sec221"/>5.2.9 What else is there in the generated code?</H3>

<p>In addition to the message class and its implementation,
the message compiler also generates reflection code which makes it
possible to inspect message contents in Tkenv.
To illustrate why this is necessary, suppose you manually subclass
<tt><a href="../api/classcMessage.html">cMessage</a></tt> to get a new message class. You could write the following:
  <br><ul><font size=-1>[Note that the code is only for illustration.
  In real code, <tt>freq</tt> and <tt>power</tt> should be private members,
  and getter/setter methods should exist to access them.
  Also, the above class definition misses several member functions
  (constructor, assignment operator, etc.) that should be written.]</font></ul>

<pre>
class RadioMsg : public <a href="../api/classcMessage.html">cMessage</a>
{
  public:
    int freq;
    double power;
    ...
};
</pre>
<p>
Now it is possible to use <tt>RadioMsg</tt> in your simple modules:

<pre>
RadioMsg *msg = new RadioMsg();
msg-&gt;freq = 1;
msg-&gt;power = 10.0;
...
</pre>
<p>
You'd notice one drawback of this solution when you try to use
Tkenv for debugging. While <tt><a href="../api/classcPar.html">cPar</a></tt>-based message parameters can be viewed in
message inspector windows, fields added via subclassing do not appear
there. The reason is that Tkenv, being just another C++ library in your
simulation program, doesn't know about your C++ instance variables.
The problem cannot be solved entirely within Tkenv, because C++ does not
support ``reflection'' (extracting class information at runtime)
like for example Java does.

<p>There is a solution however: one can supply Tkenv with missing ``reflection''
information about the new class. Reflection info might take the form of
a separate C++ class whose methods return information about the
<tt>RadioMsg</tt> fields. This descriptor class might look like this:

<pre>
class RadioMsgDescriptor : public Descriptor
{
  public:
    virtual int getFieldCount() {return 2;}

    virtual const char *getFieldName(int k) {
        const char *fieldname[] = {"freq", "power";}
        if (k&lt;0 || k&gt;=2) return NULL;
        return fieldname[k];
    }

    virtual double getFieldAsDouble(RadioMsg *msg, int k) {
        if (k==0) return msg-&gt;freq;
        if (k==1) return msg-&gt;power;
        return 0.0; // not found
    }
    //...
};
</pre>
<p>
Then you have to inform Tkenv that a <tt>RadioMsgDescriptor</tt> exists and that it
should be used whenever Tkenv finds messages of type <tt>RadioMsg</tt> (as it is
currently implemented, whenever the object's <tt>className()</tt> method returns
<tt>"RadioMsg"</tt>). So when you inspect a <tt>RadioMsg</tt> in your simulation, Tkenv
can use <tt>RadioMsgDescriptor</tt> to extract and display the values of
the <tt>freq</tt> and <tt>power</tt> variables.

<p>The actual implementation is somewhat more complicated than this, but not
much.

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec222"/>6 The Simulation Library</H1>
<a name="cha:the-simulation-library"></a>

<p>OMNeT++ has an extensive C++ class library which you can use when implementing
simple modules. Parts of the class library have already been covered in the
previous chapters:

<p><ul>
  <li>the message class <tt><a href="../api/classcMessage.html">cMessage</a></tt> (chapter <a href="#sec205">[5]</a>)
  <li>sending and receiving messages, scheduling and canceling
    events, terminating the module or the simulation
    (section <a href="#sec179">[4.6]</a>)
  <li>access to module gates and parameters via <tt><a href="../api/classcModule.html">cModule</a></tt> member functions
    (sections <a href="#sec188">[4.7]</a> and <a href="#sec190">[4.8]</a>)
  <li>accessing other modules in the network (section <a href="#sec195">[4.9]</a>)
  <li>dynamic module creation (section <a href="#sec197">[4.11]</a>)
</ul>

<p>This chapter discusses the rest of the simulation library:

<p><ul>
  <li>random number generation: <tt>normal()</tt>,
    <tt>exponential()</tt>, etc.
  <li>module parameters: <tt><a href="../api/classcPar.html">cPar</a></tt> class
  <li>storing data in containers: the <tt><a href="../api/classcArray.html">cArray</a></tt> and <tt><a href="../api/classcQueue.html">cQueue</a></tt> classes
  <li>routing support and discovery of network topology: <tt><a href="../api/classcTopology.html">cTopology</a></tt> class
  <li>recording statistics into files: <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> class
  <li>collecting simple statistics: <tt><a href="../api/classcStdDev.html">cStdDev</a></tt> and <tt>cWeightedStddev</tt> classes
  <li>distribution estimation: <tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt>,
    <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>, <tt><a href="../api/classcPSquare.html">cPSquare</a></tt>,
    <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> classes
  <li>making variables inspectable in the graphical user interface (Tkenv):
        the <tt>WATCH()</tt> macros
  <li>sending debug output to and prompting for user input in the graphical
    user interface (Tkenv<!--Tkenv-->): the <tt>ev</tt><!--ev--> object (<tt><a href="../api/classcEnvir.html">cEnvir</a></tt> class)
</ul>

<p>

<p>

<p><H2><A NAME="sec223"/>6.1 Class library conventions</H2>

<p><H3><A NAME="sec224"/>6.1.1 Base class</H3>
<a name="sec:ch-sim-lib:cobject"></a>

<p>
Classes in the OMNeT++ simulation library are derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>.
Functionality and conventions that come from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>:
<ul>
  <li>name attribute
  <li><tt>className()</tt> member and other member functions giving textual
    information about the object
  <li>conventions for assignment, copying, duplicating the object
  <li>ownership<!--ownership--> control for containers derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
  <li>support for traversing the object tree
  <li>support for inspecting the object in graphical user interfaces (Tkenv)
</ul>

<p>
Classes inherit and redefine several <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> member functions;
in the following we'll discuss some of the practically important
ones.

<p>
<H3><A NAME="sec225"/>6.1.2 Setting and getting attributes</H3>

<p>
Member functions that set and query object attributes follow
consistent naming. The setter member function has the form <tt>setFoo(...)</tt>
and its getter counterpart is named <tt>foo()</tt>. (The <i>get</i> verb found in Java
and some other libraries is omitted for brevity.)
For example, the <i>length</i> attribute of the <tt><a href="../api/classcMessage.html">cMessage</a></tt> class can
be set and read like this:

<pre>
msg-&gt;setLength(1024);
length = msg-&gt;length();
</pre>
<p>

<p><H3><A NAME="sec226"/>6.1.3 className()</H3>
<a name="sec:sim-lib:classname"></a>

<p>
For each class, the <tt>className()</tt> member function returns the class
name as a string:

<pre>
const char *classname = msg-&gt;className(); // returns "<a href="../api/classcMessage.html">cMessage</a>"
</pre>
<p>

<p><H3><A NAME="sec227"/>6.1.4 Name attribute</H3>
<a name="sec:sim-lib:name"></a>

<p>An object can be assigned a <i>name</i> (a character string). The name
string is the first argument to the constructor of every class,
and it defaults to <tt>NULL</tt> (no name string). An example:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *timeoutMsg = new <a href="../api/classcMessage.html">cMessage</a>("timeout");
</pre>
<p>
You can also set the name after the object has been created:

<pre>
timeoutMsg-&gt;setName("timeout");
</pre>
<p>
You can get a pointer to the internally stored copy of the name
string like this:

<pre>
const char *name = timeoutMsg-&gt;name(); // --&gt; "timeout"
</pre>
<p>
For convenience and efficiency reasons, the empty string <tt>""</tt>
and <tt>NULL</tt> are treated as equivalent by library objects.
That is, <tt>""</tt> is stored as <tt>NULL</tt> but returned as <tt>""</tt>.
If you create a message object with either <tt>NULL</tt>
or <tt>""</tt> as name string, it will be stored as <tt>NULL</tt>
and <tt>name()</tt> will return a pointer to a static <tt>""</tt>.

<pre>
<a href="../api/classcMessage.html">cMessage</a> *msg = new <a href="../api/classcMessage.html">cMessage</a>(NULL, &lt;additional args&gt;);
const char *str = msg-&gt;name(); // --&gt; returns ""
</pre>
<p>

<p><H3><A NAME="sec228"/>6.1.5 fullName() and fullPath()</H3>
<a name="sec:sim-lib:fullname-and-fullpath"></a>

<p>
Objects have two more member functions which return strings
based on object names: <tt>fullName()</tt> and <tt>fullPath()</tt>.
For gates and modules which are part of gate or module vectors,
<tt>fullName()</tt> returns the name with the index in brackets.
That is, for a module <tt>node[3]</tt> in the submodule vector <tt>node[10]</tt>
<tt>name()</tt> returns <tt>"node"</tt>, and <tt>fullName()</tt> returns <tt>"node[3]"</tt>.
For other objects, <tt>fullName()</tt> is the same as <tt>name()</tt>.

<p><tt>fullPath()</tt> returns <tt>fullName()</tt>, prepended with the
parent or owner object's <tt>fullPath()</tt> and separated by a dot.
That is, if the <tt>node[3]</tt> module above is in the compound module
<tt>"net.subnet1"</tt>, its <tt>fullPath()</tt> method will return
<tt>"net.subnet1.node[3]"</tt>.

<pre>
ev &lt;&lt; this-&gt;name();     // --&gt; "node"
ev &lt;&lt; this-&gt;fullName(); // --&gt; "node[3]"
ev &lt;&lt; this-&gt;fullPath(); // --&gt; "net.subnet1.node[3]"
</pre>
<p>
<tt>className()</tt>, <tt>fullName()</tt> and <tt>fullPath()</tt>
are extensively used on the graphical runtime environment Tkenv,
and also appear in error messages.

<p><tt>name()</tt> and <tt>fullName()</tt> return <tt>const char *</tt> pointers,
and <tt>fullPath()</tt> returns <tt>std::string</tt>. This makes no difference
with <tt>ev&lt;&lt;</tt>, but when <tt>fullPath()</tt> is used as a <tt>"%s"</tt> argument
to <tt>sprintf()</tt> you have to write <tt>fullPath().c_str()</tt>.

<pre>
char buf[100];
sprintf("msg is '%80s'", msg-&gt;fullPath().c_str()); // note c_str()
</pre>
<p>

<p><H3><A NAME="sec229"/>6.1.6 Copying and duplicating objects</H3>

<p>
The <tt>dup()</tt> member function creates an exact copy of the
object<!--object!copy-->, duplicating<!--object!duplication-->
contained objects also if necessary. This is especially useful in the
case of message objects. <tt>dup()</tt> returns a pointer of type
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a>*</tt>, so it needs to be cast to the proper type:

<pre>
<a href="../api/classcMessage.html">cMessage</a> *copyMsg = (<a href="../api/classcMessage.html">cMessage</a> *) msg-&gt;dup();
</pre>
<p>

<p><tt>dup()</tt> works by calling the copy constructor, which in
turn relies on the assignment operator between objects.
<tt>operator=()</tt> can be used to copy contents of an object into
another object of the same type. This is a deep copy: object
contained in the object will also be duplicated if necessary.
<tt>operator=()</tt> does not copy the name string -- this task is done
by the copy constructor<!--copy constructor-->.

<p>
<H3><A NAME="sec230"/>6.1.7 Iterators</H3>

<p>
There are several container classes in the library (<tt><a href="../api/classcQueue.html">cQueue</a></tt>,
<tt><a href="../api/classcArray.html">cArray</a></tt> etc.) For many of them, there is a corresponding
iterator class that you can use to loop through the objects stored in
the container.

<p>For example:

<pre>
<a href="../api/classcQueue.html">cQueue</a> queue;

//..
for (<a href="../api/classcQueue.html">cQueue</a>::Iterator queueIter(queue); !queueIter.end(); queueIter++)
{
    <a href="../api/classcOwnedObject.html">cOwnedObject</a> *containedObject = queueIter();
}
</pre>
<p>

<p>
<H3><A NAME="sec231"/>6.1.8 Error handling</H3>

<p>
When library objects detect an error condition, they throw a C++ exception.
This exception is then caught by the simulation environment which pops up
an error dialog or displays the error message.

<p>At times it can be useful to be able stop the simulation at the place of the error
(just before the exception is thrown) and use a C++ debugger to look
at the stack trace and examine variables. Enabling the <tt>debug-on-errors</tt>
ini file entry lets you do that -- check it in section
<a href="#"></a>  .

<p>If you detect an error condition in your code, you can stop the
simulation with an error message using the <tt>opp_error()</tt> function.
<tt>opp_error()</tt>'s argument list works like <tt>printf()</tt>: the
first argument is a format string which can contain <tt>"%s"</tt>, <tt>"%d"</tt> etc,
filled in using subsequent arguments.

<p>An example:

<pre>
if (msg-&gt;controlInfo()==NULL)
    opp_error("message (%s)%s has no control info attached",
              msg-&gt;className(), msg-&gt;name());
</pre>
<p>

<p>
<H2><A NAME="sec232"/>6.2 Logging from modules</H2>

<p>The logging feature will be used extensively in the code examples,
we introduce it here.

<p>The <tt>ev</tt><!--ev--> object represents the user interface of the
simulation.  You can send debugging output to <tt>ev</tt> with the C++-style
output operators:

<pre>
ev &lt;&lt; "packet received, sequence number is " &lt;&lt; seqNum &lt;&lt; endl;
ev &lt;&lt; "queue full, discarding packet\n";
</pre>
<p>
An alternative solution is <tt>ev.printf()</tt>:

<pre>
ev.printf("packet received, sequence number is %d\n", seqNum);
</pre>
<p>
The exact way messages are displayed to the user depends on the user
interface. In the command-line user interface (Cmdenv<!--Cmdenv-->),
it is simply dumped to the standard output. (This output can also be
disabled from <tt>omnetpp.ini</tt> so that it doesn't slow down simulation
when it is not needed.) In Tkenv, the runtime GUI, you can open
a text output window for every module.
It is not recommended that you use <tt>printf()</tt> or <tt>cout</tt>
to print messages -- <tt>ev</tt> output can be controlled much better
from <tt>omnetpp.ini</tt> and it is more convenient to view, using Tkenv.

<p>One can save CPU cycles by making logging statements conditional
on whether the output actually gets displayed or recorded anywhere.
The <tt>ev.disabled()</tt> call returns true when <tt>ev&lt;&lt;</tt> output is disabled,
such as in Tkenv or Cmdenv ``express'' mode. Thus, one can write code like
this:

<pre>
if (!ev.disabled())
    ev &lt;&lt; "Packet " &lt;&lt; msg-&gt;name() &lt;&lt; " received\n";
</pre>
<p>
A more sophisticated implementation of the same idea is to define
an <tt>EV</tt> macro which can be used in logging statements instead of
<tt>ev</tt>. The definition:

<pre>
#define EV  ev.disabled()?std::cout:ev
</pre>
<p>
And after that, one would simply write <tt>EV&lt;&lt;</tt> instead of <tt>ev&lt;&lt;</tt>.

<pre>
EV &lt;&lt; "Packet " &lt;&lt; msg-&gt;name() &lt;&lt; " received\n";
</pre>
<p>
The slightly tricky definition of <tt>EV</tt> makes use of the fact
that the <tt>&lt;&lt;</tt> operator binds looser than <tt>?:</tt>.

<p>

<p><H2><A NAME="sec233"/>6.3 Simulation time conversion</H2>

<p>Simulation time is represented by the type <tt>simtime_t</tt>
which is a typedef to <tt>double</tt>.
OMNeT++ provides utility functions, which convert <tt>simtime_t</tt>
to a printable string (<tt>"3s 130ms 230us"</tt>) and vica versa.

<p>The <tt>simtimeToStr()</tt> function converts a <tt>simtime_t</tt>
(passed in the first argument) to textual form. The result is placed into
the <tt>char</tt> array pointed to by the second argument. If the second argument is omitted
or it is <tt>NULL</tt>, <tt>simtimeToStr()</tt> will place the result into a
static buffer which is overwritten with each call. An example:

<pre>
char buf[32];
ev.printf("t1=%s, t2=%s\n", simtimeToStr(t1), simTimeToStr(t2,buf));
</pre>
<p>
The <tt>simtimeToStrShort()</tt> is similar to <tt>simtimeToStr()</tt>,
but its output is more concise.

<p>The <tt>strToSimtime()</tt> function parses a time specification passed
in a string, and returns a <tt>simtime_t</tt>. If the string cannot
be entirely interpreted, -1 is returned.

<pre>
simtime_t t = strToSimtime("30s 152ms");
</pre>
<p>
Another variant, <tt>strToSimtime0()</tt> can be used if the time
string is a substring in a larger string. Instead of taking a <tt>char*</tt>,
it takes a reference to <tt>char*</tt> (<tt>char*&amp;</tt>) as the first argument.  The
function sets the pointer to the first character that could not be
interpreted as part of the time string, and returns the value. It
never returns -1; if nothing at the beginning of the string looked
like simulation time, it returns 0.

<pre>
const char *s = "30s 152ms and something extra";

simtime_t t = strToSimtime0(s); // now s points to "and something extra"
</pre>
<p>

<p><H2><A NAME="sec234"/>6.4 Generating random numbers</H2>
<a name="cha:sim-lib:generating-random-numbers"></a>

<p>Random numbers in simulation are never random. Rather, they are
produced using deteministic algorithms. Algorithms take a <i>seed</i> value
and perform some deterministic calculations on them to produce
a ``random'' number and the next seed. Such algorithms and their
implementations are called <i>random number generators</i> or RNGs,
or sometimes pseudo random number generators or PRNGs to highlight
their deterministic nature.
  <br><ul><font size=-1>[There are real random numbers as well, see e.g.
  http://www.random.org/, http://www.comscire.com, or the Linux
  <i>/dev/random</i> device. For non-random numbers, try www.noentropy.net.]</font></ul>

<p>Starting from the same seed, RNGs always produce the same sequence
of random numbers. This is a useful property and of great importance,
because it makes simulation runs repeatable.

<p>RNGs produce uniformly distributed integers in some range,
usually between 0 or 1 and <i>2<sup>32</sup></i> or so. Mathematical transformations
are used to produce random variates from them that correspond to
specific distributions.

<p><H3><A NAME="sec235"/>6.4.1 Random number generators</H3>
<a name="sec:sim-lib:rngs"></a>
<!--random number generator-->

<p><p class="subheading">Mersenne Twister</p>

<p>By default, OMNeT++ uses the Mersenne Twister RNG (MT) by M. Matsumoto and
T. Nishimura [<a href="#bib-Matsumoto98">Matsumoto98</a>]. MT has a period of <i>2<sup>19937</sup>-1</i>,
and 623-dimensional equidistribution property is assured. MT is
also very fast: as fast or faster than ANSI C's <tt>rand()</tt>.

<p><p class="subheading">The "minimal standard" RNG</p>

<p>OMNeT++ releases prior to 3.0 used a linear congruential generator
(LCG) with a cycle length of <i>2<sup>31</sup>-2</i>, described in
[<a href="#bib-Jain91">Jain91</a>], pp. 441-444,455. This RNG is still available
and can be selected from <tt>omnetpp.ini</tt> (Chapter <a href="#sec287">[8]</a>).
This RNG is only suitable for small-scale simulation studies.
As shown by Karl Entacher et al. in [<a href="#bib-Entacher02">Entacher02</a>],
the cycle length of about <i>2<sup>31</sup></i> is too small (on todays
fast computers it is easy to exhaust all random numbers), and
the structure of the generated ``random'' points is too regular.
The [<a href="#bib-Hellekalek98">Hellekalek98</a>] paper provides a broader overview of issues
associated with RNGs used for simulation, and it is well worth reading.
It also contains useful links and references on the topic.

<p><p class="subheading">The Akaroa RNG</p>

<p>When you execute simulations under Akaroa control (see section
<a href="#sec329">[8.13]</a>), you can also select Akaroa's
RNG as the RNG underlying for the OMNeT++ random number functions.
The Akaroa RNG also has to be selected from <tt>omnetpp.ini</tt>
(section <a href="#sec311">[8.9]</a>).

<p><p class="subheading">Other RNGs</p>

<p>OMNeT++ allows plugging in your own RNGs as well. This mechanism,
based on the <tt><a href="../api/classcRNG.html">cRNG</a></tt> interface, is described in section
<a href="#sec411">[14.5.3]</a>.
For example, one candidate to include could be L'Ecuyer's CMRG [<a href="#bib-LEcuyer02">LEcuyer02</a>]
which has a period of about <i>2<sup>191</sup></i> and can provide a large
number of <i>guaranteed</i> independent streams.

<p>
<H3><A NAME="sec236"/>6.4.2 Random number streams, RNG mapping</H3>

<p>Simulation programs may consume random numbers from several streams,
that is, from several independent RNG instances. For example, if a
network simulation uses random numbers for generating packets and
for simulating bit errors in the transmission, it might be a good
idea to use different random streams for both. Since the seeds
for each stream can be configured independently, this arrangement
would allow you to perform several simulation runs with the same traffic
but with bit errors occurring in different places.
A simulation technique called <i>variance reduction</i> is
also related to the use of different random number streams.

<p>It is also important that different streams and also different
simulation runs use non-overlapping series of random numbers.
Overlap in the generated random number sequences can introduce
unwanted correlation in your results.

<p>The number of random number streams as well as seeds for the individual
streams can be configured in <tt>omnetpp.ini</tt>
(section <a href="#sec311">[8.9]</a>).
For the "minimal standard RNG", the <tt>seedtool</tt> program can be
used for selecting good seeds (section <a href="#sec317">[8.9.6]</a>).

<p>In OMNeT++, streams are identified with RNG numbers. The RNG numbers
used in simple modules may be <i>arbitrarily mapped</i> to the actual
random number streams (actual RNG instances) from <tt>omnetpp.ini</tt>
(section <a href="#sec311">[8.9]</a>). The mapping allows
for great flexibility in RNG usage and random number streams
configuration -- even for simulation models which were not written
with RNG awareness.

<p>
<H3><A NAME="sec237"/>6.4.3 Accessing the RNGs</H3>

<p>The <tt>intrand(n)</tt> function generates random integers in the range <i>[0, n-1]</i>, and
<tt>dblrand()</tt> generates a random double on <i>[0,1)</i>. These functions
simply wrap the underlying RNG objects. Examples:

<pre>
int dice = 1 + intrand(6); // result of intrand(6) is in the range 0..5
double p = dblrand();      // dblrand() produces numbers in [0,1)
</pre>
<p>
They also have a counterparts that use generator <i>k</i>:

<pre>
int dice = 1 + genk_intrand(k,6); // uses generator k
double prob = genk_dblrand(k);    // ""
</pre>
<p>
The underlying RNG objects are subclassed from <tt><a href="../api/classcRNG.html">cRNG</a></tt>,
and they can be accessed via <tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>rng()</tt> method.
The argument to <tt>rng()</tt> is a local RNG number which will undergo
RNG mapping.

<pre>
<a href="../api/classcRNG.html">cRNG</a> *rng1 = rng(1);
</pre>
<p>
<tt><a href="../api/classcRNG.html">cRNG</a></tt> contains the methods implementing the above <tt>intrand()</tt>
and <tt>dblrand()</tt> functions. The <tt><a href="../api/classcRNG.html">cRNG</a></tt> interface also allows
you to access the ``raw'' 32-bit random numbers generated by the RNG
and to learn their ranges (<tt>intRand()</tt>, <tt>intRandMax()</tt>) as well as
to query the number of random numbers generated (<tt>numbersDrawn()</tt>).

<p>
<H3><A NAME="sec238"/>6.4.4 Random variates</H3>

<p>The following functions are based on <tt>dblrand()</tt> and return
random variables of different distributions<!--distribution!random variables--><!--random!numbers from distributions-->:

<p>Random variate functions use one of the random number generators (RNGs)
provided by OMNeT++. By default this is generator 0, but you can specify
which one to be used.

<p>OMNeT++ has the following predefined distributions<!--distribution!predefined-->:

<p><table border>
<TR> <TD align=left>
<b>Function</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>Continuous distributions</b></TD></TR>
<TR> <TD align=left> <tt>uniform(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> uniform distribution in the range [a,b) </TD></TR>
<TR> <TD align=left> <tt>exponential(mean, <i>rng=0</tt>)</i> </TD> <TD align=left> exponential distribution with the given mean </TD></TR>
<TR> <TD align=left> <tt>normal(mean, stddev, <i>rng=0</tt>)</i> </TD> <TD align=left> normal distribution with the given mean and standard deviation </TD></TR>
<TR> <TD align=left> <tt>truncnormal(mean, stddev, <i>rng=0</tt>)</i> </TD> <TD align=left> normal distribution truncated to nonnegative values </TD></TR>
<TR> <TD align=left> <tt>gamma_d(alpha, beta, <i>rng=0</tt>)</i> </TD> <TD align=left> gamma distribution with parameters alpha&gt;0, beta&gt;0 </TD></TR>
<TR> <TD align=left> <tt>beta(alpha1, alpha2, <i>rng=0</tt>)</i> </TD> <TD align=left> beta distribution with parameters alpha1&gt;0, alpha2&gt;0 </TD></TR>
<TR> <TD align=left> <tt>erlang_k(k, mean, <i>rng=0</tt>)</i> </TD> <TD align=left> Erlang distribution with k&gt;0 phases and the given mean </TD></TR>
<TR> <TD align=left> <tt>chi_square(k, <i>rng=0</tt>)</i> </TD> <TD align=left> chi-square distribution with k&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>student_t(i, <i>rng=0</tt>)</i> </TD> <TD align=left> student-t distribution with i&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>cauchy(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> Cauchy distribution with parameters a,b where b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>triang(a, b, c, <i>rng=0</tt>)</i> </TD> <TD align=left> triangular distribution with parameters a&lt;=b&lt;=c, a!=c </TD></TR>
<TR> <TD align=left> <tt>lognormal(m, s, rng=0)</tt> </TD> <TD align=left> lognormal distribution with mean m and variance s&gt;0 </TD></TR>
<TR> <TD align=left> <tt>weibull(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> Weibull distribution with parameters a&gt;0, b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>pareto_shifted(a, b, c, <i>rng=0</tt>)</i> </TD> <TD align=left> generalized Pareto distribution with parameters a, b and shift c </TD></TR>
<TR> <TD align=center colspan=2><b>Discrete distributions</b> </TD></TR>
<TR> <TD align=left> <tt>intuniform(a, b, <i>rng=0</tt>)</i> </TD> <TD align=left> uniform integer from a..b </TD></TR>
<TR> <TD align=left> <tt>bernoulli(p, <i>rng=0</tt>)</i> </TD> <TD align=left> result of a Bernoulli trial with probability 0&lt;=p&lt;=1 (1 with probability p and 0 with probability (1-p)) </TD></TR>
<TR> <TD align=left> <tt>binomial(n, p, <i>rng=0</tt>)</i> </TD> <TD align=left> binomial distribution with parameters n&gt;=0 and 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>geometric(p, <i>rng=0</tt>)</i> </TD> <TD align=left> geometric distribution with parameter 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>negbinomial(n, p, <i>rng=0</tt>)</i> </TD> <TD align=left> binomial distribution with parameters n&gt;0 and 0&lt;=p&lt;=1</TD></TR>
<TR> <TD align=left> <tt>poisson(lambda, <i>rng=0</tt>)</i> </TD> <TD align=left> Poisson distribution with parameter lambda </TD></TR>
<TR> <TD align=left>
</table>

<p>
They are the same functions that can be used in NED files.
<tt>intuniform()</tt> generates integers including both the lower and
upper limit, so for example the outcome of tossing a coin could be
written as intuniform(1,2).  <tt>truncnormal()</tt> is the normal
distribution truncated to nonnegative values; its implementation
generates a number with normal distribution and if the result is
negative, it keeps generating other numbers until the outcome is
nonnegative.

<p>If the above distributions do not suffice, you can write your own
functions<!--distribution!custom-->. If you register your functions
with the <tt>Register_Function()</tt> macro, you can use them in NED
files and ini files too.

<p>
<H3><A NAME="sec239"/>6.4.5 Random numbers from histograms</H3>

<p>You can also specify your distribution as a
histogram<!--distribution!as histogram-->. The
<tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt>, <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>,
<tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>, <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> or <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> classes
are there to generate random numbers from equidistant-cell or
equiprobable-cell histograms.  This feature is documented later, with
the statistical classes.

<p>

<p>

<p><H2><A NAME="sec240"/>6.5 Container classes</H2>

<p><H3><A NAME="sec241"/>6.5.1 Queue class: <a href="../api/classcQueue.html">cQueue</a></H3>

<p><p class="subheading">Basic usage</p>

<p>
<tt><a href="../api/classcQueue.html">cQueue</a></tt> is a container class that acts as a queue.
<tt><a href="../api/classcQueue.html">cQueue</a></tt> can hold objects of type derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
(almost all classes from the OMNeT++ library), such as
<tt><a href="../api/classcMessage.html">cMessage</a></tt>, <tt><a href="../api/classcPar.html">cPar</a></tt>, etc. Internally, <tt><a href="../api/classcQueue.html">cQueue</a></tt>
uses a double-linked list to store the elements.

<p>A queue object has a head and a tail. Normally, new elements
are inserted at its head and elements are removed at its tail.

<p>

<p>  <div align=center>
    <img src="usmanFig10.png">
    <center><i>Figure: <a href="../api/classcQueue.html">cQueue</a>: insertion and removal</i></center>
    <a name="fig:ch-sim-lib:cqueue"></a>
  </div>

<p>
The basic <tt><a href="../api/classcQueue.html">cQueue</a></tt> member functions dealing with insertion and removal
are <tt>insert()</tt> and <tt>pop()</tt>. They are used
like this:

<pre>
<a href="../api/classcQueue.html">cQueue</a> queue("my-queue");
<a href="../api/classcMessage.html">cMessage</a> *msg;

// insert messages
for (int i=0; i&lt;10; i++)
{
  msg = new <a href="../api/classcMessage.html">cMessage</a>;
  queue.insert( msg );
}

// remove messages
while( ! queue.empty() )
{
  msg = (<a href="../api/classcMessage.html">cMessage</a> *)queue.pop();
  delete msg;
}
</pre>
<p>

<p>The <tt>length()</tt> member function returns the number of items in the
queue, and <tt>empty()</tt> tells whether there's anything in the queue.

<p>There are other functions dealing with insertion and removal.  The
<tt>insertBefore()</tt> and <tt>insertAfter()</tt> functions insert a
new item exactly before and after a specified one, regardless of the
ordering function.

<p>The <tt>tail()</tt> and <tt>head()</tt> functions return pointers to the objects
at the tail and head of the queue, without affecting queue contents.

<p>The <tt>pop()</tt> function can be used to remove items from the
tail of the queue, and the <tt>remove()</tt> function can be
used to remove any item known by its pointer from the queue:

<pre>
queue.remove( msg );
</pre>
<p>

<p>
<p class="subheading">Priority queue</p>

<p>
By default, <tt><a href="../api/classcQueue.html">cQueue</a></tt> implements a FIFO, but it can also act as
a priority queue, that is, it can keep the inserted objects
ordered<!--queue!order-->.  If you want to use this feature, you have
to provide a function that takes two <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> pointers,
compares the two objects and returns -1, 0 or 1 as the result (see the
reference for details).  An example of setting up an ordered
<tt><a href="../api/classcQueue.html">cQueue</a></tt>:

<pre>
<a href="../api/classcQueue.html">cQueue</a> sortedqueue("sortedqueue", <a href="../api/classcOwnedObject.html">cOwnedObject</a>::cmpbyname, true );
                        // sorted by object name, ascending
</pre>
<p>

<p>If the queue object is set up as an ordered queue, the <tt>insert()</tt>
function uses the ordering function: it searches the queue contents
from the head until it reaches the position where the new item
needs to be inserted, and inserts it there.

<p>
<p class="subheading">Iterators</p>

<p>
Normally, you can only access the objects at the head or tail of the
queue. However, if you use an iterator class, <tt><a href="../api/classcQueue.html">cQueue</a>::Iterator</tt>,
you can examine each object in the queue<!--queue!iteration-->.

<p>The <tt><a href="../api/classcQueue.html">cQueue</a>::Iterator</tt> constructor takes two arguments, the first
is the queue object and the second one specifies the initial position
of the iterator: 0=tail, 1=head. Otherwise it acts as any other
OMNeT++ iterator class: you can use the ++ and -- operators to advance
it, the () operator to get a pointer to the current item, and the
<tt>end()</tt> member function to examine if you're at the end (or the
beginning) of the queue.

<p>
An example:

<pre>
for( <a href="../api/classcQueue.html">cQueue</a>::Iterator iter(queue,1); !iter.end(), iter++)
{
  <a href="../api/classcMessage.html">cMessage</a> *msg = (<a href="../api/classcMessage.html">cMessage</a> *) iter();
  //...
}
</pre>
<p>

<p>

<p><H3><A NAME="sec242"/>6.5.2 Expandable array: <a href="../api/classcArray.html">cArray</a></H3>

<p><p class="subheading">Basic usage</p>

<p>
<tt><a href="../api/classcArray.html">cArray</a></tt> is a container class that holds objects derived from
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>. <tt><a href="../api/classcArray.html">cArray</a></tt> stores the pointers of the objects
inserted instead of making copies. <tt><a href="../api/classcArray.html">cArray</a></tt> works as an array,
but it grows automatically when it gets full. Internally,
<tt><a href="../api/classcArray.html">cArray</a></tt> is implemented with an array of pointers; when the array
fills up, it is reallocated.

<p><tt><a href="../api/classcArray.html">cArray</a></tt> objects are used in OMNeT++ to store parameters
attached to messages, and internally, for storing module parameters
and gates.

<p>
Creating an array:

<pre>
<a href="../api/classcArray.html">cArray</a> array("array");
</pre>
<p>
Adding an object at the first free index:

<pre>
<a href="../api/classcPar.html">cPar</a> *p = new <a href="../api/classcPar.html">cPar</a>("par");
int index = array.add( p );
</pre>
<p>

<p>Adding an object at a given index (if the index is occupied,
you'll get an error message):

<pre>
<a href="../api/classcPar.html">cPar</a> *p = new <a href="../api/classcPar.html">cPar</a>("par");
int index = array.addAt(5,p);
</pre>
<p>

<p>Finding an object in the array:

<pre>
int index = array.find(p);
</pre>
<p>
Getting a pointer to an object at a given index:

<pre>
<a href="../api/classcPar.html">cPar</a> *p = (<a href="../api/classcPar.html">cPar</a> *) array[index];
</pre>
<p>
You can also search the array or get a pointer to an object by
the object's name:

<pre>
int index = array.find("par");
Par *p = (<a href="../api/classcPar.html">cPar</a> *) array["par"];
</pre>
<p>

<p>You can remove an object from the array by calling <tt>remove()</tt>
with the object name, the index position or the object pointer:

<pre>
array.remove("par");
array.remove(index);
array.remove( p );
</pre>
<p>

<p>The <tt>remove()</tt> function doesn't deallocate the object, but it
returns the object pointer. If you also want to deallocate it, you can
write:

<pre>
delete array.remove( index );
</pre>
<p>
<p class="subheading">Iteration</p>

<p>
<tt><a href="../api/classcArray.html">cArray</a></tt> has no iterator, but it is easy to loop through all the
indices with an integer variable. The <tt>items()</tt> member function
returns the largest index plus one.

<pre>
for (int i=0; i&lt;array.items(); i++)
{
  if (array[i]) // is this position used?
  {
    <a href="../api/classcOwnedObject.html">cOwnedObject</a> *obj = array[i];
    ev &lt;&lt; obj-&gt;name() &lt;&lt; endl;
  }
}
</pre>
<p>



<p>

<p><H2><A NAME="sec243"/>6.6 The parameter class: <a href="../api/classcPar.html">cPar</a></H2>
<a name="sec:ch-sim-lib:cpar"></a>

<p>Module parameters (as discussed in section <a href="#sec188">[4.7]</a>)
are represented as <tt><a href="../api/classcPar.html">cPar</a></tt> objects.
The module parameter name is the <tt><a href="../api/classcPar.html">cPar</a></tt> object's name, and the object
can store any parameter type supported by the NED language, that is,
numeric (long or double), bool, string and XML config file reference.
    <br><ul><font size=-1>[<tt><a href="../api/classcPar.html">cPar</a></tt> objects used to be employed also for adding
    parameters (extra fields) to <tt><a href="../api/classcMessage.html">cMessage</a></tt>. While technically this is
    still feasible, message definitions (section <a href="#sec212">[5.2]</a>)
    are a far superior solution in every respect.]</font></ul>

<p>Module parameters are accessed via <tt><a href="../api/classcModule.html">cModule</a></tt>'s <tt>par()</tt> method:

<pre>
<a href="../api/classcPar.html">cPar</a>& par(const char *parameterName);
</pre>
<p>
<H3><A NAME="sec244"/>6.6.1 Reading the value</H3>

<p><tt><a href="../api/classcPar.html">cPar</a></tt> has a number of methods for getting the parameter's value:

<pre>
bool boolValue();
long longValue();
const char *stringValue();
double doubleValue();
<a href="../api/classcXMLElement.html">cXMLElement</a> *xmlValue();
</pre>
<p>
There are also overloaded type cast operators for C/C++ primitive types
including <tt>bool</tt>, <tt>int</tt>, <tt>long</tt>, <tt>double</tt>, <tt>const char *</tt>,
and also for <tt><a href="../api/classcXMLElement.html">cXMLElement</a> *</tt>.
    <br><ul><font size=-1>[<tt><a href="../api/classcPar.html">cPar</a></tt> also supports the <tt>void *</tt> and <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a> *</tt> types,
    but these types were used primarily for message parameters before
    message definitions (section <a href="#sec212">[5.2]</a>)
    got supported, and you cannot create such module parameters from NED.]</font></ul>

<p>Thus, any of the following ways would work to store a parameter's value in
a variable:

<pre>
double foo = par("foo").doubleValue();
double foo = (double) par("foo");
double foo = par("foo");
</pre>
<p>
If you use the <tt>par("foo")</tt> parameter in expressions (such as
<tt>4*par("foo")+2</tt>), the C++ compiler may be unable to decide
between overloaded operators and report ambiguity. In that case
you have to clarify by adding either an explicit cast
(<tt>(double)par("foo")</tt> or <tt>(long)par("foo")</tt>) or use
the <tt>doubleValue()</tt> or <tt>longValue()</tt> methods.

<p>The <tt>isConstant()</tt> method can be used to determine whether a
<tt><a href="../api/classcPar.html">cPar</a></tt> stores a constant, or an expression that may produce a different
value every time the object is read, such as <tt>1+exponential(0.5)</tt>.

<p>
<H3><A NAME="sec245"/>6.6.2 Changing the value</H3>

<p>There are many ways to set a <tt><a href="../api/classcPar.html">cPar</a></tt>'s value. One is the <tt>set...Value()</tt>
member functions:

<pre>
<a href="../api/classcPar.html">cPar</a>& foo = par("foo");
foo.setLongValue(12);
foo.setDoubleValue(2.7371);
foo.setStringValue("one two three");
</pre>
<p>
There are also overloaded assignment operators for C++ primitive types,
<tt>const char *</tt>, and <tt><a href="../api/classcXMLElement.html">cXMLElement</a> *</tt>.

<pre>
<a href="../api/classcPar.html">cPar</a> pp("pp");
pp = 12;
pp = 2.7371;
pp = "one two three";
</pre>
<p>
The <tt><a href="../api/classcPar.html">cPar</a></tt> object makes its own copy of the string, so the
original one does not need to be preserved. Short strings (less than
<it>~</it>20 chars) are handled more efficiently because they
are stored in the object's memory space (and are not dynamically
allocated).

<p><tt><a href="../api/classcPar.html">cPar</a></tt> can also store other types which yield numeric
results such as function with constant args;
they will be mentioned in the next section.

<p>For numeric and string types, an input flag<!--input flag--> can be
set. In this case, when the object's value is first used, the
parameter value will be searched for in the configuration (ini)
file<!--ini file-->; if it is not found there, the user will be offered
to enter the value interactively.

<p>Examples:

<pre>
<a href="../api/classcPar.html">cPar</a> foo("foo");
foo.setPrompt("Enter foo value:");
foo.setInput(true);   // make it an input parameter

double d = (double)foo; // the user will be prompted HERE
</pre>
<p>
Further <tt>set..()</tt> functions to assign other storage types,
e.g. double function with constant args (MathFuncNoArgs, MathFunc1Args, etc),
reverse Polish expression, compiled expressions based on
<tt>cDoubleExpression</tt>, random distribution based on a
<tt><a href="../api/classcStatistic.html">cStatistic</a></tt>'s <tt>random()</tt> method, pointer to <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>,
etc. are listed in the next section; however, they are rarely useful
for programming simulation models.

<p>

<H3><A NAME="sec246"/>6.6.3 <a href="../api/classcPar.html">cPar</a> storage types</H3>

<p><tt><a href="../api/classcPar.html">cPar</a></tt> supports the basic data types (long, double, bool, string, XML) via
several <i>storage types</i>. Storage types are internally
identified by type characters. The type character is
returned by the <tt>type()</tt> method.

<p>Example:

<pre>
<a href="../api/classcPar.html">cPar</a> par = 10L;
char typechar = par.type(); // returns storage type 'L'
</pre>
<p>
The all <tt><a href="../api/classcPar.html">cPar</a></tt> data types and are summarized in the table below.
The <tt>isNumeric()</tt> function tells whether the object
stores a data types which allows the <tt>doubleValue()</tt> method
to be called.

<p><table border>
<TR> <TD align=left>

<b>Type<br> char</b> </TD> <TD align=left>
<b>Storage<br> type</b> </TD> <TD align=left>
<b>Member functions</b> </TD> <TD align=left>
<b>Description</b></TD></TR>
<TR> <TD align=left>
S </TD> <TD align=left>  string </TD> <TD align=left>
<tt>setStringValue( <br>
  const char *); <br>
const char * <br>
 <tt>stringValue()</tt>; <br>
op const char *(); <br>
op=(const char *);</tt> </TD> <TD align=left>

string value. Short strings (len<tt>&lt;</tt>=27) are stored inside
<tt><a href="../api/classcPar.html">cPar</a></tt> object, without using heap allocation.</TD></TR>
<TR> <TD align=left> B </TD> <TD align=left>  boolean </TD> <TD align=left>
<tt>setBoolValue(bool); <br>
bool <tt>boolValue()</tt>; <br>
op <tt>bool()</tt>; <br>
op=(bool);</tt> </TD> <TD align=left>
boolean value. Can also be retrieved from the object as long  (0 or 1).</TD></TR>
<TR> <TD align=left> L </TD> <TD align=left> long int </TD> <TD align=left>
<tt>setLongValue(long); <br>
long <tt>longValue()</tt>; <br>
op <tt>long()</tt>; <br>
op=(long);</tt> </TD> <TD align=left>
signed long integer value. Can also be retrieved from the object
as double.</TD></TR>
<TR> <TD align=left> D </TD> <TD align=left> double </TD> <TD align=left>
<tt>setDoubleValue(double); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
op=(double);</tt> </TD> <TD align=left>
double-precision floating point value.</TD></TR>
<TR> <TD align=left> F </TD> <TD align=left> function </TD> <TD align=left>
<tt>setDoubleValue( <br>
 MathFunc, <br>
 [double], <br>
 [double], <br>
 [double]); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
</tt> </TD> <TD align=left>
Mathematical function with constant arguments. The function
is given by its pointer; it must take 0,1,2 or 3 doubles and
return a double. This type is mainly used to generate random
numbers: e.g. the function takes mean and standard deviation
and returns a random variable of a certain distribution.</TD></TR>
<TR> <TD align=left> X </TD> <TD align=left> expr. </TD> <TD align=left>
<tt>setDoubleValue( <br>
 <a href="../api/classcPar.html">cPar</a>::ExprElem*,int); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>;</tt>
</TD> <TD align=left>
Runtime-evaluated Reverse Polish expression. Expression can contain constants,
<tt><a href="../api/classcPar.html">cPar</a></tt> objects, refer to other <tt>cPars</tt> (e.g. module parameters),
can use math operators (+-*/^% etc), function calls
(function must take 0,1,2 or 3 doubles and return a double).
The expression must be given in an array of <tt><a href="../api/classcPar.html">cPar</a>::ExprElem</tt> structs.</TD></TR>
<TR> <TD align=left> C </TD> <TD align=left> compiled<br> expr. </TD> <TD align=left>
<tt>setDoubleValue( <br>
 cDoubleExpression *expr); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>;</tt>
</TD> <TD align=left>
Runtime-evaluated compiled expression. The expression should be
supplied in a method of an object subclassed from <tt>cDoubleExpression</tt>.
</TD></TR>
<TR> <TD align=left> T </TD> <TD align=left> distrib. </TD> <TD align=left>
<tt>setDoubleValue( <br>
 <tt><a href="../api/classcStatistic.html">cStatistic</a></tt>*); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
</tt> </TD> <TD align=left>
random variable generated from a distribution collected by a
statistical data collection object (derived from <tt><a href="../api/classcStatistic.html">cStatistic</a></tt>).</TD></TR>
<TR> <TD align=left> M </TD> <TD align=left> XML </TD> <TD align=left>
<tt>setXMLValue( <br>
 <tt><a href="../api/classcXMLElement.html">cXMLElement</a></tt> *node); <br>
<tt><a href="../api/classcXMLElement.html">cXMLElement</a></tt> *<tt>xmlValue</tt>()</tt>; <br>
op <tt><a href="../api/classcXMLElement.html">cXMLElement</a>*()</tt>;
</TD> <TD align=left>
Reference to an XML element, found in an XML config file.
</TD></TR>
<TR> <TD align=left> P </TD> <TD align=left> void* pointer </TD> <TD align=left>
<tt>setPointerValue(void*); <br>
void *<tt>pointerValue()</tt>; <br>
op void *(); <br>
op=(void *);</tt> </TD> <TD align=left>
pointer to a non-<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> item (C struct, non-<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> object
etc.) Memory management can be controlled through the <tt>configPointer()</tt>
member function.</TD></TR>
<TR> <TD align=left> O </TD> <TD align=left> object pointer </TD> <TD align=left>
<tt>setObjectValue(<a href="../api/classcOwnedObject.html">cOwnedObject</a>*); <br>
<a href="../api/classcOwnedObject.html">cOwnedObject</a> *<tt>objectValue()</tt>; <br>
op <a href="../api/classcOwnedObject.html">cOwnedObject</a> *(); <br>
op=(<a href="../api/classcOwnedObject.html">cOwnedObject</a> *);</tt>
</TD> <TD align=left>
 pointer to an object derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>.
Ownership management is done through <tt>takeOwnership()</tt>.</TD></TR>
<TR> <TD align=left> I </TD> <TD align=left> indirect value </TD> <TD align=left>
<tt>setRedirection(<a href="../api/classcPar.html">cPar</a>*); <br>
bool <tt>isRedirected()</tt>; <br>
<a href="../api/classcPar.html">cPar</a> *<tt>redirection()</tt>; <br>
<tt>cancelRedirection()</tt>;</tt>
</TD> <TD align=left>
 value is redirected to another <tt><a href="../api/classcPar.html">cPar</a></tt> object. All value setting
and reading operates on the other <tt><a href="../api/classcPar.html">cPar</a></tt>; even the <tt>type()</tt> function
will return the type in the other <tt><a href="../api/classcPar.html">cPar</a></tt> (so you'll never get 'I'
as the type). This redirection can only be broken with the <tt>cancelRedirection()</tt>
member function. Module parameters taken by <tt>ref</tt> use this mechanism.</TD></TR>
</table>

<p>


<p><H2><A NAME="sec247"/>6.7 Routing support: <a href="../api/classcTopology.html">cTopology</a></H2>

<p><H3><A NAME="sec248"/>6.7.1 Overview</H3>

<p>The <tt><a href="../api/classcTopology.html">cTopology</a></tt> class was designed primarily to support
routing<!--routing support--> in telecommunication or multiprocessor
networks.

<p>A <tt><a href="../api/classcTopology.html">cTopology</a></tt> object stores an abstract representation of the
network in graph form:
<ul>
  <li>each <tt><a href="../api/classcTopology.html">cTopology</a></tt> node corresponds to a <i>module</i>
    (simple or compound), and
  <li>each <tt><a href="../api/classcTopology.html">cTopology</a></tt> edge corresponds to a <i>link</i> or
    <i>series of connecting links</i>.
</ul>

<p>You can specify which modules (either simple or compound) you want to
include in the graph. The graph will include all connections among the
selected modules. In the graph, all nodes are at the same level,
there's no submodule nesting.  Connections which span across compound
module boundaries are also represented as one graph edge. Graph edges
are directed, just as module gates are.

<p>
If you're writing a router or switch model, the <tt><a href="../api/classcTopology.html">cTopology</a></tt>
graph can help you determine what nodes are available through which
gate and also to find optimal routes<!--optimal routes-->. The
<tt><a href="../api/classcTopology.html">cTopology</a></tt> object can calculate shortest paths<!--shortest
  path--> between nodes for you.

<p>The mapping between the graph (nodes, edges) and network model
(modules, gates, connections) is preserved: you can easily find
the corresponding module for a <tt><a href="../api/classcTopology.html">cTopology</a></tt> node and vica versa.

<p>

<p>

<p><H3><A NAME="sec249"/>6.7.2 Basic usage</H3>

<p>You can extract the network topology into a <tt><a href="../api/classcTopology.html">cTopology</a></tt>
object by a single function call. You have several ways to select
which modules you want to include in the topology:
<ul>
  <li>by module type
  <li>by a parameter's presence and its value
  <li>with a user-supplied boolean function
</ul>

<p>First, you can specify which node types you want to include. The
following code extracts all modules of type <tt>Router</tt> or <tt>Host</tt>.
(<tt>Router</tt> and <tt>Host</tt> can be either simple or compound module types.)

<pre>
<a href="../api/classcTopology.html">cTopology</a> topo;
topo.extractByModuleType("Router", "Host", NULL);
</pre>
<p>
Any number of module types can be supplied; the list must be terminated by <tt>NULL</tt>.

<p>A dynamically assembled list of module types can be passed as a
<tt>NULL</tt>-terminated array of <tt>const char*</tt> pointers, or
in an STL string vector <tt>std::vector&lt;std::string&gt;</tt>.
An example for the former:

<pre>
<a href="../api/classcTopology.html">cTopology</a> topo;
const char *typeNames[3];
typeNames[0] = "Router";
typeNames[1] = "Host";
typeNames[2] = NULL;
topo.extractByModuleType(typeNames);
</pre>
<p>
Second, you can extract all modules which have a certain parameter:

<pre>
topo.extractByParameter( "ipAddress" );
</pre>
<p>
You can also specify that the parameter must have a certain value
for the module to be included in the graph:

<pre>
<a href="../api/classcPar.html">cPar</a> yes = "yes";
topo.extractByParameter( "includeInTopo", &yes );
</pre>
<p>
The third form allows you to pass a function which can determine for
each module whether it should or should not be included.  You can have
<tt><a href="../api/classcTopology.html">cTopology</a></tt> pass supplemental data to the function through a
<tt>void*</tt> pointer. An example which selects all top-level modules (and
does not use the <tt>void*</tt> pointer):

<pre>
int selectFunction(<a href="../api/classcModule.html">cModule</a> *mod, void *)
{
  return mod-&gt;parentModule() == simulation.systemModule();
}

topo.extractFromNetwork( selectFunction, NULL );
</pre>
<p>

A <tt><a href="../api/classcTopology.html">cTopology</a></tt> object uses two types: <tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt> for
nodes and <tt><a href="../api/classcTopology.html">cTopology</a>::Link</tt> for edges. (<tt>sTopoLinkIn</tt> and
<tt><a href="../api/classcTopology.html">cTopology</a>::LinkOut</tt> are `aliases' for <tt><a href="../api/classcTopology.html">cTopology</a>::Link</tt>; we'll
talk about them later.)

<p>Once you have the topology extracted, you can start exploring
it. Consider the following code (we'll explain it shortly):

<pre>
for (int i=0; i&lt;topo.nodes(); i++)
{
  <a href="../api/classcTopology.html">cTopology</a>::Node *node = topo.node(i);
  ev &lt;&lt; "Node i=" &lt;&lt; i &lt;&lt; " is " &lt;&lt; node-&gt;module()-&gt;fullPath() &lt;&lt; endl;
  ev &lt;&lt; " It has " &lt;&lt; node-&gt;outLinks() &lt;&lt; " conns to other nodes\n";
  ev &lt;&lt; " and " &lt;&lt; node-&gt;inLinks() &lt;&lt; " conns from other nodes\n";

  ev &lt;&lt; " Connections to other modules are:\n";
  for (int j=0; j&lt;node-&gt;outLinks(); j++)
  {
    <a href="../api/classcTopology.html">cTopology</a>::Node *neighbour = node-&gt;out(j)-&gt;remoteNode();
    <a href="../api/classcGate.html">cGate</a> *gate = node-&gt;out(j)-&gt;localGate();
    ev &lt;&lt; " " &lt;&lt; neighbour-&gt;module()-&gt;fullPath()
       &lt;&lt; " through gate " &lt;&lt; gate-&gt;fullName() &lt;&lt; endl;
  }
}
</pre>
<p>
The <tt>nodes()</tt> member function (1st line) returns the number of
nodes in the graph, and node(i) returns a pointer to the <i>i</i>th
node, an <tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt> structure.

<p>
The correspondence between a graph node and a module can be obtained
by:

<pre>
<a href="../api/classcTopology.html">cTopology</a>::Node *node = topo.nodeFor( module );
<a href="../api/classcModule.html">cModule</a> *module = node-&gt;module();
</pre>
<p>

<p>The <tt>nodeFor()</tt> member function returns a pointer to the graph
node for a given module. (If the module is not in the graph, it
returns <tt>NULL</tt>). <tt>nodeFor()</tt> uses binary search within the
<tt><a href="../api/classcTopology.html">cTopology</a></tt> object so it is fast enough.

<p>
<tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt>'s other member functions let you determine the
connections of this node: <tt>inLinks()</tt>, <tt>outLinks()</tt> return
the number of connections, <tt>in(i)</tt> and
<tt>out(i)</tt> return pointers to graph edge objects.

<p>
By calling member functions of the graph edge object, you can
determine the modules and gates involved. The <tt>remoteNode()</tt>
function returns the other end of the connection, and
<tt>localGate()</tt>, <tt>remoteGate()</tt>, <tt>localGateId()</tt> and
<tt>remoteGateId()</tt> return the gate pointers and ids of the gates
involved. (Actually, the implementation is a bit tricky here: the same
graph edge object <tt><a href="../api/classcTopology.html">cTopology</a>::Link</tt> is returned either as
<tt><a href="../api/classcTopology.html">cTopology</a>::LinkIn</tt> or as <tt><a href="../api/classcTopology.html">cTopology</a>::LinkOut</tt> so that ``remote''
and ``local'' can be correctly interpreted for edges of both
directions.)

<p>

<p>

<p><H3><A NAME="sec250"/>6.7.3 Shortest paths</H3>

<p>The real power of <tt><a href="../api/classcTopology.html">cTopology</a></tt> is in finding shortest
paths<!--topology!shortest path--> in the network to support optimal
routing<!--optimal routing-->. <tt><a href="../api/classcTopology.html">cTopology</a></tt> finds shortest paths
from <i>all</i> nodes <i>to</i> a target node. The algorithm is
computationally inexpensive. In the simplest case, all edges are
assumed to have the same weight.

<p>A real-life example when we have the target module pointer, finding
the shortest path looks like this:

<pre>
<a href="../api/classcModule.html">cModule</a> *targetmodulep =...;
<a href="../api/classcTopology.html">cTopology</a>::Node *targetnode = topo.nodeFor( targetmodulep );
topo.unweightedSingleShortestPathsTo( targetnode );
</pre>
<p>

<p>This performs the Dijkstra algorithm<!--Dijkstra algorithm--> and
stores the result in the <tt><a href="../api/classcTopology.html">cTopology</a></tt> object. The result can
then be extracted using <tt><a href="../api/classcTopology.html">cTopology</a></tt> and
<tt><a href="../api/classcTopology.html">cTopology</a>::Node</tt><!--<a href="../api/classcTopology.html">cTopology</a>::Node--> methods.  Naturally, each call to
<tt>unweightedSingleShortestPathsTo()</tt> overwrites the results of
the previous call.

<p>Walking along the path from our module to the target node:

<pre>
<a href="../api/classcTopology.html">cTopology</a>::Node *node = topo.nodeFor( this );

if (node == NULL)
{
  ev &lt; "We (" &lt;&lt; fullPath() &lt;&lt; ") are not included in the topology.\n";
}
else if (node-&gt;paths()==0)
{
  ev &lt;&lt; "No path to destination.\n";
}
else
{
  while (node != topo.targetNode())
  {
    ev &lt;&lt; "We are in " &lt;&lt; node-&gt;module()-&gt;fullPath() &lt;&lt; endl;
    ev &lt;&lt; node-&gt;distanceToTarget() &lt;&lt; " hops to go\n";
    ev &lt;&lt; "There are " &lt;&lt; node-&gt;paths()
       &lt;&lt; " equally good directions, taking the first one\n";
    <a href="../api/classcTopology.html">cTopology</a>::LinkOut *path = node-&gt;path(0);
    ev &lt;&lt; "Taking gate " &lt;&lt; path-&gt;localGate()-&gt;fullName()
       &lt;&lt; " we arrive in " &lt;&lt; path-&gt;remoteNode()-&gt;module()-&gt;fullPath()
       &lt;&lt; " on its gate " &lt;&lt; path-&gt;remoteGate()-&gt;fullName() &lt;&lt; endl;
    node = path-&gt;remoteNode();
  }
}
</pre>
<p>

<p>The purpose of the <tt>distanceToTarget()</tt> member function of a
node is self-explanatory. In the unweighted case, it returns the
number of hops. The <tt>paths()</tt> member function returns the number
of edges which are part of a shortest path, and
<tt>path(i)</tt> returns the <i>i</i>th edge of them as
<tt><a href="../api/classcTopology.html">cTopology</a>::LinkOut</tt>. If the shortest paths were created by the
<tt>...SingleShortestPaths()</tt> function,
<tt>paths()</tt> will always return 1 (or 0 if the target is not
reachable), that is, only one of the several possible shortest paths
are found.  The
<tt>...MultiShortestPathsTo()</tt> functions
find all paths, at increased run-time cost. The <tt><a href="../api/classcTopology.html">cTopology</a></tt>'s
<tt>targetNode()</tt> function returns the target node of the last
shortest path search.

<p>You can enable/disable nodes or edges in the graph. This is done by
calling their <tt>enable()</tt> or <tt>disable()</tt> member functions.
Disabled nodes or edges are ignored by the shortest paths calculation
algorithm. The <tt>enabled()</tt> member function returns the state of
a node or edge in the topology graph.

<p>One usage of <tt>disable()</tt> is when you want to determine in how many
hops the target node can be reached from our node <i>through
a particular output gate</i>. To calculate this, you calculate the
shortest paths to the target <i>from the neighbor node</i>, but
you must disable the current node to prevent the shortest paths
from going through it:

<pre>
<a href="../api/classcTopology.html">cTopology</a>::Node *thisnode = topo.nodeFor( this );
thisnode-&gt;disable();
topo.unweightedSingleShortestPathsTo( targetnode );
thisnode-&gt;enable();

for (int j=0; j&lt;thisnode-&gt;outLinks(); j++)
{
  <a href="../api/classcTopology.html">cTopology</a>::LinkOut *link = thisnode-&gt;out(i);
  ev &lt;&lt; "Through gate " &lt;&lt; link-&gt;localGate()-&gt;fullName() &lt;&lt; " : "
     &lt;&lt; 1 + link-&gt;remoteNode()-&gt;distanceToTarget() &lt;&lt; " hops" &lt;&lt; endl;
}
</pre>
<p>
In the future, other shortest path algorithms will also be implemented:

<pre>
unweightedMultiShortestPathsTo(<a href="../api/classcTopology.html">cTopology</a>::Node *target);
weightedSingleShortestPathsTo(<a href="../api/classcTopology.html">cTopology</a>::Node *target);
weightedMultiShortestPathsTo(<a href="../api/classcTopology.html">cTopology</a>::Node *target);
</pre>
<p>

<p>

<p>

<p><H2><A NAME="sec251"/>6.8 Statistics and distribution estimation</H2>

<p><H3><A NAME="sec252"/>6.8.1 <a href="../api/classcStatistic.html">cStatistic</a> and descendants</H3>

<p>There are several statistic and result collection classes:
<tt><a href="../api/classcStdDev.html">cStdDev</a></tt>, <tt><a href="../api/classcWeightedStdDev.html">cWeightedStdDev</a></tt>, <tt>LongHistogram</tt>,
<tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>, <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> and
<tt><a href="../api/classcKSplit.html">cKSplit</a></tt>. They are all derived from the abstract base class
<tt><a href="../api/classcStatistic.html">cStatistic</a></tt>.

<p><ul>
  <li><tt><a href="../api/classcStdDev.html">cStdDev</a></tt> keeps number of samples, mean, standard
    deviation, minimum and maximum value etc.
  <li><tt><a href="../api/classcWeightedStdDev.html">cWeightedStdDev</a></tt> is similar to <tt><a href="../api/classcStdDev.html">cStdDev</a></tt>, but
    accepts weighted observations. <tt><a href="../api/classcWeightedStdDev.html">cWeightedStdDev</a></tt> can be used
    for example to calculate time average. It is the only weighted
    statistics class.
  <li><tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt> and <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt> are
    descendants of <tt><a href="../api/classcStdDev.html">cStdDev</a></tt> and also keep an approximation of
    the distribution of the observations using equidistant
    (equal-sized) cell histograms<!--histogram!equal-sized-->.
  <li><tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt> implements a histogram where cells do not
    need to be the same size. You can manually add the cell (bin)
    boundaries, or alternatively, automatically have a partitioning
    created where each bin has the same number of observations (or as
    close to that as possible).
  <li><tt><a href="../api/classcPSquare.html">cPSquare</a></tt> is a class that uses the <i>P<sup>2</sup></i> algorithm
    described in [<a href="#bib-JCh85">JCh85</a>]. The algorithm calculates quantiles without
    storing the observations; one can also think of it as a histogram
    with equiprobable cells<!--histogram!equiprobable-cells-->.
  <li><tt><a href="../api/classcKSplit.html">cKSplit</a></tt> uses a novel, experimental method, based on an
    adaptive histogram-like algorithm.
</ul>

<p><p class="subheading">Basic usage</p>

<p>One can insert an observation into a statistic object with the
<tt>collect()</tt> function or the <tt>+=</tt> operator (they are
equivalent).  <tt><a href="../api/classcStdDev.html">cStdDev</a></tt> has the following methods for getting
statistics out of the object: <tt>samples()</tt>, <tt>min()</tt>,
<tt>max()</tt>, <tt>mean()</tt>, <tt>stddev()</tt>, <tt>variance()</tt>,
<tt>sum()</tt>, <tt>sqrSum()</tt> with the obvious meanings. An example
usage for <tt><a href="../api/classcStdDev.html">cStdDev</a></tt>:

<pre>
<a href="../api/classcStdDev.html">cStdDev</a> stat("stat");

for (int i=0; i&lt;10; i++)
  stat.collect( normal(0,1) );

long numSamples = stat.samples();
double smallest = stat.min(),
       largest = stat.max();
double mean = stat.mean(),
       standardDeviation = stat.stddev(),
       variance = stat.variance();
</pre>
<p>

<p>

<p>
<H3><A NAME="sec253"/>6.8.2 Distribution estimation</H3>

<p><p class="subheading">Initialization and usage</p>

<p>
The distribution estimation<!--distribution!estimation--> classes
(<tt><a href="../api/classcLongHistogram.html">cLongHistogram</a></tt>, <tt><a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a></tt>, <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt>,
<tt><a href="../api/classcPSquare.html">cPSquare</a></tt> and <tt><a href="../api/classcKSplit.html">cKSplit</a></tt>) are derived from
<tt><a href="../api/classcDensityEstBase.html">cDensityEstBase</a></tt>. Distribution estimation classes (except for
<tt><a href="../api/classcPSquare.html">cPSquare</a></tt>) assume that the observations are within a range.
You may specify the range explicitly (based on some a-priori info
about the distribution) or you may let the object collect the first
few observations and determine the range from them. Methods which let
you specify range settings are part of <tt><a href="../api/classcDensityEstBase.html">cDensityEstBase</a></tt>.

<p>The following member functions exist for setting up the range
and to specify how many observations should be used for
automatically determining the range.

<pre>
setRange(lower,upper);
setRangeAuto(numFirstvals, rangeExtFactor);
setRangeAutoLower(upper, numFirstvals, rangeExtFactor);
setRangeAutoUpper(lower, numFirstvals, rangeExtFactor);
</pre>
<p>
<pre>
setNumFirstVals(numFirstvals);
</pre>

<p>The following example creates a histogram with 20 cells and automatic
range estimation<!--histogram!range estimation-->:

<pre>
<a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a> histogram("histogram", 20);
histogram.setRangeAuto(100,1.5);
</pre>
<p>

<p>Here, 20 is the number of cells (not including the underflow/overflow
cells, see later), and 100 is the number of observations to be
collected before setting up the cells. 1.5 is the range extension
factor. It means that the actual range of the initial observations
will be expanded 1.5 times and this expanded range will be used to lay
out the cells. This method increases the chance that further
observations fall in one of the cells and not outside the histogram
range.

<p>
  <div align=center>
    <img src="usmanFig12.png">
    <center><i>Figure: Setting up a histogram's range</i></center>
  </div>

<p>
After the cells have been set up, collection can go on.

<p>The <tt>transformed()</tt> function returns <i>true</i> when the cells have
already been set up. You can force range estimation and setting
up the cells by calling the <tt>transform()</tt> function.

<p>The observations that fall outside the histogram range will be counted
as underflows and overflows. The number of underflows and overflows
are returned by the <tt>underflowCell()</tt> and <tt>overflowCell()</tt>
member functions.

<p>
<div align=center>
  <img src="usmanFig13.png">
  <center><i>Figure: Histogram structure after setting up the cells</i></center>
</div>

<p>
You create a <i>P<sup>2</sup></i> object by specifying the number of cells:

<pre>
<a href="../api/classcPSquare.html">cPSquare</a> psquare("interarrival-times", 20);
</pre>
<p>
Afterwards, a <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> can be used with the same member functions
as a histogram.

<p>
<p class="subheading">Getting histogram data</p>

<p>
There are three member functions to explicitly return cell boundaries
and the number of observations is each cell. <tt>cells()</tt> returns
the number of cells, <tt>basepoint(int k)</tt> returns the
<i>k</i>th base point, <tt>cell(int k)</tt> returns the
number of observations in cell <i>k</i>, and
<tt>cellPDF(int k)</tt> returns the PDF value in the cell
(i.e. between <tt>basepoint(k)</tt> and
<tt>basepoint(k+1)</tt>).  These functions work for all
histogram types, plus <tt><a href="../api/classcPSquare.html">cPSquare</a></tt> and <tt><a href="../api/classcKSplit.html">cKSplit</a></tt>.

<p>
  <div align=center>
    <img src="usmanFig14.png">
    <center><i>Figure: base points and cells</i></center>
  </div>

<p>
An example:

<pre>
long n = histogram.samples();
for (int i=0; i&lt;histogram.cells(); i++)
{
  double cellWidth = histogram.basepoint(i+1)-histogram.basepoint(i);
  int count = histogram.cell(i);
  double pdf = histogram.cellPDF(i);
  //...
}
</pre>
<p>

<p>The <tt>pdf(x)</tt> and <tt>cdf(x)</tt> member functions
return the value of the Probability Density Function and the Cumulated
Density Function at a given <i>x</i>, respectively.

<p>
<p class="subheading">Random number generation from distributions</p>

<p>
The <tt>random()</tt> member function generates random
numbers<!--random!numbers--> from the distribution stored by the
object:

<pre>
double rnd = histogram.random();
</pre>
<p>

<p><tt><a href="../api/classcStdDev.html">cStdDev</a></tt> assumes normal distribution.

<p>You can also wrap the distribution object in a <tt><a href="../api/classcPar.html">cPar</a></tt>:

<pre>
<a href="../api/classcPar.html">cPar</a> rndPar("rndPar");
rndPar.setDoubleValue(&histogram);
</pre>
<p>

<p>The <tt><a href="../api/classcPar.html">cPar</a></tt> object stores the pointer to the histogram (or <i>P<sup>2</sup></i> object),
and whenever it is asked for the value, calls the histogram object's <tt>random()</tt>
function:

<pre>
double rnd = (double)rndPar; // random number from the <a href="../api/classcPSquare.html">cPSquare</a>
</pre>
<p>
<p class="subheading">Storing/loading distributions</p>

<p>
The statistic classes have <tt>loadFromFile()</tt> member functions
that read the histogram data from a text file. If you need a custom
distribution<!--distribution!custom--> that cannot be written (or it
is inefficient) as a C function, you can describe it in histogram form
stored in a text file, and use a histogram object with
<tt>loadFromFile()</tt>.

<p>You can also use <tt>saveToFile()</tt>that writes out the distribution
collected by the histogram object:

<pre>
FILE *f = fopen("histogram.dat","w");
histogram.saveToFile(f); // save the distribution
fclose(f);

<a href="../api/classcDoubleHistogram.html">cDoubleHistogram</a> hist2("Hist-from-file");
FILE *f2 = fopen("histogram.dat","r");
hist2.loadFromFile(f2); // load stored distribution
fclose(f2);
</pre>
<p>

<p><p class="subheading">Histogram with custom cells</p>

<p>
The <tt><a href="../api/classcVarHistogram.html">cVarHistogram</a></tt> class can be used to create
histograms with arbitrary (non-equidistant) cells.
It can operate in two modes:

<p><ul>
  <li> <i>manual</i>, where you specify cell boundaries explicitly
     before starting collecting
  <li> <i>automatic</i>, where <tt>transform()</tt> will set up the cells
     after collecting a certain number of initial observations. The cells
     will be set up so that as far as possible, an equal number of observations
     fall into each cell (equi-probable cells).
</ul>

<p>Modes are selected with a <i>transform-type</i> parameter:
<ul>
  <li><tt>HIST_TR_NO_TRANSFORM</tt>: no transformation; uses bin boundaries
    previously defined by <tt>addBinBound()</tt>
  <li><tt>HIST_TR_AUTO_EPC_DBL</tt>: automatically creates equiprobable cells
  <li><tt>HIST_TR_AUTO_EPC_INT</tt>: like the above, but for integers
</ul>

<p>Creating an object:

<pre>
<a href="../api/classcVarHistogram.html">cVarHistogram</a>(const char *s=NULL,
              int numcells=11,
              int transformtype=HIST_TR_AUTO_EPC_DBL);
</pre>
<p>
Manually adding a cell boundary:

<pre>
void addBinBound(double x);
</pre>
<p>
Rangemin and rangemax is chosen after collecting the
<tt>numFirstVals</tt> initial observations. One cannot add cell
boundaries when the histogram has already been transformed.

<p>

<p>

<p><H3><A NAME="sec254"/>6.8.3 The k-split algorithm</H3>

<p><p class="subheading">Purpose</p>

<p>
The <i>k</i>-split algorithm is an on-line distribution
estimation<!--distribution!online estimation--> method.  It was
designed for on-line result collection in simulation programs.  The
method was proposed by Varga and Fakhamzadeh in 1997. The primary
advantage of <i>k</i>-split is that without having to store the
observations, it gives a good estimate without requiring a-priori
information about the distribution, including the sample size. The
<i>k</i>-split algorithm can be extended to multi-dimensional
distributions<!--distribution!multi-dimensional-->, but here we deal
with the one-dimensional version only.

<p>
<p class="subheading">The algorithm</p>

<p>
The <i>k-split</i> algorithm is an adaptive histogram-type estimate which
maintains a good partitioning by doing cell splits. We start out with
a histogram range <i>[x<sub>lo</sub>, x<sub>hi</sub>)</i> with <i>k</i> equal-sized histogram
cells with observation counts <i>n<sub>1</sub>,n<sub>2</sub>, .. n<sub>k</sub></i>.  Each collected
observation increments the corresponding observation count. When an
observation count <i>n<sub>i</sub></i> reaches a <i>split threshold</i>, the cell
is split into <i>k</i> smaller, equal-sized cells with observation counts
<i>n<sub>i,1</sub>, n<sub>i,2</sub>, .. n<sub>i,k</sub></i> initialized to zero. The <i>n<sub>i</sub></i>
observation count is remembered and is called the <i>mother
  observation count</i> to the newly created cells. Further observations
may cause cells to be split further (e.g. <i>n<sub>i,1,1</sub>,...n<sub>i,1,k</sub></i>
etc.), thus creating a <i>k</i>-order tree of observation counts where
leaves contain live counters that are actually incremented by new
observations, and intermediate nodes contain mother observation counts
for their children. If an observation falls outside the histogram
range, the range is extended in a natural manner by inserting new
level(s) at the top of the tree. The fundamental parameter to the
algorithm is the split factor <i>k</i>. Experience shows that <i>k=2</i> worked best.

<p>
  <div align=center>
    <img src="usmanFig15.png">
    <center><i>Figure: Illustration of the k-split algorithm, <i>k=2</i>. The
      numbers in boxes represent the observation count values</i></center>
  </div>

<p>

<p>For density estimation, the total number of observations that
fell into each cell of the partition has to be determined. For
this purpose, mother observations in each internal node of the
tree must be distributed among its child cells and propagated
up to the leaves.

<p>
Let <i>n<sub>...,i</sub></i> be the (mother) observation count for a cell,
<i>s<sub>...,i</sub></i> be the total observation count in a cell <i>n<sub>...,i</sub></i> plus
the observation counts in all its sub-, sub-sub-, etc. cells), and
<i>m<sub>...,i</sub></i> the mother observations propagated to the cell. We are
interested in the <i>&ntilde;<sub>...,i</sub> = n<sub>...,i</sub> + m<sub>...,i</sub></i>
estimated amount of observations in the tree nodes, especially in the
leaves. In other words, if we have <i>&ntilde;<sub>...,i</sub></i> estimated
observation amount in a cell, how to divide it to obtain
<i>m<sub>...,i,1</sub>, m<sub>...,i,2</sub> .. m<sub>...,i,k</sub></i>
that can be propagated to child cells. Naturally,
<i>m<sub>...,i,1</sub> + m<sub>...,i,2</sub> + .. + m<sub>...,i,k</sub> = &ntilde;<sub>...,i</sub></i>.

<p>
Two natural distribution methods are even
distribution<!--distribution!even--> (when
<i>m<sub>...,i,1</sub> = m<sub>...,i,2</sub> = .. = m<sub>...,i,k</sub></i>) and proportional
distribution<!--distribution!proportional--> (when
<i>m<sub>...,i,1</sub> : m<sub>...,i,2</sub> : .. : m<sub>...,i,k</sub> = s<sub>...,i,1</sub> : s<sub>...,i,2</sub> : .. : s<sub>...,i,k</sub></i>).
Even distribution is optimal when the
<i>s<sub>...,i,j</sub></i> values are very small, and proportional distribution is
good when the <i>s<sub>...,i,j</sub></i> values are large compared to
<i>m<sub>...,i,j</sub></i>. In practice, a linear combination of them seems
appropriate, where <i>&lambda;=0</i> means even and <i>&lambda;=1</i> means
proportional distribution:

<p>
<i>m<sub>..,i,j</sub> = (1-&lambda;)&ntilde;<sub>..,i</sub>/k + &lambda; &ntilde;<sub>..,i</sub> s<sub>...,i,j</sub> / s<sub>..,i</sub></i>
where <i>&lambda; is in [0,1]</i>

<p>
  <div align=center>
    <img src="usmanFig16.png">
    <center><i>Figure: Density estimation from the k-split cell tree. We
      assume <i>&lambda;=0</i>, i.e. we distribute mother observations
      evenly.</i></center>
  </div>

<p>

Note that while <i>n<sub>...,i</sub></i> are integers, <i>m<sub>...,i</sub></i> and thus
<i>&ntilde;<sub>...,i</sub></i> are typically real numbers. The histogram estimate
calculated from <i>k</i>-split is not exact, because the frequency
counts calculated in the above manner contain a degree of estimation
themselves. This introduces a certain <i>cell division error</i>;
the <i>&lambda;</i> parameter should be selected so that it minimizes that
error. It has been shown that the cell division error can
be reduced to a more-than-acceptable small value.<br>
Strictly speaking, the <i>k</i>-split algorithm is semi-online,
because its needs some observations to set up the initial histogram
range.  Because of the range extension and cell split
capabilities, the algorithm is not very sensitive to the choice of the
initial range, so very few observations are sufficient for range
estimation (say <i>N<sub>pre</sub>=10</i>). Thus we can regard <i>k</i>-split as
an on-line method.

<p><i>K</i>-split can also be used in semi-online mode, when the
algorithm is only used to create an optimal partition from a larger
number of <i>N<sub>pre</sub></i> observations. When the partition has been created,
the observation counts are cleared and the <i>N<sub>pre</sub></i> observations are
fed into <i>k</i>-split once again. This way all mother (non-leaf)
observation counts will be zero and the cell division error is
eliminated. It has been shown that the partition created by
<i>k</i>-split can be better than both the equi-distant and the
equal-frequency partition.

<p>
OMNeT++ contains an experimental implementation of the <i>k</i>-split
algorithm, the <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> class. Research on <i>k</i>-split is
still under way.

<p>
<p class="subheading">The <a href="../api/classcKSplit.html">cKSplit</a> class</p>

<p>The <tt><a href="../api/classcKSplit.html">cKSplit</a></tt> class is an implementation of the <i>k-split</i> method.
Member functions:


<pre>
void setCritFunc(KSplitCritFunc _critfunc, double *_critdata);
void setDivFunc(KSplitDivFunc \_divfunc, double *\_divdata);
void rangeExtension( bool enabled );
</pre>
<p>

<pre>
int treeDepth();
int treeDepth(sGrid& grid);
</pre>
<p>
<pre>
double realCellValue(sGrid& grid, int cell);
void printGrids();
</pre>

<pre>
sGrid& grid(int k);
sGrid& rootGrid();
</pre>
<p>
<pre>
struct sGrid
{
  int parent;   // index of parent grid
  int reldepth; // depth = (reldepth - rootgrid's reldepth)
  long total;   // sum of cells & all subgrids (includes `mother')
  int mother;   // observations `inherited' from mother cell
  int cells[K]; // cell values
};
</pre>

<p>

<p><H3><A NAME="sec255"/>6.8.4 Transient detection and result accuracy</H3>

<p>In many simulations, only the steady state performance (i.e.
the performance after the system has reached a stable state)
is of interest. The initial part of the simulation is called
the transient period. After the model has entered steady state,
simulation must proceed until enough statistical data has been
collected to compute result with the required accuracy.

<p>
Detection of the end of the transient period and a certain result
accuracy is supported by OMNeT++. The user can attach transient
detection<!--transient detection--> and result accuracy<!--result
  accuracy--> objects to a result object (<tt><a href="../api/classcStatistic.html">cStatistic</a></tt>'s
descendants). The transient detection and result accuracy objects will
do the specific algorithms on the data fed into the result object and
tell if the transient period is over or the result accuracy has been
reached.

<p>The base classes for classes implementing specific transient
detection and result accuracy detection algorithms are:
<ul>
<li><tt><a href="../api/classcTransientDetection.html">cTransientDetection</a></tt>: base class for transient detection
<li><tt><a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a></tt>: base class for result accuracy detection
</ul>

<p>
<p class="subheading">Basic usage</p>


Attaching detection objects to a <tt><a href="../api/classcStatistic.html">cStatistic</a></tt> and getting pointers
to the attached objects:

<pre>
addTransientDetection(<a href="../api/classcTransientDetection.html">cTransientDetection</a> *object);
addAccuracyDetection(<a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a> *object);
<a href="../api/classcTransientDetection.html">cTransientDetection</a> *transientDetectionObject();
<a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a> *accuracyDetectionObject();
</pre>
<p>

<p>Detecting the end of the period:
<ul>
<li>polling the <tt>detect()</tt> function of the object
<li>installing a post-detect function
</ul>

<p>
<p class="subheading">Transient detection</p>

<p>
Currently one transient detection<!--transient detection--> algorithm
is implemented, i.e.  there's one class derived from
<tt><a href="../api/classcTransientDetection.html">cTransientDetection</a></tt>. The <tt><a href="../api/classcTDExpandingWindows.html">cTDExpandingWindows</a></tt> class
uses the sliding window approach with two windows, and checks the
difference of the two averages to see if the transient period is over.

<pre>
void setParameters(int reps=3,
                   int minw=4,
                   double wind=1.3,
                   double acc=0.3);
</pre>
<p>
<p class="subheading">Accuracy detection</p>

<p>
Currently one accuracy detection<!--accuracy detection--> algorithm
is implemented, i.e.  there's one class derived from
<tt><a href="../api/classcAccuracyDetection.html">cAccuracyDetection</a></tt>. The algorithm implemented in the
<tt><a href="../api/classcADByStddev.html">cADByStddev</a></tt> class is: divide the standard deviation by the
square of the number of values and check if this is small enough.

<pre>
void setParameters(double acc=0.1, int reps=3);
</pre>
<p>

<p>

<p><H2><A NAME="sec256"/>6.9 Recording simulation results</H2>

<p><H3><A NAME="sec257"/>6.9.1 Output vectors: <a href="../api/classcOutVector.html">cOutVector</a></H3>
<a name="sec:ch-sim-lib:coutvector"></a>

<p>Objects of type <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> are responsible for writing time series
data (referred to as <i>output vectors</i>) to a file. The <tt>record()</tt>
method is used to output a value (or a value pair) with a timestamp.
The object name will serve as the name of the output vector.

<p>The vector name can be passed in the constructor,

<pre>
<a href="../api/classcOutVector.html">cOutVector</a> responseTimeVec("response time");
</pre>
<p>
but in the usual arrangement you'd make the <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> a member
of the module class and set the name in <tt>initialize()</tt>. You'd
record values from <tt>handleMessage()</tt> or from a function called from
<tt>handleMessage()</tt>.

<p>The following example is a <tt>Sink</tt> module which records the lifetime
of every message that arrives to it.

<pre>
class Sink : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classcOutVector.html">cOutVector</a> endToEndDelayVec;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
};

Define_Module(Sink);

void Sink::initialize()
{
    endToEndDelayVec.setName("End-to-End Delay");
}

void Sink::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    simtime_t eed = simTime() - msg-&gt;creationTime();
    endToEndDelayVec.record(eed);
    delete msg;
}
</pre>
<p>
There is also a <tt>recordWithTimestamp()</tt> method, to make it
possible to record values into output vectors with a timestamp other than
<tt>simTime()</tt>. Increasing timestamp order is still enforced though.

<p>All <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects write to a single <i>output vector file</i>
named <tt>omnetpp.vec</tt> by default.
You can configure output vectors from <tt>omnetpp.ini</tt>:
you can disable writing to the file, or limit it to a certain
simulation time interval for recording (section
<a href="#sec310">[8.8]</a>).

<p>The format and processing of output vector files is described in section
<a href="#sec356">[10.1]</a>.

<p>If the output vector object is disabled or the simulation time is
outside the specified interval, <tt>record()</tt> doesn't write
anything to the output file. However, if you have a Tkenv inspector
window open for the output vector object<!--output!vector object-->,
the values will be displayed there, regardless of the state of the
output vector object.

<p>

<p><H3><A NAME="sec258"/>6.9.2 Output scalars</H3>

<p>While output vectors are to record time series data and thus they
typically record a large volume of data during a simulation run,
output scalars<!--output!scalars--> are supposed to record a single
value per simulation run. You can use output scalars

<p><ul>
<li>to record summary data at the end of the simulation run
<li>to do several runs with different parameter settings/random seed
    and determine the dependence of some measures on the parameter
    settings. For example, multiple runs and output scalars are the
    way to produce <i>Throughput vs. Offered Load</i> plots.
</ul>

<p>Output scalars are recorded with the <tt>recordScalar()</tt> method of
<tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt>, and you'll usually want to insert this code
into the <tt>finish()</tt> function. An example:

<pre>
void Transmitter::finish()
{
    double avgThroughput = totalBits / simTime();
    recordScalar("Average throughput", avgThroughput);
}
</pre>
<p>
You can record whole statistics objects by calling their <tt>recordScalar()</tt>
methods, declared as part of <tt><a href="../api/classcStatistic.html">cStatistic</a></tt>. In the following example
we create a <tt>Sink</tt> module which calculates the mean, standard
deviation, minimum and maximum values of a variable, and records them at the
end of the simulation.

<pre>
class Sink : public <a href="../api/classcSimpleModule.html">cSimpleModule</a>
{
  protected:
    <a href="../api/classcStdDev.html">cStdDev</a> eedStats;

    virtual void initialize();
    virtual void handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg);
    virtual void finish();
};

Define_Module(Sink);

void Sink::initialize()
{
    eedStats.setName("End-to-End Delay");
}

void Sink::handleMessage(<a href="../api/classcMessage.html">cMessage</a> *msg)
{
    simtime_t eed = simTime() - msg-&gt;creationTime();
    eedStats.collect(eed);
    delete msg;
}

void Sink::finish()
{
    recordScalar("Simulation duration", simTime());
    eedStats.recordScalar();
}
</pre>
<p>
The above calls write into the <i>output scalar file</i> which is named
<tt>omnetpp.sca</tt> by default. The output scalar file is preserved across
simulation runs (unlike the output vector file which gets deleted
at the beginning of every simulation run).
Data are always appended at the end of the file, and
output from different simulation runs are separated by special lines.
The format and processing of output vector files is described in section
<a href="#sec360">[10.2]</a>.

<p>
<H3><A NAME="sec259"/>6.9.3 Precision</H3>
<a name="sec:outputfile-precision"></a>

<p>Output scalar and output vector files are text files, and floating point
values (<tt>double</tt>s) are recorded into it using <tt>fprintf()</tt>'s
<tt>"%g"</tt> format.
The number of significant digits can be configured using the
<tt>output-scalar-precision=</tt> and <tt>output-vector-precision=</tt>
configuration entries (see <a href="#"></a>).
The default precision is 12 digits. The following has to be considered
when changing the default value:

<p>IEEE-754 doubles are 64-bit numbers. The mantissa is 52 bits, which
is roughly equivalent to 16 decimal places (52*log(2)/log(10)).
However, due to rounding errors, usually only
12..14 digits are correct, and the rest is pretty much random garbage
which should be ignored. However, when you convert the decimal
representation back into an IEEE-754 double (as in Plove and Scalars),
an additional small error will occurs because 0.1, 0.01, etc cannot be
accurately represented in binary. This conversion error is usually
smaller than the one that the <tt>double</tt>
variable already had before recording into the file, however if
it is important you can eliminate it by setting &gt;16 digits precision
for the file (but again, be aware that the last digits are garbage).
The practical upper limit is 17 digits, setting it higher
doesn't make any difference in <tt>fprintf()</tt>'s output.



<p>Errors coming from converting to/from decimal representation can be
eliminated by choosing an output vector/output scalar manager class
which stores <tt>double</tt>s in their native binary form.
The appropriate configuration entries are <tt>outputvectormanager-class=</tt>
and <tt>outputvectormanager-class=</tt>; see <a href="#"></a>.
For example, <tt>cMySQLOutputScalarManager</tt> and <tt>cMySQLOutputScalarManager</tt>
provided in <tt>samples/database</tt> fulfill this requirement.

<p>However, before worrying too much about rounding and conversion errors,
it is worth considering what is the <i>real</i> accuracy of your results.
Some things to consider:

<p><ul>
  <li>in real life, it is very hard to measure quantities (weight, distance,
     even time) with more than a few digits of precision. What precision
     are your input data? For example, if you approximate inter-arrival
     time as <i>exponential(0.153)</i> when the mean is really
     <i>0.152601...</i> and the distribution is not even exactly exponential,
     you are already starting out with a bigger error than rounding can cause.

<p>  <li>the simulation model is itself an approximation of real life. How much
     error do the (known and unknown) simplifications cause in the results?
</ul>

<p>

<p>
<H2><A NAME="sec260"/>6.10 Watches and snapshots</H2>

<p><H3><A NAME="sec261"/>6.10.1 Basic watches</H3>

<p>It would be nice, but variables of type <tt>int</tt>, <tt>long</tt>, <tt>double</tt>
do not show up by default in Tkenv; neither do STL classes
(<tt>std::string</tt>, <tt>std::vector</tt>, etc.) or your own structs and
classes. This is because the simulation kernel, being a library, knows
nothing about types and variables in your source code.

<p>OMNeT++ provides <tt>WATCH()</tt> and set of other macros to come to your rescue,
and make variable to be inspectable in Tkenv and to be output into the snapshot
file<!--snapshot file-->. <tt>WATCH()</tt> macros are usually placed into
<tt>initialize()</tt> (to watch instance variables) or to the top of the
<tt>activity()</tt> function (to watch its local variables), the point being
that they should only be executed once.

<pre>
long packetsSent;
double idleTime;

WATCH(packetsSent);
WATCH(idleTime);
</pre>
<p>
Of course, members of classes and structs can also be watched:

<pre>
WATCH(config.maxRetries);
</pre>
<p>
When you open an inspector for the simple module in Tkenv and click
the Objects/Watches tab in it, you'll see your watched variables
and their values there. Tkenv also lets you change the value of a
watched variable.

<p>The <tt>WATCH()</tt> macro can be used with any type that has a
stream output operator (<tt>operator&lt;&lt;</tt>) defined. By default,
this includes all primitive types and <tt>std::string</tt>, but since
you can write <tt>operator&lt;&lt;</tt> for your classes/structs and basically
any type, <tt>WATCH()</tt> can be used with anything. The only limitation
is that since the output should more or less fit on single line, the
amount of information that can be conveniently displayed is limited.

<p>An example stream output operator:

<pre>
std::ostream& operator&lt;&lt;(std::ostream& os, const ClientInfo& cli)
{
    os &lt;&lt; "addr=" &lt;&lt; cli.clientAddr &lt;&lt; "  port=" &lt;&lt; cli.clientPort; // no endl!
    return os;
}
</pre>
<p>
And the <tt>WATCH()</tt> line:

<pre>
WATCH(currentClientInfo);
</pre>
<p>

<p><H3><A NAME="sec262"/>6.10.2 Read-write watches</H3>

<p>Watches for primitive types and <tt>std::string</tt> allow for changing
the value from the GUI as well, but for other types you need to explicitly
add support for that. What you need to do is define a stream input
operator (<tt>operator&gt;&gt;</tt>) and use the <tt>WATCH_RW()</tt> macro instead of
<tt>WATCH()</tt>.

<p>The stream input operator:

<pre>
std::ostream& operator&gt;&gt;(std::istream& is, ClientInfo& cli)
{
    // read a line from "is" and parse its contents into "cli"
    return is;
}
</pre>
<p>
And the <tt>WATCH_RW()</tt> line:

<pre>
WATCH_RW(currentClientInfo);
</pre>
<p>

<p><H3><A NAME="sec263"/>6.10.3 Structured watches</H3>

<p><tt>WATCH()</tt> and <tt>WATCH_RW()</tt> are basic watches: they allow one
line of (unstructured) text to be displayed. However, if you have a
data structure generated from message definitions (see Chapter <a href="#sec205">[5]</a>),
then one can do better. The message compiler automatically generates
meta-information describing individual fields of the class or struct,
which makes it possible to display the contents on field level.

<p>The <tt>WATCH</tt> macros to be used for this purpose are <tt>WATCH_OBJ()</tt>
and <tt>WATCH_PTR()</tt>. Both expect the object to be subclassed from
<tt><a href="../api/classcObject.html">cObject</a></tt>; <tt>WATCH_OBJ()</tt> expects a reference to such class,
and <tt>WATCH_PTR()</tt> expects a pointer variable.

<pre>
ExtensionHeader hdr;
ExtensionHeader *hdrPtr;
...
WATCH_OBJ(hdr);
WATCH_PTR(hdrPtr);
</pre>
<p>
CAUTION: With <tt>WATCH_PTR()</tt>, the pointer variable must point to a valid
object or be <tt>NULL</tt> at all times, otherwise the GUI may crash
while trying to display the object. This practically means that
the pointer should be initialized to <tt>NULL</tt> even if not used, and
should be set to <tt>NULL</tt> when the object to which it points gets deleted.

<pre>
delete watchedPtr;
watchedPtr = NULL;  // set to NULL when object gets deleted
</pre>
<p>

<p><H3><A NAME="sec264"/>6.10.4 STL watches</H3>

<p>The standard C++ container classes (<tt>vector</tt>, <tt>map</tt>, <tt>set</tt>, etc)
also have structured watches, available via the following macros:

<p><tt>WATCH_VECTOR()</tt>, <tt>WATCH_PTRVECTOR()</tt>,
<tt>WATCH_LIST()</tt>, <tt>WATCH_PTRLIST()</tt>,
<tt>WATCH_SET()</tt>, <tt>WATCH_PTRSET()</tt>,
<tt>WATCH_MAP()</tt>, <tt>WATCH_PTRMAP()</tt>.

<p>The <tt>PTR</tt>-less versions expect the data items ("T") to have
stream output operators (<tt>operator &lt;&lt;</tt>), because that's how
they will display them. The <tt>PTR</tt> versions assume that
data items are pointers to some type which has <tt>operator &lt;&lt;</tt>.
<tt>WATCH_PTRMAP()</tt> assumes that only the value type (``second'')
is a pointer, the key type (``first'') is not. (If you happen to use
pointers as key, then define <tt>operator &lt;&lt;</tt> for the pointer type
itself.)

<p>Examples:

<pre>
std::vector&lt;int&gt; intvec;
WATCH_VECTOR(intvec);

std::map&lt;std::string,Command*&gt; commandMap;
WATCH_PTRMAP(commandMap);
</pre>
<p>

<p>
<H3><A NAME="sec265"/>6.10.5 Snapshots</H3>
<a name="sec:ch-sim-lib:snapshots"></a>

<p>The <tt>snapshot()</tt> function outputs textual information about all
or selected objects of the simulation (including the objects created
in module functions by the user) into the snapshot file<!--snapshot file-->.

<pre>
bool snapshot(<a href="../api/classcOwnedObject.html">cOwnedObject</a> *obj = &simulation, const char *label = NULL);
</pre>
<p>

<p>The function can be called from module functions, like this:

<pre>
snapshot();     // dump the whole network
snapshot(this); // dump this simple module and all its objects
snapshot(&simulation.msgQueue); // dump future events
</pre>
<p>
This will append snapshot information to the end of the snapshot file.
(The snapshot file name has an extension of <tt>.sna</tt>, default is
<tt>omnetpp.sna</tt><!--omnetpp.sna-->. Actual file name can be set in the
config file.)

<p>
The snapshot file output is detailed enough to be used for debugging
the simulation: by regularly calling <tt>snapshot()</tt>, one can trace
how the values of variables, objects changed over the simulation.
The arguments: label is a string that will appear in the output
file; obj is the object whose inside is of interest. By default,
the whole simulation (all modules etc) will be written out.

<p>If you run the simulation with Tkenv, you can also create a snapshot
from the menu.

<p>
An example of a snapshot file:

<p><pre>
[...]

(<a href="../api/classcSimulation.html">cSimulation</a>) `simulation' begin
  Modules in the network:
    `token' #1 (TokenRing)
      `comp[0]' #2 (Computer)
        `mac' #3 (TokenRingMAC)
        `gen' #4 (Generator)
        `sink' #5 (Sink)
      `comp[1]' #6 (Computer)
        `mac' #7 (TokenRingMAC)
        `gen' #8 (Generator)
        `sink' #9 (Sink)
      `comp[2]' #10 (Computer)
        `mac' #11 (TokenRingMAC)
        `gen' #12 (Generator)
        `sink' #13 (Sink)
end

(TokenRing) `token' begin
  #1 params     (<a href="../api/classcArray.html">cArray</a>) (n=6)
  #1 gates      (<a href="../api/classcArray.html">cArray</a>) (empty)
  comp[0]          (<a href="../api/classcCompoundModule.html">cCompoundModule</a>,#2)
  comp[1]          (<a href="../api/classcCompoundModule.html">cCompoundModule</a>,#6)
  comp[2]          (<a href="../api/classcCompoundModule.html">cCompoundModule</a>,#10)
end

(<a href="../api/classcArray.html">cArray</a>) `token.parameters' begin
  num_stations (cModulePar) 3 (L)
  num_messages (cModulePar) 10000 (L)
  ia_time      (cModulePar) truncnormal(0.005,0.003) (F)
  THT          (cModulePar) 0.01 (D)
  data_rate    (cModulePar) 4000000 (L)
  cable_delay  (cModulePar) 1e-06 (D)
end

[...]

(<a href="../api/classcQueue.html">cQueue</a>) `token.comp[0].mac.local-objects.send-queue' begin
  0--&gt;1         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0158105774 ( 15ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0163553310 ( 16ms) Src=#4 Dest=#3
  0--&gt;1         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0205628236 ( 20ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0242203591 ( 24ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0300994268 ( 30ms) Src=#4 Dest=#3
  0--&gt;1         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0364005251 ( 36ms) Src=#4 Dest=#3
  0--&gt;1         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0370745702 ( 37ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0387984129 ( 38ms) Src=#4 Dest=#3
  0--&gt;1         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0457462493 ( 45ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0487308918 ( 48ms) Src=#4 Dest=#3
  0--&gt;2         (<a href="../api/classcMessage.html">cMessage</a>) Tarr=0.0514466766 ( 51ms) Src=#4 Dest=#3
end

(<a href="../api/classcMessage.html">cMessage</a>) `token.comp[0].mac.local-objects.send-queue.0--&gt;1' begin
  #4 --&gt; #3
  sent:         0.0158105774 ( 15ms)
  arrived:      0.0158105774 ( 15ms)
  length:       33536
  kind:         0
  priority:     0
  error:        FALSE
  time stamp:   0.0000000 ( 0.00s)
  parameter list:
    dest        (<a href="../api/classcPar.html">cPar</a>) 1 (L)
    source      (<a href="../api/classcPar.html">cPar</a>) 0 (L)
    gentime     (<a href="../api/classcPar.html">cPar</a>) 0.0158106 (D)
end

[...]
</pre>

<p>It is possible that the format of the snapshot file will change to XML
in future OMNeT++ releases.

<p>

<p><H3><A NAME="sec266"/>6.10.6 Breakpoints</H3>

<p><b>With activity() only!</b> In those user interfaces which support
debugging, breakpoints stop execution and the state of the simulation
can be examined.

<p>You can set a breakpoint<!--breakpoint--> inserting a
<tt>breakpoint()</tt> call into the source:

<pre>
for(;;)
{
    <a href="../api/classcMessage.html">cMessage</a> *msg = receive();
    breakpoint("before-processing");
    breakpoint("before-send");
    send( reply_msg, "out" );
    //..
}
</pre>
<p>

<p>In user interfaces that do not support debugging, <tt>breakpoint()</tt>
calls are simply ignored.

<p>

<p>



<p>

<p>
<H3><A NAME="sec267"/>6.10.7 Getting coroutine stack usage</H3>

<p>It is important to choose the correct stack size for
modules<!--module!stack size--><!--stack!size-->.  If the stack is
too large, it unnecessarily consumes memory; if it is too small, stack
violation occurs.

<p>From the Feb99 release, OMNeT++ contains a mechanism that detects stack
overflows<!--stack!overflow-->. It checks the intactness of a
predefined byte pattern (<tt>0xdeadbeef</tt>) at the stack boundary,
and reports ``stack violation''<!--stack!violation--> if it was
overwritten. The mechanism usually works fine, but occasionally it can
be fooled by large -- and not fully used -- local variables (e.g. char
buffer[256]): if the byte pattern happens to fall in the middle of
such a local variable, it may be preserved intact and OMNeT++ does not
detect the stack violation.

<p>To be able to make a good guess about stack size, you can use
the <tt>stackUsage()</tt> call which tells you how much stack the module
actually uses. It is most conveniently called from <tt>finish()</tt>:

<pre>
void FooModule::finish()
{
  ev &lt;&lt; stackUsage() &lt;&lt;  "bytes of stack used\n";
}
</pre>
<p>

<p>The value includes the extra stack added by the user interface library
(see <i>extraStackforEnvir</i><!--extraStackforEnvir--> in
envir/omnetapp.h), which is currently 8K for Cmdenv and at least 16K
for Tkenv.
  <br><ul><font size=-1>[The actual value is platform-dependent.]</font></ul>

<p><tt>stackUsage()</tt>also works by checking the existence of predefined
byte patterns in the stack area, so it is also subject to the above
effect with local variables.

<p>

<p><H2><A NAME="sec268"/>6.11 Deriving new classes</H2>
<a name="sec:ch-sim-lib:deriving-new-classes"></a>

<p><H3><A NAME="sec269"/>6.11.1 <a href="../api/classcOwnedObject.html">cOwnedObject</a> or not?</H3>

<p>If you plan to implement a completely new class (as opposed to
subclassing something already present in OMNeT++), you have
to ask yourself whether you want the new class to be based
on <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> or not.
Note that we are <i>not</i> saying you should always
subclass from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>.
Both solutions have advantages and disadvantages, which you
have to consider individually for each class.

<p><tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> already carries (or provides a framework for)
significant functionality that is either relevant to
your particular purpose or not. Subclassing <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
generally means you have more code to write (as you <i>have to</i>
redefine certain virtual functions and adhere to conventions)
and your class will be a bit more heavy-weight.
However, if you need to store your objects in OMNeT++ objects like <tt><a href="../api/classcQueue.html">cQueue</a></tt>,
or you'll want to store OMNeT++ classes in your object,
then you <i>must</i> subclass from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>.
  <br><ul><font size=-1>[For simplicity, in the these sections ``OMNeT++ object''
  should be understood as ``object of a class subclassed from
  <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>'']</font></ul>

<p>The most significant features <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> has is
the name string (which has to be stored somewhere, so it has
its overhead) and ownership management (see section
<a href="#sec273">[6.12]</a>) which
also has the advantages but also some costs.

<p>As a general rule, small <tt>struct</tt>-like classes like <tt>IPAddress</tt>,
<tt>MACAddress</tt>, <tt>RoutingTableEntry</tt>, <tt>TCPConnectionDescriptor</tt>, etc.
are better <i>not</i> sublassed from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>.
If your class has at least one virtual member function, consider
subclassing from <tt><a href="../api/classcObject.html">cObject</a></tt>, which does not impose any
extra cost because it doesn't have data members at all, only
virtual functions.

<p>
<H3><A NAME="sec270"/>6.11.2 <a href="../api/classcOwnedObject.html">cOwnedObject</a> virtual methods</H3>

<p>Most classes in the simulation class library are descendants of
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>. If you want to derive a new class from
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> or a <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> descendant, you must redefine
some member functions so that objects of the new type can fully
co-operate with other parts of the simulation system. A more or less
complete list of these functions is presented here. You do not need to
worry about the length of the list: most functions are not
absolutely necessary to implement. For example, you do not need to
redefine <tt>forEachChild()</tt> unless your class is a container class.

<p>The following methods <b>must</b> be implemented:

<p><ul>
  <li><i>Constructor</i>. At least two constructors should be provided:
        one that takes the object name string as <tt>const char *</tt>
        (recommended by convention), and another one with no arguments
        (must be present). The two are usually implemented as a single
        method, with <tt>NULL</tt> as default name string.
  <li><i>Copy constructor</i>, which must have the following signature
        for a class <tt>X</tt>: <tt>X(const X&amp;)</tt>. The copy constructor is used
        whenever an object is duplicated. The usual implementation of
        the copy constructor is to initialize the base class with the
        name (<tt>name()</tt>) of the other object it receives, then call the
        assignment operator (see below).
  <li><i>Destructor</i>.
  <li><i>Duplication function,</i> <tt><a href="../api/classcObject.html">cObject</a> *dup() const</tt>.
        It should create and return an exact duplicate of the object.
        It is usually a one-line function, implemented with the help
        of the <tt>new</tt> operator and the copy constructor.
  <li><i>Assigment operator</i>, that is, <tt>X&amp; operator=(const X&amp;)</tt>
        for a class <tt>X</tt>. It should copy the contents of the other
        object into this one, except the name string. See later what to do
        if the object contains pointers to other objects.
</ul>

<p>If your class contains other objects subclassed from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>,
either via pointers or as data member, the following function <b>should</b>
be implemented:

<p><ul>
  <li><i>Iteration function,</i> <tt>void forEachChild(<a href="../api/classcVisitor.html">cVisitor</a> * v)</tt>.
        The implementation should call the function passed
        for each object it contains via pointer or as data member;
        see the API Reference on <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> on how to implement
        <tt>forEachChild()</tt>. <tt>forEachChild()</tt> makes it possible
        for Tkenv to display the object tree to you, to perform searches on it, etc.
        It is also used by <tt>snapshot()</tt> and some other library functions.
</ul>

<p>The following methods are <b>recommended</b> to implement:

<p><ul>
  <li><i>Object info,</i> <tt>std::string info()</tt>. The <tt>info()</tt> function
        should return a one-line string describing the object's contents or state.
        <tt>info()</tt> is displayed at several places in Tkenv.
  <li><i>Detailed object info,</i> <tt>std::string detailedInfo()</tt>.
        This method may potentially be implemented in addition to <tt>info()</tt>;
        it can return a multi-line description. <tt>detailedInfo()</tt> is also
        displayed by Tkenv in the object's inspector.
  <li><i>Serialization</i>, <tt>netPack()</tt> and <tt>netUnpack()</tt> methods.
        These methods are needed for parallel simulation, if you want
        objects of this type to be transmitted across partitions.
</ul>

<p>
<H3><A NAME="sec271"/>6.11.3 Class registration</H3>

<p>You should also use the <tt>Register_Class()</tt> macro to register the
new class. It is used by the <tt>createOne()</tt> factory function, which can
create any object given the class name as a string. <tt>createOne()</tt>
is used by the Envir library to implement <tt>omnetpp.ini</tt> options
such as <tt>rng-class="..."</tt> or <tt>scheduler-class="..."</tt>.
(see Chapter <a href="#sec401">[14]</a>)

<p>For example, an omnetpp.ini entry such as

<pre>
rng-class="<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>"
</pre>
<p>
would result in something like the following code to be executed
for creating the RNG objects:

<pre>
<a href="../api/classcRNG.html">cRNG</a> *rng = check_and_cast&lt;<a href="../api/classcRNG.html">cRNG</a>*&gt;(createOne("<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>"));
</pre>
<p>
But for that to work, we needed to have the following line somewhere in the code:

<pre>
Register_Class(<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>);
</pre>
<p>
<tt>createOne()</tt> is also needed by the parallel distributed simulation feature
(Chapter <a href="#sec392">[13]</a>) to create blank objects to unmarshal into
on the receiving side.

<p>
<H3><A NAME="sec272"/>6.11.4 Details</H3>

<p>We'll go through the details using an example. We create a new
class <tt>NewClass</tt>, redefine all above mentioned <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
member functions, and explain the conventions, rules and tips
associated with them.
To demonstrate as much as possible, the class will contain
an <tt>int</tt> data member, dynamically allocated non-<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt> data
(an array of <tt>double</tt>s),
an OMNeT++ object as data member (a <tt><a href="../api/classcQueue.html">cQueue</a></tt>), and
a dynamically allocated OMNeT++ object (a <tt><a href="../api/classcMessage.html">cMessage</a></tt>).

<p>The class declaration is the following. It contains the declarations
of all methods discussed in the previous section.

<pre>
//
// file: NewClass.h
//
#include &lt;omnetpp.h&gt;

class NewClass : public <a href="../api/classcOwnedObject.html">cOwnedObject</a>
{
  protected:
    int data;
    double *array;
    <a href="../api/classcQueue.html">cQueue</a> queue;
    <a href="../api/classcMessage.html">cMessage</a> *msg;
    ...
  public:
    NewClass(const char *name=NULL, int d=0);
    NewClass(const NewClass& other);
    virtual ~NewClass();
    virtual <a href="../api/classcObject.html">cObject</a> *dup() const;
    NewClass& operator=(const NewClass& other);

    virtual void forEachChild(<a href="../api/classcVisitor.html">cVisitor</a> *v);
    virtual std::string info();
};
</pre>
<p>
We'll discuss the implementation method by method.
Here's the top of the <tt>.cc</tt> file:

<pre>
//
// file: NewClass.cc
//
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream.h&gt;
#include "newclass.h"

Register_Class( NewClass );


NewClass::NewClass(const char *name, int d) : <a href="../api/classcOwnedObject.html">cOwnedObject</a>(name)
{
    data = d;
    array = new double[10];
    take(&queue);
    msg = NULL;
}
</pre>
<p>
The constructor (above) calls the base class constructor with
the name of the object, then initializes its own data members.
You need to call <tt>take()</tt> for <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based data members.

<p>
<pre>
NewClass::NewClass(const NewClass& other) : <a href="../api/classcOwnedObject.html">cOwnedObject</a>(other.name())
{
    array = new double[10];
    msg = NULL;
    take(&queue);
    operator=(other);
}
</pre>

<p>The copy constructor relies on the assignment operator. Because
by convention the assignment operator does not copy the
name member, it is passed here to the base class constructor.
(Alternatively, we could have written <tt>setName(other.name())</tt>
into the function body.)

<p>Note that pointer members have to be initialized (to <tt>NULL</tt> or to an
allocated object/memory) before calling the assignment operator,
to avoid crashes.

<p>You need to call <tt>take()</tt> for <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based data members.

<pre>
NewClass::~NewClass()
{
    delete [] array;
    if (msg-&gt;owner()==this)
        delete msg;
}
</pre>
<p>
The destructor should delete all data structures the object allocated.
<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based objects should <i>only</i> be deleted if they
are owned by the object -- details will be covered in section
<a href="#sec273">[6.12]</a>.

<pre>
<a href="../api/classcObject.html">cObject</a> *NewClass::dup() const
{
    return new NewClass(*this);
}
</pre>
<p>
The <tt>dup()</tt> functions is usually just one line, like the one above.

<pre>
NewClass& NewClass::operator=(const NewClass& other)
{
    if (&other==this)
        return *this;
    <a href="../api/classcOwnedObject.html">cOwnedObject</a>::operator=(other);

    data = other.data;

    for (int i=0; i&lt;10; i++)
        array[i] = other.array[i];

    queue = other.queue;
    queue.setName(other.queue.name());

    if (msg && msg-&gt;owner()==this)
        delete msg;
    if (other.msg && other.msg-&gt;owner()==const_cast&lt;<a href="../api/classcMessage.html">cMessage</a>*&gt;(&other))
        take(msg = (<a href="../api/classcMessage.html">cMessage</a> *)other.msg-&gt;dup());
    else
        msg = other.msg;
    return *this;
}
</pre>
<p>
Complexity associated with copying and duplicating the object
is concentrated in the assignment operator, so it is usually
the one that requires the most work from you of all methods
required by <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>.

<p>If you do not want to implement object copying and duplication,
you should implement the assigment operator to call
<tt>copyNotSupported()</tt> -- it'll throw an exception that
stops the simulation with an error message if this function
is called.

<p>The assignment operator copies contents of the <tt>other</tt> object
to this one, except the name string. It should always return
<tt>*this</tt>.

<p>First, we should make sure we're not trying to copy the object
to itself, because it might be disastrous. If so (that is,
<tt>&amp;other==this</tt>), we return immediately without doing anything.

<p>The base class part is copied via invoking the assignment operator of
the base class.

<p>New data members are copied in the normal C++ way. If the class
contains pointers, you'll most probably want to make a deep copy of
the data where they point, and not just copy the pointer values.

<p>If the class contains pointers to OMNeT++ objects, you need
to take ownership into account. If the contained object is <i>not owned</i>
then we assume it is a pointer to an ``external'' object, consequently
we only copy the pointer. If it is <i>owned</i>, we duplicate
it and become the owner of the new object. Details of ownership
management will be covered in section <a href="#sec273">[6.12]</a>.

<p>
<pre>
void NewClass::forEachChild(<a href="../api/classcVisitor.html">cVisitor</a> *v)
{
    v-&gt;visit(queue);
    if (msg)
        v-&gt;visit(msg);
}
</pre>

<p>The <tt>forEachChild()</tt> function should call <tt>v-&gt;visit(obj)</tt>
for each <tt>obj</tt> member of the class. See the API Reference for more
information of <tt>forEachChild()</tt>.

<pre>
std::string NewClass::info()
{
    std::stringstream out;
    out &lt;&lt; "data=" &lt;&lt; data &lt;&lt; ", array[0]=" &lt;&lt; array[0];
    return out.str();

}
</pre>
<p>
The <tt>info()</tt> method should produce a concise, one-line string
about the object. You should try not to exceed 40-80 characters, since the
string will be shown in tooltips and listboxes.

<p>See the virtual functions of <tt><a href="../api/classcObject.html">cObject</a></tt> and <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>
in the class library reference for more information. The sources of the
Sim library (<tt>include/</tt>, <tt>src/sim/</tt>) can serve as further examples.

<p>

<p><H2><A NAME="sec273"/>6.12 Object ownership management</H2>
<a name="sec:ch-sim-lib:ownership-management"></a>

<p><H3><A NAME="sec274"/>6.12.1 The ownership tree</H3>

<p>OMNeT++ has a built-in ownership management mechanism which
is used for sanity checks, and as part of the infrastructure
supporting Tkenv inspectors.

<p>Container classes like <tt><a href="../api/classcQueue.html">cQueue</a></tt> own the objects inserted
into them. But this is not limited to objects inserted into a container:
<i>every <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based object has an owner all the time</i>.
From the user's point of view, ownership is managed transparently.
For example, when you create a new <tt><a href="../api/classcMessage.html">cMessage</a></tt>,
it will be owned by the simple module. When you send it, it will
first be handed over to (i.e. change owership to) the FES<!--FES-->, and,
upon arrival, to the destination simple module. When you encapsulate
the message in another one, the encapsulating message will become
the owner. When you decapsulate it again, the currently active
simple module becomes the owner.

<p>The <tt>owner()</tt> method, defined in <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>, returns the
owner of the object:

<pre>
<a href="../api/classcOwnedObject.html">cOwnedObject</a> *o = msg-&gt;owner();
ev &lt;&lt; "Owner of " &lt;&lt; msg-&gt;name() &lt;&lt; " is: " &lt;&lt;
   &lt;&lt; "(" &lt;&lt; o-&gt;className() &lt;&lt; ") " &lt;&lt; o-&gt;fullPath() &lt;&lt; endl;
</pre>
<p>
The other direction, enumerating the objects owned can be implemented with
the <tt>forEachChild()</tt> method by it looping through all
contained objects and checking the owner of each object.

<p><p class="subheading">Why do we need this?</p>

<p>The traditional concept of object ownership is associated with
the ``right to delete'' objects. In addition to that,
keeping track of the owner and the list of objects owned also
serves other purposes in OMNeT++:

<p><ul>
    <li>enables methods like <tt>fullPath()</tt> to be implemented.

<p>    <li>prevents certain types of programming errors, namely,
    those associated with wrong ownership handling.

<p>    <li>enables Tkenv to display the list of simulation objects
    present within a simple module. This is extremely useful for finding
    memory leaks caused by forgetting to delete messages that are
    no longer needed.
</ul>

<p>Some examples of programming errors that can be caught
by the ownership facility:

<p><ul>
    <li>attempts to send a message while it is still in a queue,
    encapsulated in another message, etc.

<p>    <li>attempts to send/schedule a message while it is still owned
    by the simulation kernel (i.e. scheduled as a future event)

<p>    <li>attempts to send the very same message object to multiple
    destinations at the same time (ie. to all connected modules)
</ul>

<p>For example, the <tt>send()</tt> and <tt>scheduleAt()</tt> functions check
that the message being sent/scheduled <i>must</i> is owned by the module.
If it is not, then it signals a programming error: the message is probably
owned by another module (already sent earlier?), or currently scheduled, or
inside a queue, a message or some other object -- in either case, the
module does not have any authority over it. When you get the error message
(<tt>"not owner of object"</tt>), you need to carefully examine the error
message: which object has the ownership of the message, why's that, and
then probably you'll need to fix the logic somewhere in your program.

<p>The above errors are easy to make in the code, and if not detected
automatically, they could cause random crashes which are usually very
difficult to track down. Of course, some errors of the same kind still
cannot be detected automatically, like calling member functions of a
message object which has been sent to (and so currently kept by) another
module.

<p>
<H3><A NAME="sec275"/>6.12.2 Managing ownership</H3>

<p>Ownership is managed transparently for the user, but this mechanism
has to be supported by the participating classes themselves.
It will be useful to look inside <tt><a href="../api/classcQueue.html">cQueue</a></tt> and <tt><a href="../api/classcArray.html">cArray</a></tt>,
because they might give you a hint what behavior you need
to implement when you want to use non-OMNeT++ container classes
to store messages or other <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based objects.

<p>
<p class="subheading">Insertion</p>

<p><tt><a href="../api/classcArray.html">cArray</a></tt> and <tt><a href="../api/classcQueue.html">cQueue</a></tt> have internal data structures
(array and linked list) to store the objects which are inserted
into them. However, they do <i>not</i> necessarily own all of these
objects.  (Whether they own an object or not can be determined
from that object's <tt>owner()</tt> pointer.)

<p>The default behaviour of <tt><a href="../api/classcQueue.html">cQueue</a></tt> and <tt><a href="../api/classcArray.html">cArray</a></tt> is
to take ownership of the objects inserted.
This behavior can be changed via the <i>takeOwnership</i> flag.

<p>Here's what the <i>insert</i> operation of <tt><a href="../api/classcQueue.html">cQueue</a></tt> (or <tt><a href="../api/classcArray.html">cArray</a></tt>) does:
<ul>
    <li>insert the object into the internal array/list data structure

<p>    <li>if the <i>takeOwnership</i> flag is true, take ownership
    of the object, otherwise just leave it with its original owner
</ul>

<p>The corresponding source code:

<pre>
void <a href="../api/classcQueue.html">cQueue</a>::insert(<a href="../api/classcOwnedObject.html">cOwnedObject</a> *obj)
{
    // insert into queue data structure
    ...

    // take ownership if needed
    if (takeOwnership())
        take(obj);

}
</pre>
<p>

<p><p class="subheading">Removal</p>

<p>Here's what the <i>remove</i> family of operations in <tt><a href="../api/classcQueue.html">cQueue</a></tt>
(or <tt><a href="../api/classcArray.html">cArray</a></tt>) does:

<p><ul>
    <li>remove the object from the internal array/list data structure

<p>    <li>if the object is actually owned by this <tt><a href="../api/classcQueue.html">cQueue</a></tt>/<tt><a href="../api/classcArray.html">cArray</a></tt>,
    release ownership of the object, otherwise just leave it with
    its current owner
</ul>

<p>After the object was removed from a <tt><a href="../api/classcQueue.html">cQueue</a></tt>/<tt><a href="../api/classcArray.html">cArray</a></tt>,
you may further use it, or if it is not needed any more, you can delete it.

<p>The <i>release ownership</i> phrase requires further explanation.
When you remove an object from a queue or array, the ownership
is expected to be transferred to the simple module's local objects list.
This is acomplished by the <tt>drop()</tt> function, which transfers the
ownership to the object's default owner.
<tt>defaultOwner()</tt> is a virtual method returning <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a>*</tt>
defined in <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>, and its implementation returns
the currently executing simple module's local object list.

<p>As an example, the <tt>remove()</tt> method of <tt><a href="../api/classcQueue.html">cQueue</a></tt> is
implemented like this:
  <br><ul><font size=-1>[Actual code in <tt>src/sim</tt> is structured somewhat
  differently, but the meaning is the same.]</font></ul>

<pre>
<a href="../api/classcOwnedObject.html">cOwnedObject</a> *<a href="../api/classcQueue.html">cQueue</a>::remove(<a href="../api/classcOwnedObject.html">cOwnedObject</a> *obj)
{
    // remove object from queue data structure
    ...

    // release ownership if needed
    if (obj-&gt;owner()==this)
        drop(obj);

    return obj;
}
</pre>
<p>

<p><p class="subheading">Destructor</p>

<p>The concept of <tt>ownership</tt> is that <i>the owner has the
exclusive right and duty to delete the objects it owns</i>.
For example, if you delete a <tt><a href="../api/classcQueue.html">cQueue</a></tt> containing <tt><a href="../api/classcMessage.html">cMessage</a></tt>s,
all messages it contains <i>and</i> owns will also be deleted.

<p>The destructor should delete all data structures the object allocated.
From the contained objects, only the owned ones are deleted -- that is,
where <tt>obj-&gt;owner()==this</tt>.

<p>
<p class="subheading">Object copying</p>

<p>The ownership mechanism also has to be taken into consideration
when a <tt><a href="../api/classcArray.html">cArray</a></tt> or <tt><a href="../api/classcQueue.html">cQueue</a></tt> object is duplicated.
The duplicate is supposed to have the same content as the
original, however the question is whether the contained objects
should also be duplicated or only their pointers taken over
to the duplicate <tt><a href="../api/classcArray.html">cArray</a></tt> or <tt><a href="../api/classcQueue.html">cQueue</a></tt>.

<p>The convention followed by <tt><a href="../api/classcArray.html">cArray</a></tt>/<tt><a href="../api/classcQueue.html">cQueue</a></tt> is that
only owned objects are copied, and the contained but not owned ones
will have their pointers taken over and their original owners
left unchanged.

<p>In fact, the same question arises in three places:
the assignment operator <tt>operator=()</tt>, the copy constructor
and the <tt>dup()</tt> method.
In OMNeT++, the convention is that copying is implemented
in the assignment operator, and the other two just rely on it.
(The copy constructor just constructs an empty object and
invokes assigment, while <tt>dup()</tt>
is implemented as <tt>new <a href="../api/classcArray.html">cArray</a>(*this)</tt>).



</BODY>
</HTML>
<hr><hr><H1><A NAME="sec276"/>7 Building Simulation Programs</H1>
<a name="cha:building-simulation-programs"></a>

<p>

<p>
<H2><A NAME="sec277"/>7.1 Overview</H2>

<p>As it was already mentioned, an OMNeT++ model physically consists of
the following parts:
<ul>
  <li>NED language<!--ned!files--> topology description(s). These
      are files with the <tt>.ned</tt> suffix.
  <li>Message definitions<!--message definitions-->, in files
      with <tt>.msg</tt> suffix.
  <li>Simple modules implementations and other C++ code, in <tt>.cc</tt>
        files (or <tt>.cpp</tt>, on Windows)
</ul>

<p>
To build an executable simulation program,
you first need to translate the NED files<!--ned!files-->
and the message files into C++, using the NED compiler<!--ned!compiler-->
(<tt>nedtool</tt>) and the message compiler (<tt>opp_msgc</tt>).
After this step, the process is the same as building any C/C++
program from source: all C++ sources need to be compiled into object files
(<tt>.o</tt> files on Unix/Linux, and <tt>.obj</tt> on Windows),
and all object files need to be linked with the necessary libraries to get
an executable.


File names for libraries differ for Unix/Linux and for Windows,
and also different for static and shared libraries.
Let us suppose you have a library called Tkenv.
On a Unix/Linux system, the file name for the static library
would be something like <tt>libtkenv.a</tt> (or <tt>libtkenv.a.</tt><i>&lt;version&gt;</i>),
and the shared library would be called <tt>libtkenv.so</tt>
(or <tt>libtkenv.so.</tt><i>&lt;version&gt;</i>).
The Windows version of the static library would be <tt>tkenv.lib</tt>,
and the DLL (which is the Windows equivalent of shared libraries)
would be a file named <tt>tkenv.dll</tt>.

<p>You'll need to link with the following libraries:

<p><ul>
  <li>The simulation kernel and class library<!--simulation!kernel-->,
    called <i>sim_std</i> (file <tt>libsim_std.a</tt>, <tt>sim_std.lib</tt>, etc).
  <li>User interfaces. The common part of all user interfaces is
    the <i>envir</i> library (file <tt>libenvir.a</tt>, etc),
    and the specific user interfaces are <i>tkenv</i> and <i>cmdenv</i>
    (<tt>libtkenv.a</tt>, <tt>libcmdenv.a</tt>, etc). You have to link
    with <i>envir</i>, plus either <i>tkenv</i> or <i>cmdenv</i>.
</ul>

<p>Luckily, you do not have to worry about the above details, because
automatic tools like <tt>opp_makemake</tt> will take care of the hard
part for you.

<p>The following figure gives an overview of the process of building
and running simulation programs.

<p>
  <div align=center>
    <img src="usmanFig17.png">
    <center><i>Figure: Building and running simulation</i></center>
  </div>

<p>

<p>This section discusses how to use the simulation system on the
following platforms:
<ul>
  <li>Unix with gcc (also Windows with Cygwin or MinGW)
  <li>MSVC 6.0 on Windows
</ul>

<p>

<p>
<H2><A NAME="sec278"/>7.2 Using Unix and gcc</H2>

<p>This section applies to using OMNeT++ on Linux, Solaris, FreeBSD and
other Unix derivatives, and also more or less to Cygwin and MinGW
on Windows.

<p>Here in the manual we can give you a rough overview only.
The <tt>doc/</tt> directory of your OMNeT++ installation contains
<tt>Readme.</tt><i>&lt;platform&gt;</i> files that provide
up-to-date, more detailed and more precise instructions.

<p>
<H3><A NAME="sec279"/>7.2.1 Installation</H3>

<p>The installation process depends on what distribution you take
(source, precompiled RPM, etc.) and it may change from release
to release, so it is better to refer to the readme files.
If you compile from source, you can expect the usual GNU
procedure: <tt>./configure</tt> followed by <tt>make</tt>.

<p>
<H3><A NAME="sec280"/>7.2.2 Building simulation models</H3>

<p>The <tt>opp_makemake</tt> script can automatically generate the
<tt>Makefile</tt> for your simulation program, based on the source files
in the current directory. (It can also handle large models
which are spread across several directories; this is covered later in
this section.)

<p><tt>opp_makemake</tt> has several options, with the <tt>-h</tt>
option it displays a summary.

<pre>
% opp_makemake -h
</pre>
<p>
Once you have the source files (<tt>*.ned</tt>, <tt>*.msg</tt>, <tt>*.cc</tt>,
<tt>*.h</tt>) in a directory, <tt>cd</tt> there then type:

<pre>
% opp_makemake
</pre>
<p>
This will create a file named <tt>Makefile</tt><!--Makefile-->. Thus if you
simply type <tt>make</tt>, your simulation program should build. The name of
the executable will be the same as the name of the directory
containing the files.

<p>
The freshly generated <tt>Makefile</tt> doesn't contain
dependencies<!--Makefile!dependencies-->, it is advisable to add them
by typing <tt>make depend</tt>. The warnings during the
dependency generation process can be safely ignored.

<p>In addition to the simulation executable, the <tt>Makefile</tt>
contains other targets, too. Here is a list of important ones:

<p><table border>
<TR> <TD align=left>

<p><b>Target</b> </TD> <TD align=left> <b>Action</b></TD></TR>
<TR> <TD align=left>  </TD> <TD align=left> The default target is to build the simulation executable</TD></TR>
<TR> <TD align=left> depend </TD> <TD align=left> Adds (or refreshes) dependencies in the <tt>Makefile</tt></TD></TR>
<TR> <TD align=left> clean </TD> <TD align=left>  Deletes all files that were produced by the make process</TD></TR>
<TR> <TD align=left> makefiles </TD> <TD align=left> Regenerates the <tt>Makefile</tt> using <tt>opp_makemake</tt> (this is useful if e.g.  after upgrading OMNeT++, if <tt>opp_makemake</tt> has changed)</TD></TR>
<TR> <TD align=left> makefile-ins </TD> <TD align=left> Similar to <tt>make makefiles</tt>, but it regenerates the <tt>Makefile.in</tt> instead</TD></TR>
</table>

<p>If you already had a <tt>Makefile</tt> in that directory, <tt>opp_makemake</tt>
will refuse to overwrite it. You can force overwriting the old <tt>Makefile</tt>
with the -f option:

<pre>
% opp_makemake -f
</pre>
<p>
If you have problems, check the path definitions (locations of include
files and libraries etc.) in the configure script<!--configure script-->
and correct them if necessary. Then re-run configure for the changes
to take effect.

<p>You can specify the user interface (Cmdenv/Tkenv) with the -u option
(with no -u, Tkenv is the default):

<pre>
% opp_makemake -u Tkenv
</pre>
<p>
Or:

<pre>
% opp_makemake -u Cmdenv
</pre>
<p>
The name of the output file<!--output!file--> is set with the -o
option (the default is the name of the directory):

<pre>
% opp_makemake -o fddi-net
</pre>
<p>
If some of your source files are generated from other files (for
example, you use generated NED files), write your make rules
into a file called <tt>makefrag</tt>. When you run <tt>opp_makemake</tt>, it
will automatically insert <tt>makefrag</tt> into the resulting <tt>makefile</tt>.
With the -i option, you can also name other files to be included into
<tt>Makefile</tt>.

<p>
If you want better portability for your models, you can generate
<tt>Makefile.in</tt> instead of <tt>Makefile</tt> with <tt>opp_makemake</tt>'s
-m option. You can then use <tt>autoconf</tt>-like configure scripts to generate
the <tt>Makefile</tt>.

<p>

<p>
<H3><A NAME="sec281"/>7.2.3 Multi-directory models</H3>

<p>In the case of a large project, your source files may be spread across
several directories. You have to decide whether you want to use static
linking<!--static linking-->, shared or run-time loaded (shared)
libraries<!--shared libraries-->. Here we discuss static linking.

<p>In every subdirectory which contains source files, (say <tt>app/</tt> and
<tt>routing/</tt>), run

<pre>
opp_makemake -n
</pre>
<p>
The -n option means no linking is necessary, only compiling has
to be done.

<p>In non-leaf directories, run

<pre>
opp_makemake -r -n
</pre>
<p>
The -r option enables recursive make: when you build the simulation, make
will descend into the subdirectories and runs make in them too.
By default, -r decends into all subdirectories; the -X directory option
can be used to make it ignore certain subdirectories.

<p>You may need to use the -I option if you include files from other
directories. The -I option is for both C++ and NED
files<!--ned!include path-->. In our example, you could run

<pre>
opp_makemake -n -I../routing
</pre>
<p>
in the <tt>app/</tt> directory, and vice versa.

<p>To build an executable, the -w option can be used; it causes a simulation
executable to be built using all object files from the include (-I) directories:

<pre>
opp_makemake -w -I../routing -I../app
</pre>
<p>
You can affect build order by adding dependencies among subdirectories
into the <tt>makefrag</tt> (<tt>makefrag.vc</tt>) file.

<p>For a complex example of using opp_makemake, check the Makefiles
of the INET Framework, or rather, the makemake script (and makemake.bat file)
which contain the commands to generate the makefiles.

<p>

<p><H3><A NAME="sec282"/>7.2.4 Static vs shared OMNeT++ system libraries</H3>

<p>Default linking uses the shared libraries<!--shared libraries-->. One
reason you would want static linking is that
debugging<!--debugging--> the OMNeT++ class library is more trouble
with shared libraries. Another reason might be that you want to run
the executable on another machine without having to worry about
setting the <tt>LD_LIBRARY_PATH</tt> variable (which should contain the name
of the directory where the OMNeT++ shared libraries are).

<p>If you want static linking<!--static linking-->, find the

<pre>
build_shared_libs=yes
</pre>
<p>

<p>line in the <tt>configure.user</tt> script and change it to

<pre>
build_shared_libs=no
</pre>
<p>
Then you have to re-run the configure script and rebuild everything:

<pre>
./configure
make clean
make
</pre>
<p>

<p>
<H2><A NAME="sec283"/>7.3 Using Windows and Microsoft Visual C++</H2>

<p>This is only a rough overview. Up-to-date, more detailed and more
precise instructions can be found in the <tt>doc/</tt> directory
of your OMNeT++ installation, in the file <tt>Readme.MSVC</tt>.

<p>
<H3><A NAME="sec284"/>7.3.1 Installation</H3>

<p>It is easiest to start with the binary, installer version.
It contains all necessary software except MSVC<!--MSVC-->,
and you can get a working system up and running very fast.

<p>Later you'll probably want to download and build the source
distribution too. Reasons for that might be to compile the libraries
with different flags, to debug into them, or to recompile
with support for additional packages (e.g. Akaroa, MPI).
Compilation should be painless (it takes a single
<tt>nmake -f Makefile.vc</tt> command) after you get the different
component directories right in <tt>configuser.vc</tt>.
Additional software needed for the compilation is also described
in <tt>doc/</tt>.

<p>
<H3><A NAME="sec285"/>7.3.2 Building simulation models on the command line</H3>

<p>OMNeT++ has an automatic MSVC makefile creator named <tt>opp_nmakemake</tt>
which is probably the easier way to go. Its usage is very similar
to the similarly named tool for Unix.

<p>If you run <tt>opp_nmakemake</tt> in a directory of model sources, it
collects all the names of all source files in the directory,
and creates a makefile from them. The resulting makefile is
called <tt>Makefile.vc</tt>.

<p>To use <tt>opp_nmakemake</tt>, open a command window (<i>Start menu</i>
-&gt; <i>Run...</i> --&gt; type <tt>cmd</tt>), then <tt>cd</tt> to the directory
of your model and type:

<pre>
opp_nmakemake
</pre>
<p>
<tt>opp_nmakemake</tt> has several command-line options, mostly the
same as the Unix version.

<p>Then you can build the program by typing:

<pre>
nmake -f Makefile.vc
</pre>
<p>
The most common problem is that <tt>nmake</tt> (which is is part of MSVC)
cannot be found because it is not in the path. You can fix
this by running <tt>vcvars32.bat</tt>, which can be found in the
MSVC <tt>bin</tt> directory (usually
<tt>C:\Program Files\Microsoft
Visual Studio\VC98\Bin</tt>).

<p>
<H3><A NAME="sec286"/>7.3.3 Building simulation models from the MSVC IDE</H3>

<p>You can also use the MSVC IDE for development.
It is best to start by copying one of the sample simulations.

<p>If you want to use compiled NED files (as opposed to dynamic
NED loading, described in section <a href="#"></a>),
you need to add NED files to the project, with Custom Build Step
commands to invoke the NED compiler (<tt>nedtool</tt>) on them.
You also need to add the <tt>_n.cc</tt> files generated by <tt>nedtool</tt>
to the project. There is an <tt>AddNEDFileToProject</tt>
macro which performs exactly this task: adding a NED file and
the corresponding <tt>_n.cc</tt> file, and configuring
the Custom Build Step.

<p>
Some caveats (please read <tt>doc/Readme.MSVC</tt> for more!):

<p><ul>
 <li> <b>how to get the graphical environment</b>. By default,
   the sample simulations link with Cmdenv if you rebuild them
   from the IDE. To change to Tkenv, choose Build|Set
   active configuration from the menu, select ``Debug-Tkenv''
   or ``Release-Tkenv'', then re-link the executable.

<p> <li> <b>can't find a usable init.tcl</b>. If you get this message,
   Tcl/Tk is missing the <tt>TCL_LIBRARY</tt> environment variable
   which is normally set by the installer. If you see this message,
   you need to set this variable yourself to the Tcl <tt>lib/</tt> directory.

<p> <li> <b>changed compiler settings</b>. Changes since OMNeT++ 2.2:
   You'll need exception handling and RTTI turned ON, and
   stack size set to as low as 64K.
   See the readme file for rationale and more hints.

<p> <li> <b>adding NED files</b>. After you added a <tt>.ned</tt> file
   to the project, you also have to add a <tt>_n.cpp</tt> file, and set a
   <i>Custom Build Step</i> for them:

<pre>
Description: NED Compiling $(InputPath)
Command: nedtool -s _n.cpp $(InputPath)
Outputs: $(InputName)_n.cpp
</pre>
<p>
   For msg files you need an analogous procedure.

<p> <li> <b>file name extension</b>: MSVC 6.0 doesn't recognize <tt>.cc</tt> files
   as C++ sources. Your options are to switch to the <tt>.cpp</tt> extension,
   to convince MSVC by changing by the corresponding registry entries.
   Do a web search to find out what exactly you need to change.

<p></ul>

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec287"/>8 Configuring and Running Simulations</H1>
<a name="cha:run-sim"></a>

<p><H2><A NAME="sec288"/>8.1 Configuring simulations</H2>

<p>Configuration and input data for the simulation are in
a configuration file usually called <tt>omnetpp.ini</tt>.
Some entries in this file apply to Tkenv or Cmdenv only, other
settings are in effect regardless of the user interface.
Both user interfaces accept command-line arguments, too.

<p>The following sections explain <tt>omnetpp.ini</tt>.

<p><H2><A NAME="sec289"/>8.2 The configuration file: omnetpp.ini</H2>

<p><H3><A NAME="sec290"/>8.2.1 An example</H3>

<p>For a start, let us see a simple <tt>omnetpp.ini</tt> file which
can be used to run the Fifo example simulation.

<pre>
[General]
network = FifoNet
sim-time-limit = 100h
cpu-time-limit = 300s
#debug-on-errors = true
#record-eventlog = true

[Config Fifo1]
description = "low job arrival rate"
**.gen.sendIaTime = exponential(0.2s)
**.gen.msgLength = 100b
**.fifo.bitsPerSec = 1000bps

[Config Fifo2]
description = "high job arrival rate"
**.gen.sendIaTime = exponential(0.01s)
**.gen.msgLength = 10b
**.fifo.bitsPerSec = 1000bps
</pre>
<p>
The file is grouped into <i>sections</i> named <tt>[General]</tt>, <tt>[Config Fifo1]</tt>
and <tt>[Config Fifo2]</tt>, each one containing several <i>entries</i>.

<p>Lines that start with ``#'' are comments.

<p>When you build the Fifo example with Cmdenv and you run it by typing <tt>fifo1</tt>
(or on Unix, <tt>./fifo1</tt>) on the command prompt, you should see
something like this.

<pre>
OMNeT++ Discrete Event Simulation  (C) 1992-2003 Andras Varga
See the license for distribution terms and warranty disclaimer
Setting up Cmdenv (command-line user interface)...

Preparing for Run #1...
Setting up network `fifonet1'...
Running simulation...
** Event #0        T=0.0000000   Elapsed: 0m  0s
** Event #100000   T=25321.99    Elapsed: 0m  1s
** Event #200000   T=50275.694   Elapsed: 0m  3s
** Event #300000   T=75217.597   Elapsed: 0m  5s
** Event #400000   T=100125.76   Elapsed: 0m  6s
** Event #500000   T=125239.67   Elapsed: 0m  8s
...
** Event #1700000  T=424529.21   Elapsed: 0m 28s
** Event #1800000  T=449573.47   Elapsed: 0m 30s
** Event #1900000  T=474429.06   Elapsed: 0m 32s
** Event #2000000  T=499417.66   Elapsed: 0m 34s
&lt;!&gt; Simulation time limit reached -- simulation stopped.
</pre>
<p>
As Cmdenv runs the simulation, periodically it prints the sequence number
of the current event, the simulation time, the elapsed (real) time,
and the performance of the simulation (how many events are processed per
second; the first two values are 0 because there wasn't enough data
for it to calculate yet). At the end of the simulation, the <tt>finish()</tt>
methods of the simple modules are run, and the output from them are displayed.
On my machine this run took 34 seconds. This Cmdenv output can be
customized via <tt>omnetpp.ini</tt> entries. The output file <tt>fifo1.vec</tt>
contains vector data recorded during simulation (here, queueing times),
and it can be processed using Plove or other tools.

<p><H3><A NAME="sec291"/>8.2.2 The concept of simulation runs</H3>

<p>OMNeT++ can execute several simulation runs automatically one after
another. If multiple runs<!--simulation!multiple runs--> are
selected, option settings and parameter values can be given either
individually for each run, or together for all runs, depending in
which section the option or parameter appears.

<p><H3><A NAME="sec292"/>8.2.3 File syntax</H3>

<p>The ini file is a text file consisting of entries grouped into different sections.
The order of the sections doesn't matter. Also, if you have two sections
with the same name (e.g. <tt>[General]</tt> occurs twice in the file),
they will be merged.

<p>Lines that start with "#" are comments, and will be ignored during processing.

<p>Long lines can be broken up using the backslash notation: if the last character
of a line is "\", it will be merged with the next line.

<p>There is no limit on the file size or the maximum line length.

<p>Example:

<pre>
[General]
# this is a comment
foo="this is a single value \
for the foo parameter"

[General]  # duplicate sections are merged
bar="belongs to the same section as foo"
</pre>
<p>
<H3><A NAME="sec293"/>8.2.4 File inclusion</H3>

<p>OMNeT++ supports including an ini file in another<!--ini file!file inclusion-->,
via the <tt>include</tt> keyword. This feature allows you to partition large ini
files into logical units, fixed and varying part etc.

<p>An example:

<pre>
# omnetpp.ini
...
include parameters.ini
include per-run-pars.ini
...
</pre>
<p>
You can also include files from other directories. If the included ini file
further includes others, their path names will be understood as relative
to the location of the file which contains the reference,
rather than relative to the current working directory of the simulation.

<p>This rule also applies to other file names occurring in ini files
(such as the <tt>load-libs=</tt>, <tt>output-vector-file=</tt>, <tt>output-scalar-file=</tt>
etc. options, and <tt>xmldoc()</tt> module parameter values.)

<p>
<H2><A NAME="sec294"/>8.3 Sections</H2>
<H3><A NAME="sec295"/>8.3.1 Overview</H3>

<p>Named configurations are sections of the form <tt>[Config &lt;configname&gt;]</tt>, where
<i>&lt;configname&gt;</i> is by convention a camel-case string that starts with a capital letter:
<tt>Config1</tt>, <tt>WirelessPing</tt>, <tt>OverloadedFifo</tt>, etc. For example,
<tt>omnetpp.ini</tt> for an Aloha simulation might have the following skeleton:

<p><pre>
[General]
...
[Config PureAloha]
...
[Config SlottedAloha1]
...
[Config SlottedAloha2]
...
</pre>

<p>Some configuration keys (such as user interface selection) are only
accepted in the <tt>[General]</tt> section, but most of them can go into Config
sections as well.

<p>When you run a simulation, you need to select one of the configurations
to be activated. In Cmdenv, this is done with the <tt>-c</tt> command-line option:

<p><pre>
$ aloha -c PureAloha
</pre>

<p>The simulation will then use the contents of the <tt>[Config PureAloha]</tt>
section to set up the simulation. (Tkenv, of course, lets you select
the configuration from a dialog.)

<p>
<H3><A NAME="sec296"/>8.3.2 Fallbacks</H3>

<p>Actually, when you activate the PureAloha configuration, the contents of
the <tt>[General]</tt> section will also be taken into account: if some
configuration key or parameter value is not found in <tt>[Config PureAloha]</tt>,
then the search will continue in the <tt>[General]</tt> section. In
other words, lookups in <tt>[Config PureAloha]</tt> will fall back to <tt>[General]</tt>.
The <tt>[General]</tt> section itself is optional; when it is absent, it is
treated like an empty <tt>[General]</tt> section.

<p>All named configurations fall back to <tt>[General]</tt> by default. However, for
each configuration it is possible to specify a fall-back section
explicitly, using the extends= key. Consider the following ini file
skeleton:

<p><pre>
[General]
...
[Config SlottedAlohaBase]
...
[Config SlottedAloha1]
extends = SlottedAlohaBase
...
[Config SlottedAloha2]
extends = SlottedAlohaBase
...
[Config SlottedAloha2a]
extends = SlottedAloha2
...
[Config SlottedAloha2b]
extends = SlottedAloha2
...
</pre>

<p>
If you activate the <tt>SlottedAloha2b</tt> configuration, lookups will consider
sections in the following order (this is also called the
<i>section fallback chain</i>): <tt>SlottedAloha2b</tt>,
<tt>SlottedAloha2</tt>, <tt>SlottedAlohaBase</tt>, <tt>General</tt>.

<p>The effect is the same as if the contents of the sections
SlottedAloha2b, SlottedAloha2, SlottedAlohaBase and General were copied
together into one section, one after another, <tt>[Config SlottedAloha2b]</tt>
being at the top, and <tt>[General]</tt> at the bottom. Lookups always start at
the top, and stop at the first matching entry.

<p>The concept is similar to inheritance in object-oriented languages,
and benefits are similar too: you can to factor out the common parts of
several configurations into a "base"
configuration, and the other way round, you can reuse existing
configurations (as opposed to copying them) by using them as a base. In
practice you will often have "abstract"
configurations too (in the C++/Java sense), which assign only a subset
of parameters and leave the others open, to be assigned in derived
configurations.

<p>If you are experimenting a lot with different parameter settings of a
simulation model, these techniques will make it a lot easier to manage
ini files.

<p><H2><A NAME="sec297"/>8.4 Scenarios</H2>

<p><H3><A NAME="sec298"/>8.4.1 Basic use</H3>

<p>
It is quite common in simulation studies that the simulation model is
run several times with different parameter settings, and the results
are analyzed in relation to the input parameters. OMNeT++ 3.x had no
direct support for batch runs, and users had to resort to writing shell
(or Python, Ruby, etc.) scripts that iterated over the required
parameter space, and generated a (partial) ini file and run the
simulation program in each iteration.

<p>OMNeT++ 4.0 largely automates this process, and eliminates the need for
writing batch execution scripts. It is the ini file where the user can
specify iterations over various parameter settings.
Here's an example:

<p><pre>
[Config AlohaScenario]
*.numHosts = ${1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential( ${0.2, 0.4, 0.6} )
</pre>

<p>
This scenario expands to 8*3 = 24 simulation runs, where the number of
hosts iterates over the numbers 1, 2, 5, 10, 20, 30, 40, 50, and for
each host count three simulation runs will be done, with the generation
interval being exponential(0.2), exponential(0.4), and
exponential(0.6).

<p>How does it get run? First of all, Cmdenv with the '-n' option will tell you how many
simulation runs a given section expands to. (You'll of course use Cmdenv for batch runs,
not Tkenv.)

<p><pre>
$ aloha -u Cmdenv -c AlohaScenario -n

OMNeT++/OMNEST Discrete Event Simulation
...
Config: AlohaScenario
Number of runs: 24
</pre>

<p>
If you add the '-g' option, the
program will also print out the values of the iteration variables for
each run. Note that the scenario description actually maps to nested
loops, with the last "${..}" becoming
the innermost loop. The iteration variables are just named $0 and $1
-- we'll see that it is possible to give
meaningful names to them. Please ignore the
'$repetition=0' part in the printout
for now.

<p>
<pre>
$ aloha -u Cmdenv -c AlohaScenario -n -g
OMNeT++/OMNEST Discrete Event Simulation
...
Config: AlohaScenario
Number of runs: 24
Run 0: $0=1, $1=0.2, $repetition=0
Run 1: $0=1, $1=0.4, $repetition=0
Run 2: $0=1, $1=0.6, $repetition=0
Run 3: $0=2, $1=0.2, $repetition=0
Run 4: $0=2, $1=0.4, $repetition=0
Run 5: $0=2, $1=0.6, $repetition=0
Run 6: $0=5, $1=0.2, $repetition=0
Run 7: $0=5, $1=0.4, $repetition=0
...
Run 19: $0=40, $1=0.4, $repetition=0
Run 20: $0=40, $1=0.6, $repetition=0
Run 21: $0=50, $1=0.2, $repetition=0
Run 22: $0=50, $1=0.4, $repetition=0
Run 23: $0=50, $1=0.6, $repetition=0
</pre>

<p>
Any of these runs can be executed by passing the '-r
&lt;runnumber&gt;' option to Cmdenv.
So, the task is now to run the simulation program 24 times, with
'-r' running from 0 through 23:

<p><pre>
$ aloha -u Cmdenv -c AlohaScenario -r 0
$ aloha -u Cmdenv -c AlohaScenario -r 1
$ aloha -u Cmdenv -c AlohaScenario -r 2
...
$ aloha -u Cmdenv -c AlohaScenario -r 23
</pre>

<p>
This batch can be executed either from the OMNeT++ IDE (where you are
prompted to pick an executable and an ini file, choose the scenario
from a list, and just click Run), or using a little command-line
batch execution tool supplied with OMNeT++.

<p>Actually, it is also possible to get Cmdenv execute all runs in one go,
by simply omitting the '-r' option.

<p>
<pre>
$ aloha -u Cmdenv -c AlohaScenario

OMNeT++/OMNEST Discrete Event Simulation
Preparing for running configuration AlohaScenario, run #0...
...
Preparing for running configuration AlohaScenario, run #1...
...
...
Preparing for running configuration AlohaScenario, run #23...
</pre>

<p>
However, this approach is not recommended, because it is more
susceptible to C++ programming errors in the model. (For example, if
any of the runs crashes, the whole batch is terminated -- which may
not be what the user wants).

<p>Let us get back to the ini file. We had:

<p><pre>
[Config AlohaScenario]
*.numHosts = ${1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential( ${0.2, 0.4, 0.6} )
</pre>

<p>
The ${...} syntax specifies an iteration. It is sort of a macro: at
each run, the whole ${...} string gets textually replaced with the
current iteration value. The values to iterate over do not need to be
numbers (unless you want to use the <i>"a..b"</i> or
<i>"a..b step c"</i> syntax), and the
substitution takes place even inside string constants. So, the
following examples are all valid (note that textual substitution is
used):

<p><pre>
*.param = 1 + ${1e-6, 1/3, sin(0.5)}
    ==&gt; *.param = 1 + 1e-6
        *.param = 1 + 1/3
        *.param = 1 + sin(0.5)
*.greeting = "We will simulate ${1,2,5} host(s)."
    ==&gt; *.greeting = "We will simulate 1 host(s)."
        *.greeting = "We will simulate 2 host(s)."
        *.greeting = "We will simulate 5 host(s)."
</pre>

<p>
To write a literal ${..} inside a string constant, quote
"{" with a backslash, and write "$\{..}".

<p>
<H3><A NAME="sec299"/>8.4.2 Named iteration variables</H3>

<p>You can assign names to iteration variables, which has the advantage
that you'll see meaningful names instead of $0 and
$1 in the Cmdenv output, and also lets you refer to the variables at
more than one place in the ini file. The syntax is
${&lt;varname&gt;=&lt;iteration&gt;}, and variables can be referred to simply as
${&lt;varname&gt;}:

<p><pre>
[Config Aloha]
*.numHosts = ${N=1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential( ${mean=0.2, 0.4, 0.6} )
**.greeting = "There are ${N} hosts"
</pre>

<p>The scope of the variable name is the section that defines it, plus
sections based on that section (via extends=).

<p>There are also a number of predefined variables: ${configname} and
${runnumber} with the obvious meanings; ${network} is the name of
the network that is simulated; ${processid} and ${datetime}
expand to the OS process id of the simulation and the time it was
started; and there are some more: ${runid}, ${iterationvars} and
${repetition}.

<p>${runid} holds the Run ID. When a simulation is run, it gets assigned
a Run ID, which uniquely identifies that instance of running the
simulation: if you run the same thing again, it will get a different
Run ID. Run ID is a concatenation of several variables like
${configname}, ${runnumber}, ${datetime} and ${processid}.
This yields an identifier that is unique
"enough" for all practical purposes, yet it
is meaningful for humans. The Run ID is recorded into result files
written during the simulation, and can be used to match vectors and
scalars written by the same simulation run.

<p>In cases when not all combinations of the iteration variables make sense
or need to be simulated, it is possible to specify an additional
constraint expression. This expression is interpreted as a conditional
(an "if" statement) within the innermost
loop, and it must evaluate to "true" for
the variable combination to generate a run. The expression should be
given with the constraint= configuration key. An example:

<p><pre>
*.numNodes = ${n=10..100 step 10}
**.numNeighbors = ${m=2..10 step 2}
constraint = $m &lt;= sqrt($n)
</pre>

<p>
The expression syntax supports most C language operators (including
boolean, conditional and binary shift operations) and most
&lt;math.h&gt; functions; data types are boolean,
double and string. The expression must evaluate to a boolean.

<p><fontmaroon><em> Unknown LaTeX command </em> \begin </font>note<fontmaroon><em>  </em>  </font>
    It is not supported to refer to other iteration variables
    in the definition of an iteration variable (i.e. you cannot write
    things like ${j=$i..10}), although it might get implemented in
    future OMNeT++ releases.

<p>
<H3><A NAME="sec300"/>8.4.3 Repeating runs with different seeds</H3>

<p>It is directly supported to perform several runs with the same
parameters but different random number seeds. There are two
configuration keys related to this: repeat= and seed-set=. The first
one simple specifies how many times a run needs to be repeated. For
example,

<p><pre>
repeat = 10
</pre>

<p>causes every combination of iteration variables to be repeated 10 times,
and the ${repetition} predefined variable holds the loop counter.
Indeed, repeat=10 is equivalent of adding ${repetition=0..9} to the
ini file. The ${repetition} loop always becomes the innermost loop.

<p>The seed-set= configuration key affects seed selection. Every
simulation uses one or more random number generators (as configured by
the num-rngs= key), for which the simulation kernel can automatically
generate seeds. The first simulation run may use one set of seeds (seed
set 0), the second run may use a second set (seed set 1), and so on.
Each set contains as many seeds as there are RNGs configured. All
automatic seeds generate random number sequences that are far apart in
the RNG's cycle, so they will never overlap during
simulations.

<p>
Mersenne Twister, the default RNG of OMNeT++ has a cycle length of
<i>2<sup>19937</sup></i>, which is more than enough for any conceivable purpose.

<p>
The seed-set= key tells the simulation kernel which seed set to use.
It can be set to a concrete number (such as seed-set=0), but it
usually does not make sense as it would cause every simulation to run
with exactly the same seeds. It is more practical to set it to either
${runnumber} or to ${repetition}. The default setting is
${runnumber}:

<p><pre>
seed-set = ${runnumber}   # this is the default
</pre>

<p>This makes every simulation run to execute with a unique seed set. The
second option is:

<p><pre>
seed-set = ${repetition}
</pre>

<p>where all $repetition=0 runs will use the same seeds (seed set 0), all
$repetition=1 runs use another seed set, $repetition=2 a third seed
set, etc.

<p>To perform runs with manually selected seed sets, you can just define an
iteration for the seed-set= key:

<p><pre>
seed-set = ${5,6,8..11}
</pre>

<p>In this case, the repeat= key should be left out, as seed-set= already
defines an iteration and there's no need for an extra
loop.

<p>It is of course also possible to manually specify individual seeds for
simulations. This is rarely necessary, but we can use it here to
demonstrate another feature, parallel iterators:

<p><pre>
repeat = 4
seed-1-mt = ${53542, 45732, 47853, 33434 ! repetition}
seed-2-mt = ${75335, 35463, 24674, 56673 ! repetition}
seed-3-mt = ${34542, 67563, 96433, 23567 ! repetition}
</pre>

<p>The meaning of the above is this: in the first repetition, the first
column of seeds is chosen, for the second repetition, the second
column, etc. The "!" syntax chooses the
<i>kth</i> value from the iteration, where <i>k</i> is the position
(iteration count) of the iteration variable after the
"!". Thus, the above example is equivalent
to the following:

<p><pre>
# no repeat= line!
seed-1-mt = ${seed1 = 53542, 45732, 47853, 33434}
seed-2-mt = ${        75335, 35463, 24674, 56673 ! seed1}
seed-3-mt = ${        34542, 67563, 96433, 23567 ! seed1}
</pre>

<p>That is, the iterators of seed-2-mt and seed-3-mt are advanced
in lockstep with the seed1 iteration.

<p>
<H2><A NAME="sec301"/>8.5 Scenarios and Result Analysis</H2>

<p><H3><A NAME="sec302"/>8.5.1 Output vectors and scalars</H3>

<p>In OMNeT++ 3.x, the default result file names were ``omnetpp.vec'' and
``omnetpp.sca''. This is not very convenient for batch execution, where
an output vector file created in one run would be overwritten in the
next run. Thus, we have changed the default file names to make them
differ for every run. The new defaults are:

<p><pre>
output-vector-file = "${configname}-${runnumber}.vec"
output-scalar-file = "${configname}-${runnumber}.sca"
</pre>

<p>
This generates file names like "PureAloha-0.vec", "PureAloha-1.vec", and so on.

<p>Also, in OMNeT++ 3.x output scalar files were always appended to by the
simulation program, rather than being overwritten. This behavior was
changed in 4.0 to make it consistent with vector files, that is, output
scalar files are also overwritten by the simulator, and not appended
to.

<p>
    The old behavior can be turned back on by setting
    output-scalar-file-append=true.

<p>
The way of configuring output vectors has also changed. In OMNeT++ 3.x,
the keys for enabling-disabling a vector and specifying recording
interval were &lt;module-and-vectorname-pattern&gt;.enabled,
and &lt;module-and-vectorname-pattern&gt;.interval.
The "enabled" and "interval" words changed to "enable-recording" and
"recording-interval".

<p>
    The reason for this change is that per-object
    configuration keys are now required to have a hyphen in their names, to
    make it possible to tell them apart from module parameter assignments.
    This allows the simulator to catch mistyped config keys in ini files.

<p>
The syntax for specifying the recording interval has also been extended
(in a backward compatible way) to accept multiple intervals, separated
by comma. An example:

<p><pre>
**.fifo[2].queueLengthVector.enable-recording = false
**.fifo[*].queueLengthVector.recording-interval = ..100, 300..500, 900..
</pre>

<p>Although it has nothing to do with our main topic (ini files), this is a
good place to mention that the format of result files have been
extended to include meta info such as the run ID, network name, all
configuration settings, etc. These data make the files more
self-documenting, which can be valuable during the result analysis
phase, and increase reproduciblity of the results. Another change is
that vector data are now recorded into the file clustered by the output
vectors, which (combined with index files) allows much more efficient
processing.

<p><H3><A NAME="sec303"/>8.5.2 Saving parameters as scalars</H3>

<p>When you are running several simulations with different parameter
settings, you'll usually want to refer to selected
input parameters in the result analysis as well -- for example when
drawing a throughput (or response time) versus load (or network
background traffic) plot. Average throughput or response time numbers
are saved into the output scalar files, and it is useful for the input
parameters to get saved into the same file as well.

<p>For convenience, OMNeT++ automatically saves the iteration variables
into the output scalar file, so they can be referred to during result
analysis. Module parameters can also be saved, but this has to be
requested by the user, by configuring save-as-scalar=true for the
parameters in question. The configuration key is a pattern that
identifies the parameter, plus ".save-as-scalar". An example:

<p><pre>
**.host[*].networkLoad.save-as-scalar = true
</pre>

<p>This looks simple enough. However, there are three pitfalls:
non-numeric parameters, too many matching parameters, and
random-valued volatile parameters.

<p>First, the scalar file only holds numeric results, so non-numeric
parameters cannot be recorded -- that will result in a runtime
error.

<p>Second, if wildcards in the pattern match too many parameters, that
might unnecessarily increase the size of the scalar file. For example,
if the host[] module vector size is 1000 in the example below, then the
same value (3) will be saved 1000 times into the scalar file, once for
each host.

<p><pre>
**.host[*].startTime = 3
**.host[*].startTime.save-as-scalar = true  # saves "3" once for each host
</pre>

<p>Third, recording a random-valued volatile parameter will just save a
random number from that distribution. This is rarely what you need, and
the simulation kernel will also issue a warning if this happens.

<p><pre>
**.interarrivalTime = exponential(1)
**.interarrivalTime.save-as-scalar = true  # wrong: saves random values!
</pre>

<p>
These pitfalls are not rare in practice, so it is usually more
convenient to rely on the iteration variables in the result analysis.
That is, one can rewrite the above example as

<p><pre>
**.interarrivalTime = exponential( $mean=1 )
</pre>

<p>and refer to the $mean iteration variable instead of the
interarrivalTime module parameter(s) during result analysis.
save-as-scalar=true is not needed because iteration variables are
automatically saved into the result files.

<p>

<p><H3><A NAME="sec304"/>8.5.3 Experiment-Measurement-Replication</H3>

<p>We have introduced three concepts that are useful for organizing
simulation results generated by batch executions or several batches of
executions.

<p>During a simulation study, a person prepares several
<i>experiments</i>. The purpose of an experiment is to find out the
answer to questions like <i>"how does the number of
nodes affect response times in the network?"</i> For an
experiment, several <i>measurements</i> are performed on the
simulation model, and each measurement runs the simulation model with a
different parameter settings. To eliminate the bias introduced by the
particular random number stream used for the simulation, several
<i>replications</i> of every measurement are run with different
random number seeds, and the results are averaged.

<p>OMNeT++ result analysis tools can take advantage of
experiment/measurement/replication labels recorded into result files,
and organize simulation runs and recorded output scalars and vectors
accordingly on the user interface.

<p>These labels can be explicitly specified in the ini file using the
experiment=, measurement= and replication= config keys. If they are
missing, the default is the following:

<p><pre>
experiment = "${configname}"
measurement = "${iterationvars}"
replication = "#${repetition},seed-set=&lt;seedset&gt;"
</pre>

<p>
That is, the default experiment label is the configuration name; the
measurement label is concatenated from the iteration variables; and the
replication label contains the repeat loop variable and for the
seed-set. Thus, for our first example the
experiment-measurement-replication tree would look like this:

<p><pre>
<fontmaroon><em> Unknown LaTeX command </em> \textrm </font>"PureAloha" <fontmaroon><em>  </em>  </font><fontmaroon><em> Unknown LaTeX command </em> \textrm </font><i>--experiment</i><fontmaroon><em>  </em>  </font>
<fontmaroon><em> Unknown LaTeX command </em> \textrm </font>$N=1,$mean=0.2<fontmaroon><em>  </em>  </font><fontmaroon><em> Unknown LaTeX command </em> \textrm </font><i> -- measurement</i><fontmaroon><em>  </em>  </font>
<fontmaroon><em> Unknown LaTeX command </em> \textrm </font>#0, seed-set=0<fontmaroon><em>  </em>  </font><fontmaroon><em> Unknown LaTeX command </em> \textrm </font><i> -- replication</i><fontmaroon><em>  </em>  </font>
</pre>

<p>#1, seed-set=1

<p>#2, seed-set=2

<p>#3, seed-set=3

<p>#4, seed-set=4

<p>$N=1,$mean=0.4

<p>#0, seed-set=5

<p>#1, seed-set=6

<p>...

<p>#4, seed-set=9

<p>$N=1,$mean=0.6

<p>#0, seed-set=10

<p>#1, seed-set=11

<p>...

<p>#4, seed-set=14

<p>$N=2,$mean=0.2

<p>...

<p>$N=2,$mean=0.4

<p>...

<p>...

<p>

<p>
The experiment-measurement-replication labels should be enough to
reproduce the same simulation results, given of course that the ini
files and the model (NED files and C++ code) haven't
changed.

<p>Every instance of running the simulation gets a unique run ID. We can
illustrate this by listing the corresponding run IDs under each
repetition in the tree. For example:

<p>"PureAloha"

<p>$N=1,$mean=0.2

<p>#0, seed-set=0

<p><i>PureAloha-0-20070704-11:38:21-3241</i>

<p><i>PureAloha-0-20070704-11:53:47-3884</i>

<p><i>PureAloha-0-20070704-16:50:44-4612</i>

<p>#1, seed-set=1

<p><i>PureAloha-1-20070704-16:50:55-4613</i>

<p>#2, seed-set=2

<p><i>PureAloha-2-20070704-11:55:23-3892</i>

<p><i>PureAloha-2-20070704-16:51:17-4615</i>

<p>\itshape
...

<p>

<p>
The tree shows that ("PureAloha", "$N=1,$mean=0.2", "#0, seed-set=0")
was run three times. The results produced
by these three executions should be identical, unless, for example,
some parameter was modified in the ini file, or a bug got fixed in the
C++ code.

<p>We believe that the default way of generating
experiment-measurement-replication labels will be useful and
sufficient in the majority of the simulation studies. However, you can
customize it if needed. For example, here is a way to join two
scenarios into one experiment:

<p><pre>
[Config PureAloha_Part1]
experiment = "PureAloha"
...
[Config PureAloha_Part2]
experiment = "PureAloha"
...
</pre>

<p>

<p>
Measurement and replication labels can be customized in a similar way,
making use of named iteration variables, ${repetition},
${runnumber} and other predefined variables. One possible benefit is
to customize the generated measurement and replication labels. For
example:

<p><pre>
[Config PureAloha_Part1]
measurement = "${N} hosts, exponential(${mean}) packet generation interval"
</pre>

<p>
One should be careful with the above technique though, because if some
iteration variables are left out of the measurement labels, runs with
all values of those variables will be grouped together to the same
replications.

<p>

<p>////////////////////////////////////////////////////////////////

<p>

<p>

<p><H2><A NAME="sec305"/>8.6 User interfaces</H2>

<p>OMNeT++ simulations can be run under different user interfaces.
Currenly, two user interfaces are supported:

<p><ul>
  <li> Tkenv: Tcl/Tk-based graphical, windowing user interface
  <li> Cmdenv: command-line user interface for batch execution
</ul>

<p>
You would typically test and debug your simulation under Tkenv,
then run actual simulation experiments from the command line or
shell script, using Cmdenv. Tkenv is also better suited for educational or
demonstration purposes.

<p>Both Tkenv and Cmdenv are provided in the form of a library, and
you choose between them by linking one or the other into your
simulation executable. (Creating the executable was described in
chapter <a href="#sec276">[7]</a>). Both user interfaces
are supported on Unix and Windows platforms.

<p>Common functionality in Tkenv and Cmdenv has been collected and
placed into the Envir library<!--Envir-->, which can be thought of as the
``common base class'' for the two user interfaces.

<p>The user interface<!--user interface--> is separated from the
simulation kernel, and the two parts interact through a well-defined
interface. This also means that, if needed, you can write your
own user interface or embed an OMNeT++ simulation into your application
without any change to models or the simulation library.

<p>

<p><H3><A NAME="sec306"/>8.6.1 The [General] section</H3>

<p>The most important options of the <tt>[General]</tt> section are the
following.
<ul>
  <li>The <tt>network</tt> option selects the model to be set up and run.
  <li>The length of the simulation can be set with the
    <tt>sim-time-limit</tt> and the <tt>cpu-time-limit</tt> options (the
    usual time units such as ms, s, m, h, etc. can be used).
  <li>The output file names can be set with the following options:
    <tt>output-vector-file</tt>, <tt>output-scalar-file</tt> and <tt>snapshot-file</tt>.
</ul>

<p>It is important to note, that the loaded NED files may contain
any number of modules, channel and <i>any number of networks</i> as well.
It does not matter whether you use all or just some of them
in the simulations. You will be able to select <tt>any</tt> of the
networks that occur in the loaded NED files using the <tt>network=</tt>
<tt>omnetpp.ini</tt> entry, and as long as every module, channel etc
for it has been loaded, network setup will be successful.

<p>
<H2><A NAME="sec307"/>8.7 Setting module parameters in omnetpp.ini</H2>
<a name="sec:ch-run-sim:parameter-settings"></a>

<p>Simulations get input via module parameters, which can be assigned a
value in NED files or in <tt>omnetpp.ini</tt> -- in this order. Since parameters
assigned in NED files cannot be overridden in omnetpp.ini, one can
think about them as being ``hardcoded''. In contrast, it is easier
and more flexible to maintain module parameter settings in omnetpp.ini.

<p>In omnetpp.ini, module parameters are referred to by their full paths
or hiearchical names. This name consists of the dot-separated list of
the module names (from the top-level module down to the module containg
the parameter), plus the parameter name
(see section <a href="#sec228">[6.1.5]</a>).

<p>An example <tt>omnetpp.ini</tt> which sets the <tt>numHosts</tt> parameter of
the toplevel module and the <tt>transactionsPerSecond</tt> parameter of the
<tt>server</tt> module:

<pre>
[Parameters]
net.numHosts = 15
net.server.transactionsPerSecond = 100
</pre>
<p>

<p><H3><A NAME="sec308"/>8.7.1 Using wildcard patterns</H3>
<a name="sec:ch-run-sim:wildcards"></a>

<p>Models can have a large number of parameters to be configured, and it would
be tedious to set them one-by-one in <tt>omnetpp.ini</tt>. OMNeT++ supports
<i>wildcards patterns</i> which allow for setting several model parameters
at once.

<p>The notation is a variation on the usual glob-style patterns.
The most apperent differences to the usual rules are the distinction between
<tt>*</tt> and <tt>**</tt>, and that character ranges should be written
with curly braces instead of square brackets (that is, <i>any-letter</i>
is <tt>{a-zA-Z}</tt> not <tt>[a-zA-Z]</tt>, because square brackets are
already reserved for the notation of module vector indices).

<p>Pattern syntax:

<p><ul>
  <li> <tt>?</tt> : matches any character except dot (.)
  <li> <tt>*</tt> : matches zero or more characters except dot (.)
  <li> <tt>**</tt> : matches zero or more character (any character)
  <li> <tt>{a-f}</tt> : <i>set</i>: matches a character in the range a-f
  <li> <tt>{^a-f}</tt>: <i>negated set</i>: matches a character
    NOT in the range a-f
  <li> <tt>{38..150}</tt> : <i>numeric range</i>: any number (i.e. sequence of digits)
    in the range 38..150  (e.g. <tt>99</tt>)
  <li> <tt>[38..150]</tt> : <i>index range</i>: any number in square brackets in the
    range 38..150 (e.g. <tt>[99]</tt>)
  <li> backslash (\) : takes away the special meaning of the
    subsequent character
</ul>

<p><p class="subheading">Precedence</p>

<p>If you use wildcards, the order of entries is important: if a parameter
name matches several wildcards-patterns, the <i>first</i> matching occurrence
is used. This means that you need to list specific settings first, and
more general ones later. Catch-all settings should come last.

<p>An example ini file:

<pre>
[Parameters]
*.host[0].waitTime = 5ms   # specifics come first
*.host[3].waitTime = 6ms
*.host[*].waitTime = 10ms  # catch-all comes last
</pre>
<p>

<p><p class="subheading">Asterisk vs double asterisk</p>

<p>The <tt>*</tt> wildcard is for matching a single module or parameter name in the
path name, while <tt>**</tt> can be used to match several components in the path.
For example, <tt>**.queue*.bufSize</tt> matches the <tt>bufSize</tt> parameter of any module
whose name begins with <tt>queue</tt> in the model, while <tt>*.queue*.bufSize</tt>
or <tt>net.queue*.bufSize</tt> selects only queues immediately on network level.
Also note that <tt>**.queue**.bufSize</tt> would match <tt>net.queue1.foo.bar.bufSize</tt>
as well!

<p><p class="subheading">Sets, negated sets</p>

<p>Sets and negated sets can contain several character ranges and also
enumeration of characters. For example, <tt>{_a-zA-Z0-9}</tt> matches any letter
or digit, plus the underscore; <tt>{xyzc-f}</tt> matches any of the characters
x, y, z, c, d, e, f.
To include '-' in the set, put it at a position where it cannot be
interpreted as character range, for example: <tt>{a-z-}</tt> or <tt>{-a-z}</tt>.
If you want to include '}' in the set, it must be the first
character: <tt>{}a-z}</tt>, or as a negated set: <tt>{^}a-z}</tt>. A backslash
is always taken as literal backslash (and NOT as escape character)
within set definitions.

<p>
<p class="subheading">Numeric ranges and index ranges</p>

<p>Only nonnegative integers can be matched.  The start or the end of the range
(or both) can be omitted: <tt>{10..}</tt>, <tt>{..99}</tt> or <tt>{..}</tt>
are valid numeric ranges (the last one matches any number).
The specification must use exactly two dots.
Caveat: <tt>*{17..19}</tt> will match <tt>a17</tt>, <tt>117</tt> and <tt>963217</tt> as well,
because the <tt>*</tt> can also match digits!

<p>An example for numeric ranges:

<pre>
[Parameters]
*.*.queue[3..5].bufSize = 10
*.*.queue[12..].bufSize = 18
*.*.queue[*].bufSize = 6  # this will only affect queues 0,1,2 and 6..11
</pre>
<p>

<p><H3><A NAME="sec309"/>8.7.2 Applying the defaults</H3>

<p>It is also possible to utilize the default values specifified with
<tt>input(</tt><i>default-value</i><tt>)</tt> in the NED files.
The <i>&lt;parameter-name&gt;</i><tt>.use-default=yes</tt> setting assigns
the default value to the parameter, or 0, false or empty string if
there was no default value in the NED file.

<p>The following example sets <tt>ttl</tt> (time-to-live) of <tt>hostA</tt>'s
<tt>ip</tt> module to 5, while all other nodes in the network
will get the default specified with <tt>input()</tt> in the NED files.

<p><pre>
[Parameters]
**.hostA.ip.ttl = 5
**.ip.ttl.use-default = yes
</pre>

<p>To make use of <i>all</i> defaults in NED files, you'd add the following to
<tt>omnetpp.ini</tt>:

<pre>
[Parameters]
**.use-default = yes
</pre>
<p>

<p><H2><A NAME="sec310"/>8.8 Configuring output vectors</H2>
<a name="sec:ch-run-sim:outvectors"></a>

<p>As a simulation program is evolving, it is becoming capable of
collecting more and more statistics. The size of output vector
files<!--output!vector file--> can easily reach a magnitude of
several ten or hundred megabytes, but very often, only some of the
recorded statistics are interesting to the analyst.

<p>In OMNeT++, you can control how <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects record data
to disk. You can turn output vectors on/off or you can assign a result
collection interval. Output vector configuration is given in the
<tt>[OutVectors]</tt> section of the ini file, or in the <tt>[Run
  1]</tt>, <tt>[Run 2]</tt> etc sections individually for each run. By
default, all output vectors are turned on.

<p>Output vectors can be configured with the following syntax:

<p><pre>
<i>module-pathname</i>.<i>objectname</i>.enabled = yes/no
<i>module-pathname</i>.<i>objectname</i>.interval = <i>start</i>..<i>stop</i>
<i>module-pathname</i>.<i>objectname</i>.interval = ..<i>stop</i>
<i>module-pathname</i>.<i>objectname</i>.interval = <i>start</i>..
</pre>

<p>The object name is the string passed to <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> in its constructor
or with the <tt>setName()</tt> member function.

<pre>
<a href="../api/classcOutVector.html">cOutVector</a> eed("End-to-End Delay");
</pre>
<p>
Start and stop values can be any time specification accepted
in NED and config files (e.g. <i>10h 30m 45.2s</i>).

<p>As with parameter names, wildcards are allowed in the object
names and module path names.

<p>An example:

<pre>
#
# omnetpp.ini
#

[OutVectors]
**.interval = 1s..60s
**.End-to-End Delay.enabled = yes
**.Router2.**.enabled = yes
**.enabled = no
</pre>
<p>

<p>The above configuration limits collection of all output vectors
to the 1s..60s interval, and disables collection of output vectors
except all end-to-end delays and the ones in any module called Router2.

<p>
<H2><A NAME="sec311"/>8.9 Configuring the random number generators</H2>
<a name="sec:ch-run-sim:rng-config"></a>

<p>The random number architecture of OMNeT++ was already outlined
in section <a href="#sec234">[6.4]</a>. Here
we'll cover the configuration of RNGs in <tt>omnetpp.ini</tt>.

<p><H3><A NAME="sec312"/>8.9.1 Number of RNGs</H3>

<p>The <tt>num-rngs=</tt> configuration entry sets the number of
random number generator instances (i.e. random number streams)
available for the simulation model (see <a href="#sec234">[6.4]</a>).
Referencing an RNG number greater or equal to this number
(from a simple module or NED file) will cause a runtime error.

<p>
<H3><A NAME="sec313"/>8.9.2 RNG choice</H3>

<p>The <tt>rng-class=</tt> configuration entry sets the random number
generator class to be used. It defaults to <tt>"<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>"</tt>,
the Mersenne Twister RNG. Other available classes are <tt>"<a href="../api/classcLCG32.html">cLCG32</a>"</tt>
(the "legacy" RNG of OMNeT++ 2.3 and earlier versions, with a cycle length
of <i>2<sup>31</sup>-2</i>), and <tt>"cAkaroaRNG"</tt> (Akaroa's random number generator,
see section <a href="#sec329">[8.13]</a>).

<p><H3><A NAME="sec314"/>8.9.3 RNG mapping</H3>

<p>The RNG numbers used in simple modules may be arbitrarily mapped to the
actual random number streams (actual RNG instances) from <tt>omnetpp.ini</tt>.
The mapping allows for great flexibility in RNG usage and random number
streams configuration -- even for simulation models which were not
written with RNG awareness.

<p>RNG mapping may be specified in <tt>omnetpp.ini</tt>. The syntax of
configuration entries is the following.

<pre>
[General]
&lt;modulepath&gt;.rng-N=M  (where N,M are numeric, M&lt;num-rngs)
</pre>
<p>
This maps module-local RNG N to physical RNG M. The following
example maps all  <tt>gen</tt> module's default (N=0) RNG to physical RNG 1,
and all  <tt>noisychannel</tt> module's default (N=0) RNG to physical RNG 2.

<pre>
[General]
num-rngs = 3
**.gen[*].rng-0 = 1
**.noisychannel[*].rng-0 = 2
</pre>
<p>
This mapping allows variance reduction techniques to be applied to
OMNeT++ models, without any model change or recompilation.

<p>
<H3><A NAME="sec315"/>8.9.4 Automatic seed selection</H3>

<p>Automatic seed selection gets used for an RNG if you don't explicitly
specify seeds in omnetpp.ini. Automatic and manual seed selection can
co-exist: for a particular simulation, some RNGs can be configured
manually, and some automatically.

<p>The automatic seed selection mechanism uses two inputs: the <i>run number</i>
(i.e. the number in the <tt>[Run 1]</tt>, <tt>[Run 2]</tt>, etc. section names),
and the <i>RNG number</i>. For the same the run number and RNG number,
OMNeT++ always selects the same seed value for any simulation model.
If the run number or the RNG number is different, OMNeT++ does its best
to choose different seeds which are also sufficiently apart in the RNG's sequence
so that the generated sequences don't overlap.

<p>The run number can be specified either in in omnetpp.ini (e.g. via the
<tt>[Cmdenv]/runs-to-execute=</tt> entry) or on the command line:

<pre>
./mysim -r 1
./mysim -r 2
./mysim -r 3
</pre>
<p>
For the <tt><a href="../api/classcMersenneTwister.html">cMersenneTwister</a></tt> random number generator, selecting seeds
so that the generated sequences don't overlap is easy,
due to the extremely long sequence of the RNG.
The RNG is initialized from the 32-bit seed value <i>seed = runNumber*numRngs + rngNumber</i>.
(This implies that simulation runs participating in the study should have
the same number of RNGs set).
    <br><ul><font size=-1>[While (to our knowledge) no one has proven that the seeds 0,1,2,...
    are well apart in the sequence, this is probably true, due to the extremely
    long sequence of MT. The author would however be interested in papers
    published about seed selection for MT.]</font></ul>

<p>For the <tt><a href="../api/classcLCG32.html">cLCG32</a></tt> random number generator, the situation is more difficult,
because the range of this RNG is rather short (<i>2<sup>31</sup>-1</i>, about 2 billion).
For this RNG, OMNeT++ uses a table of 256 pre-generated seeds, equally spaced
in the RNG's sequence. Index into the table is calculated with the
<i>runNumber*numRngs + rngNumber</i> formula. Care should be taken that
one doesn't exceed 256 with the index, or it will wrap and the
same seeds will be used again. It is best not to use the <tt><a href="../api/classcLCG32.html">cLCG32</a></tt>
at all -- <tt><a href="../api/classcMersenneTwister.html">cMersenneTwister</a></tt> is superior in every respect.

<p>
<H3><A NAME="sec316"/>8.9.5 Manual seed configuration</H3>

<p>In some cases you may want manually configure seed values.
Reasons for doing that may be that you want to use variance reduction
techniques, or you may want to use the same seeds for several simulation
runs.

<p>For the <a href="../api/classcLCG32.html">cLCG32</a> RNG, OMNeT++ provides a standalone program to generate
seed values (<tt>seedtool</tt> is discussed in section
<a href="#sec317">[8.9.6]</a>), and you can specify those seeds explicitly
in the ini file.

<p>The following ini file explicitly initializes two of the random
number generators, and uses different seed values for each run:

<pre>
[General]
rng-class=<a href="../api/classcLCG32.html">cLCG32</a>  # needed because the default is <a href="../api/classcMersenneTwister.html">cMersenneTwister</a>
num-rngs = 2

[Run 1]
seed-0-lcg32 = 1768507984
seed-1-lcg32 = 33648008

[Run 2]
seed-0-lcg32 = 1082809519
seed-1-lcg32 = 703931312
...
</pre>
<p>
To manually set seeds for the Mersenne Twister RNG (which should
seldom, if ever, be necessary), use the <tt>seed-0-mt=</tt>,
<tt>seed-1-mt=</tt>, etc settings:

<pre>
[General]
num-rngs = 2

[Run 1]
seed-0-mt = 1317366363
seed-1-mt = 1453732904

[Run 2]
...
</pre>
<p>
To set a seed value for all runs, place the necessary seed entries
into the <tt>[General]</tt> section.

<p>
<H3><A NAME="sec317"/>8.9.6 Choosing good seed values: the seedtool utility</H3>
<a name="sec:ch-run-sim:seedtool"></a>

<p>The <tt>seedtool</tt> program can be used for selecting
seeds for the <a href="../api/classcLCG32.html">cLCG32</a> RNG. When started without command-line
arguments, the program prints out the following help:

<pre>
seedtool - part of OMNeT++/OMNEST, (C) 1992-2004 Andras Varga
See the license for distribution terms and warranty disclaimer.

Generates seeds for the LCG32 random number generator. This RNG has a
period length of 2^31-2, which makes about 2,147 million random numbers.
Note that Mersenne Twister is also available in OMNeT++, which has a
practically infinite period length (2^19937).

Usage:
  seedtool i seed         - index of 'seed' in cycle
  seedtool s index        - seed at index 'index' in cycle
  seedtool d seed1 seed2  - distance of 'seed1' and 'seed2' in cycle
  seedtool g seed0 dist   - generate seed 'dist' away from 'seed0'
  seedtool g seed0 dist n - generate 'n' seeds 'dist' apart, starting at 'seed0'
  seedtool t              - generate hashtable
  seedtool p              - print hashtable
</pre>
<p>

<p>The last two options, p and t were used internally to generate
a hash table of pre-computed seeds that greatly speeds up the
tool. For practical use, the g option is the most important.
Suppose you have 4 simulation runs that need two independent
random number generators each and you want to start their seeds
at least 10,000,000 values apart. The first seed value can be
simply 1. You would type the following command:

<pre>
C:\OMNETPP\UTILS&gt; seedtool g 1 10000000 8
</pre>
<p>

<p>The program outputs 8 numbers that can be used as random number
seeds:

<pre>
1768507984
33648008
1082809519
703931312
1856610745
784675296
426676692
1100642647
</pre>
<p>

<p>You would specify these seed values in the ini file.

<p>

<p><H2><A NAME="sec318"/>8.10 Cmdenv: the command-line interface</H2>

<p>The command line user interface<!--command line user interface--> is
a small, portable and fast user interface that compiles and runs on
all platforms. Cmdenv<!--Cmdenv--> is designed primarily for batch execution.

<p>Cmdenv uses simply executes some or all simulation runs that are described
in the configuration file. If one run stops with an error message,
subsequent ones will still be executed. The runs to be executed can be
passed via command-line argument or in the ini file.

<p><H3><A NAME="sec319"/>8.10.1 Command-line switches</H3>

<p>A simulation program built with Cmdenv accepts the following command line
switches<!--command line switches-->:

<p><table>
<TR> <TD align=left>   <tt>-h</tt>
  </TD> <TD align=left>
  The program prints a short help message and the networks
  contained in the executable, then exits.</TD></TR>
<TR> <TD align=left>
  <tt>-f</tt> <tt>&lt;</tt><i>fileName<tt>&gt;</tt></i>
  </TD> <TD align=left>
  Specify the name of the configuration file.
  The default is <tt>omnetpp.ini</tt><!--omnetpp.ini-->.
  Multiple <tt>-f</tt> switches can be given; this allows you to partition your
  configuration file.  For example, one file can contain your general
  settings, another one most of the module parameters, another one the
  module parameters you change often.</TD></TR>
<TR> <TD align=left>
  <tt>-l</tt> <tt>&lt;</tt><i>fileName<tt>&gt;</tt></i>
  </TD> <TD align=left>
  Load a shared object<!--shared objects--> (<tt>.so</tt> file on Unix).
  Multiple <tt>-l</tt> switches are accepted. Your <tt>.so</tt> files may contain module
  code etc. By dynamically loading all simple
  module code and compiled network description (<tt>_n.o</tt> files
  on Unix) you can even eliminate the need to re-link the simulation
  program after each change in a source file.  (Shared objects can be
  created with <tt>gcc -shared...</tt>)</TD></TR>
<TR> <TD align=left>
  <tt>-r</tt> <tt>&lt;</tt><i>runs<tt>&gt;</tt></i>
  </TD> <TD align=left>
  It specifies which runs should be executed (e.g. <tt>-r 2,4,6-8</tt>).
  This option overrides the <tt>runs-to-execute=</tt> option
  in the <tt>[Cmdenv]</tt> section of the ini file<!--ini file-->
  (see later).</TD></TR>
</table>

<p>All other options are read from the configuration file.

<p>An example of running an OMNeT++ executable with the -h flag:

<pre>
% ./fddi -h

OMNeT++/OMNEST Discrete Event Simulation  (C) 1992-2005 Andras Varga
See the license for distribution terms and warranty disclaimer
Setting up Tkenv...

Command line options:
  -h            Print this help and exit.
  -f &lt;inifile&gt;  Use the given ini file instead of omnetpp.ini. Multiple
                -f options are accepted to load several ini files.
  -u &lt;ui&gt;       Selects the user interface. Standard choices are Cmdenv
                and Tkenv. To make a user interface available, you need
                to link the simulation executable with the cmdenv/tkenv
                library, or load it as shared library via the -l option.
  -l &lt;library&gt;  Load the specified shared library (.so or .dll) on startup.
                The file name should be given without the .so or .dll suffix
                (it will be appended automatically.) The loaded module may
                contain simple modules, plugins, etc. Multiple -l options
                can be present.

Tkenv-specific options:
  -r &lt;run&gt;      Set up the given run, specified in a [Run n] section of
                the ini file.

The following components are available:
  module types:
    FDDI_Monitor
    FDDI_Generator4Sniffer
    FDDI_Generator4Ring
    ...

End run of OMNeT++
</pre>
<p>

<p><H3><A NAME="sec320"/>8.10.2 Cmdenv ini file options</H3>
<a name="sec:ch-run-sim:cmdenv-section"></a>

<p>Cmdenv can be executed in two modes, selected by the <tt>express-mode</tt> ini file entry:

<p><ul>
    <li> <b>Normal</b> (non-express) mode is for debugging: detailed information
        will be written to the standard output (event banners, module output,
        etc).
    <li> <b>Express</b> mode can be used for long simulation runs: only
        periodical status update is displayed about the progress of the
        simulation.
</ul>

<p>The full list of ini file options recognized by Cmdenv:

<p><table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=left colspan=2><b>[Cmdenv]</b></TD></TR>
<TR> <TD align=left> <tt>runs-to-execute</tt> = </TD> <TD align=left> Specifies which simulation runs should be executed.
It accepts a comma-separated list of run numbers or run number ranges, e.g.
<tt>1,3-4,7-9</tt>. If the value is missing, Cmdenv executes all runs that have
ini file sections; if no runs are specified in the ini file, Cmdenv does one run.
The -r command line option overrides this ini file setting. </TD></TR>
<TR> <TD align=left> <tt>express-mode</tt>=yes/no (default: no) </TD> <TD align=left> Selects ``normal'' (debug/trace) or ``express'' mode.
</TD></TR>
<TR> <TD align=left> <tt>module-messages</tt>=yes/no (default: yes) </TD> <TD align=left> In normal mode only:
printing module ev&lt;&lt; output on/off </TD></TR>
<TR> <TD align=left> <tt>event-banners</tt>=yes/no (default: yes) </TD> <TD align=left> In normal mode only:
printing event banners on/off </TD></TR>
<TR> <TD align=left> <tt>message-trace</tt>=yes/no (default: no) </TD> <TD align=left> In normal mode only: print a line
about each message sending (by <tt>send()</tt>,<tt>scheduleAt()</tt>, etc)
and delivery on the standard output </TD></TR>
<TR> <TD align=left> <tt>autoflush</tt>=yes/no (default: no) </TD> <TD align=left>  Call <tt>fflush(stdout)</tt> after each
event banner or status update; affects both express and normal mode. Turning on
autoflush can be useful with printf-style debugging for tracking down
program crashes. </TD></TR>
<TR> <TD align=left> <tt>status-frequency</tt>=&lt;integer&gt; (default: 50000) </TD> <TD align=left> In express mode only:
print status update every n events (on today's computers, and
for a typical model, this will produce an update every few seconds,
perhaps a few times per second) </TD></TR>
<TR> <TD align=left> <tt>performance-display</tt>=yes/no (default: yes) </TD> <TD align=left> In express mode only:
print detailed performance information. Turning it on results in a 3-line
entry printed on each update, containing ev/sec, simsec/sec, ev/simsec,
number of messages created/still present/currently scheduled in FES<!--FES-->.
</TD></TR>
<TR> <TD align=left> <tt>extra-stack-kb</tt> = 8 </TD> <TD align=left> Specifies the extra amount of stack
(in kilobytes) that is reserved for each <tt>activity()</tt>
simple module when the simulation is run under Cmdenv.</TD></TR>
</table>

<p>
<H3><A NAME="sec321"/>8.10.3 Interpreting Cmdenv output</H3>
<a name="sec:ch-run-sim:interpreting-cmdenv-output"></a>

<p>When the simulation is running in ``express'' mode with detailed
performance display enabled, Cmdenv periodically outputs a three-line
status info about the progress of the simulation.
The output looks like this:

<pre>
...
** Event #250000   T=123.74354 ( 2m  3s)    Elapsed: 0m 12s
     Speed:     ev/sec=19731.6   simsec/sec=9.80713   ev/simsec=2011.97
     Messages:  created: 55532   present: 6553   in FES: 8
** Event #300000   T=148.55496 ( 2m 28s)    Elapsed: 0m 15s
     Speed:     ev/sec=19584.8   simsec/sec=9.64698   ev/simsec=2030.15
     Messages:  created: 66605   present: 7815   in FES: 7
...
</pre>
<p>
The first line of the status display (beginning with <tt>**</tt>)
contains:

<p><ul>
   <li>how many events have been processed so far
   <li>the current simulation time (T), and
   <li>the elapsed time (wall clock time) since the beginning of the simulation run.
</ul>

<p>The second line displays info about simulation performance:

<p><ul>
   <li><tt>ev/sec</tt> indicates <i>performance</i>: how many events are processed
     in one real-time second.  On one hand it depends on your hardware
     (faster CPUs process more events per second), and on the other hand
     it depends on the complexity (amount of calculations) associated
     with processing one event. For example, protocol simulations tend to require
     more processing per event than e.g. queueing networks, thus
     the latter produce higher ev/sec values.
     In any case, this value is independent of the size (number of modules) in your model.
   <li><tt>simsec/sec</tt> shows <i>relative speed</i> of the simulation, that is,
     how fast the simulation is progressing compared to real time, how many
     simulated seconds can be done in one real second. This value virtuall depends
     on everything: on the hardware, on the size of the simulation model,
     on the complexity of events, and the average simulation time between events as well.
   <li><tt>ev/simsec</tt> is the <i>event density</i>: how many events are
     there per simulated second. Event density only depends on the simulation model,
     regardless of the hardware used to simulate it: in a cell-level ATM simulation
     you'll have very hight values (<i>10<sup>9</sup></i>), while in a bank teller simulation
     this value is probably well under 1. It also depends on the size of your
     model: if you double the number of modules in your model, you can expect
     the event density double, too.
</ul>

<p>The third line displays the number of messages, and it is important
because it may indicate the `health' of your simulation.

<p><ul>
   <li><tt>Created</tt>: total number of message objects created since the
     beginning of the simulation run. This does not mean that this many message
     object actually exist, because some (many) of them may have been deleted
     since then. It also does not mean that <i>you</i> created all those
     messages -- the simulation kernel also creates messages for its own use
     (e.g. to implement <tt>wait()</tt> in an <tt>activity()</tt> simple module).
   <li><tt>Present</tt>: the number of message objects currently present
     in the simulation model, that is, the number of messages created (see above)
     minus the number of messages already deleted. This number includes
     the messages in the FES<!--FES-->.
   <li><tt>In FES</tt>: the number of messages currently scheduled in the
     Future Event Set.
</ul>

<p>
The second value, the number of messages present is more useful than
perhaps one would initially think. It can indicator of the `health' of the simulation:
if it is growing steadily, then either you have a memory leak and losing
messages (which indicates a programming error), or the network you simulate is
overloaded and queues are steadily filling up (which might indicate wrong input
parameters).

<p>Of course, if the number of messages does not increase, it does not mean
that you do <i>not</i> have a memory leak (other memory leaks are also
possible). Nevertheless the value is still useful, because by far the
most common way of leaking memory in a simulation is by not deleting messages.

<p>

<p><H2><A NAME="sec322"/>8.11 Tkenv: the graphical user interface</H2>

<p><p class="subheading">Features</p>

<p>Tkenv<!--Tkenv--> is a portable graphical windowing user interface.
Tkenv supports interactive execution of the simulation, tracing and
debugging<!--simulation!debugging-->. Tkenv is recommended in the
development stage of a simulation or for presentation and educational
purposes, since it allows one to get a detailed picture of the state
of simulation at any point of execution and to follow what happens
inside the network.

<p><H3><A NAME="sec323"/>8.11.1 Command-line switches</H3>

<p>A simulation program built with Tkenv accepts the following command line
switches<!--command line switches-->:

<p><table>
<TR> <TD align=left>   <tt>-h</tt>
  </TD> <TD align=left>
  The program prints a short help message and the networks
  contained in the executable, then exits.</TD></TR>
<TR> <TD align=left>
  <tt>-f </tt><i>&lt;fileName&gt;</i>
  </TD> <TD align=left>
  Specify the name of the configuration file.
  The default is <tt>omnetpp.ini</tt><!--omnetpp.ini-->.
  Multiple <tt>-f</tt> switches can be given; this allows you to partition your
  configuration file.  For example, one file can contain your general
  settings, another one most of the module parameters, another one the
  module parameters you change often.</TD></TR>
<TR> <TD align=left>
  <tt>-l </tt><i>&lt;fileName&gt;</i>
  </TD> <TD align=left>
  Load a shared object<!--shared objects--> (<tt>.so</tt> file on Unix).
  Multiple <tt>-l</tt> switches are accepted. Your <tt>.so</tt> files may contain module
  code etc. By dynamically loading all simple
  module code and compiled network description (<tt>_n.o</tt> files
  on Unix) you can even eliminate the need to re-link the simulation
  program after each change in a source file.  (Shared objects can be
  created with <tt>gcc -shared...</tt>)</TD></TR>
<TR> <TD align=left>
  <tt>-r </tt><i>&lt;run-number&gt;</i>
  </TD> <TD align=left>
  It has the same effect as (but takes priority over) the <tt>[Tkenv]/default-run=</tt>
  ini file entry.

<p></table>

<p><H3><A NAME="sec324"/>8.11.2 In Memoriam... </H3>

<p>There used to be other windowing user interfaces which have been removed
from the distribution:

<p><ul>
  <li> <b>TVEnv</b>. A Turbo Vision-based user interface, the first
    interactive UI for OMNeT++. Turbo Vision was an excellent
    character-graphical windowing environment, originally shipped with
    Borland C++ 3.1.
  <li> <b>XEnv</b>. A GUI written in pure X/Motif. It was an
    experiment, written before I stumbled into Tcl/Tk and discovered
    its immense productivity in GUI building. XEnv never got too far
    because it was really very-very slow to program in Motif...
</ul>

<p>
<H2><A NAME="sec325"/>8.12 Repeating or iterating simulation runs</H2>

<p>Once your model works reliably, you'll usually want to run several
simulations. You may want to run the model with various
parameter settings, or you may want <i>(should want?)</i> to
run the same model with the same parameter settings but with
different random number generator seeds, to achieve statistically
more reliable results.

<p>Running a simulation several times by hand can easily become tedious,
and then a good solution is to write a control script that
takes care of the task automatically. Unix shell is
a natural language choice to write the control script in,
but other languages like Perl, Matlab/Octave, Tcl, Ruby might also have
justification for this purpose.

<p>The next sections are only for Unix users. We'll use the
Unix `Bourne' shell (<tt>sh</tt>, <tt>bash</tt>) to write the control script.
If you'd prefer Matlab/Octave, the <tt>contrib/octave/</tt> directory
contains example scripts (contributed by Richard Lyon).

<p>
<H3><A NAME="sec326"/>8.12.1 Executing several runs</H3>

<p>In simple cases, you may define all simulation runs needed in the
<tt>[Run 1]</tt>, <tt>[Run 2]</tt>, etc. sections of <tt>omnetpp.ini</tt>,
and invoke your simulation with the -r flag each time.
The -f flag lets you use a file name different from <tt>omnetpp.ini</tt>.

<p>The following script executes a simulation named <tt>wireless</tt>
several times, with parameters for the different runs
given in the <tt>runs.ini</tt> file.

<pre>
#! /bin/sh
./wireless -f runs.ini -r 1
./wireless -f runs.ini -r 2
./wireless -f runs.ini -r 3
./wireless -f runs.ini -r 4
...
./wireless -f runs.ini -r 10
</pre>
<p>
To run the above script, type it in a text file called e.g. <tt>run</tt>,
give it <tt>x</tt> (executable) permission using <tt>chmod</tt>,
then you can execute it by typing <tt>./run</tt>:

<pre>
% chmod +x run
% ./run
</pre>
<p>
You can simplify the above script by using a <i>for</i> loop.
In the example below, the variable <tt>i</tt> iterates through
the values of list given after the <tt>in</tt> keyword.
It is very practical, since you can leave out or add runs,
or change the order of runs by simply editing the list --
to demonstrate this, we skip run 6, and include run 15 instead.

<pre>
#! /bin/sh
for i in 3 2 1 4 5 7 15 8 9 10; do
   ./wireless -f runs.ini -r $i
done
</pre>
<p>
If you have many runs, you can use a C-style loop:

<pre>
#! /bin/sh
for ((i=1; $i&lt;50; i++)); do
   ./wireless -f runs.ini -r $i
done
</pre>
<p>

<p><H3><A NAME="sec327"/>8.12.2 Variations over parameter values</H3>

<p>It may not be practical to hand-write descriptions of all runs
in an ini file, especially if there are many parameter
settings to try, or you want to try all possible
combinations of two or more parameters.
The solution might be to generate only a small fraction
of the ini file with the variable parameters, and
use it via ini file inclusion. For example, you might
write your <tt>omnetpp.ini</tt> like this:

<pre>
[General]
network = Wireless

[Parameters]
Wireless.n = 10
...   # other fixed parameters
include params.ini  # include variable part
</pre>
<p>
And have the following as control script. It uses two nested loops to explore
all possible combinations of the <i>alpha</i> and <i>beta</i> parameters.
Note that <tt>params.ini</tt> is created by redirecting the <tt>echo</tt>
output into file, using the <tt>&gt;</tt> and <tt>&gt;&gt;</tt> operators.

<pre>
#! /bin/sh
for alpha in 1 2 5 10 20 50; do
   for beta in 0.1 0.2 0.3 0.4 0.5; do
       echo "Wireless.alpha=$alpha" &gt; params.ini
       echo "Wireless.beta=$beta" &gt;&gt; params.ini
       ./wireless
   done
done
</pre>
<p>

<p>As a heavy-weight example, here's the ``runall'' script of
Joel Sherrill's <i>File System Simulator</i>. It also demonstrates
that loops can iterate over string values too, not just numbers.
(<tt>omnetpp.ini</tt> includes the generated <tt>algorithms.ini</tt>.)

<p>Note that instead of redirecting every <tt>echo</tt> command to file,
they are grouped using parentheses, and redirected together.
The net effect is the same, but you can spare some typing this way.

<pre>
#! /bin/bash
#
# This script runs multiple variations of the file system simulator.
#
all_cache_managers="NoCache FIFOCache LRUCache PriorityLRUCache..."
all_schedulers="FIFOScheduler SSTFScheduler CScanScheduler..."

for c in ${all_cache_managers}; do
  for s in ${all_schedulers}; do
  (
    echo "[Parameters]"
    echo "filesystem.generator_type = \"GenerateFromFile\""
    echo "filesystem.iolibrary_type = \"PassThroughIOLibrary\""
    echo "filesystem.syscalliface_type = \"PassThroughSysCallIface\""
    echo "filesystem.filesystem_type = \"PassThroughFileSystem\""
    echo "filesystem.cache_type = \"${c}\""
    echo "filesystem.blocktranslator_type = \"NoTranslation\""
    echo "filesystem.diskscheduler_type = \"${s}\""
    echo "filesystem.accessmanager_type = \"MutexAccessManager\""
    echo "filesystem.physicaldisk_type = \"HP97560Disk\""
  ) &gt;algorithms.ini

  ./filesystem
  done
done
</pre>
<p>

<p>
<H3><A NAME="sec328"/>8.12.3 Variations over seed value (multiple independent runs)</H3>

<p>The same kind of control script can be used if you want to execute
several runs with different random seeds<!--random!seeds-->.
The following code does 500 runs with independent seeds.
(<tt>omnetpp.ini</tt> should include <tt>parameters.ini</tt>.)

<p>The seeds are 10 million numbers apart in the sequence (<tt>seedtool</tt>
parameter), so one run should not use more random numbers than this,
otherwise there will be overlaps in the sequences and the runs
will not be independent.

<pre>
#! /bin/sh
seedtool g 1 10000000 500 &gt; seeds.txt
for seed in `cat seeds.txt`; do
   (
     echo "[General]"
     echo "random-seed = ${seed}"
     echo "output-vector-file = xcube-${seed}.vec"
   ) &gt; parameters.ini
   ./xcube
done
</pre>
<p>

<p>

<p>
<H2><A NAME="sec329"/>8.13 Akaroa support: Multiple Replications in Parallel</H2>
<a name="sec:ch-run-sim:akaroa"></a>
<!--Akaroa-->
<!--Multiple Replications in Parallel-->

<p><H3><A NAME="sec330"/>8.13.1 Introduction</H3>

<p>Typical simulations are Monte-Carlo simulations: they use
(pseudo-)random numbers to drive the simulation model.
For the simulation to produce statistically reliable results,
one has to carefully consider the following:

<p><ul>
  <li>When is the initial transient over, when can we start
    collecting data? We usually do not want to include the
    initial transient when the simulation is still ``warming up.''
  <li>When can we stop the simulation? We want to wait long enough
    so that the statistics we are collecting can ``stabilize'',
    can reach the required sample size to be statistically trustable.
</ul>

<p>Neither questions are trivial to answer. One might just suggest
to wait ``very long'' or ``long enough''. However, this is neither
simple (how do you know what is ``long enough''?) nor practical
(even with today's high speed processors simulations of modest complexity
can take hours, and one may not afford multiplying runtimes by,
say, 10, ``just to be safe.'') If you need further convincing,
please read [<a href="#bib-Pawlikowsky02">Pawlikowsky02</a>] and be horrified.

<p>A possible solution is to look at the statistics while the simulation
is running, and decide at runtime when enough data have been
collected for the results to have reached the required accuracy.
One possible criterion is given by the confidence level,
more precisely, by its width relative to the mean.
But ex ante it is unknown how many observations have to be collected
to achieve this level -- it must be determined runtime.

<p>
<H3><A NAME="sec331"/>8.13.2 What is Akaroa</H3>

<p>Akaroa [<a href="#bib-Akaroa99">Akaroa99</a>] addresses the above problem.
According to its authors, Akaroa (Akaroa2) is a ``fully automated
simulation tool designed for running distributed stochastic simulations
in MRIP scenario'' in a cluster computing environment.

<p>MRIP stands for <i>Multiple Replications in Parallel</i>.
In MRIP, the computers of the cluster run independent replications
of the whole simulation process (i.e. with the same parameters but
different seed for the RNGs (random number generators)),
generating statistically equivalent streams of simulation output data.
These data streams are fed to a global data analyser responsible for
analysis of the final results and for stopping the simulation
when the results reach a satisfactory accuracy.

<p>The independent simulation processes run independently of one another
and continuously send their observations to the central analyser
and control process. This process <i>combines</i> the independent data streams,
and calculates from these observations an overall estimate of the mean value
of each parameter.
Akaroa2 decides by a given confidence level and precision
whether it has enough observations or not. When it judges that is
has enough observations it halts the simulation.

<p>If <i>n</i> processors are used, the needed simulation execution time
is usually <i>n</i> times smaller compared to a one-processor
simulation (the required number of observations are produced sooner).
Thus, the simulation would be sped up approximately in proportion
to the number of processors used and sometimes even more.

<p>Akaroa was designed at the University of Canterbury in Christchurch, New Zealand
and can be used free of charge for teaching and non-profit research activities.

<p>
<H3><A NAME="sec332"/>8.13.3 Using Akaroa with OMNeT++</H3>

<p><p class="subheading">Akaroa</p>

<p>Before the simulation can be run in parallel under Akaroa, you have to
start up the system:

<p><ul>
  <li>Start <tt>akmaster</tt> running in the background on some host.
  <li>On each host where you want to run a simulation engine,
     start <tt>akslave</tt> in the background.
</ul>

<p>Each <tt>akslave</tt> establishes a connection with the <tt>akmaster</tt>.

<p>Then you use <tt>akrun</tt> to start a simulation. <tt>akrun</tt> waits
for the simulation to complete, and writes a report of the results
to the standard output. The basic usage of the <tt>akrun</tt> command is:

<pre>
akrun -n num_hosts command [argument..]
</pre>
<p>
where <i>command</i> is the name of the simulation you want to start.
Parameters for Akaroa are read from the file named <tt>Akaroa</tt> in
the working directory. Collected data from the processes are
sent to the <tt>akmaster</tt> process, and when the required precision
has been reached, <tt>akmaster</tt> tells the simulation processes to
terminate. The results are written to the standard output.

<p>The above description is not detailed enough help you
set up and successfully use Akaroa -- for that you need to read the
Akaroa manual.

<p><p class="subheading">Configuring OMNeT++ for Akaroa</p>

<p>First of all, you have to compile OMNeT++ with Akaroa support enabled.

<p>The OMNeT++ simulation must be configured in <tt>omnetpp.ini</tt>
so that it passes the observations to Akaroa. The simulation model itself does
not need to be changed -- it continues to write
the observations into output vectors (<tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects,
see chapter <a href="#sec222">[6]</a>). You can place some of
the output vectors under Akaroa control.

<p>You need to add the following to <tt>omnetpp.ini</tt>:

<pre>
[General]
rng-class="cAkaroaRNG"
outputvectormanager-class="cAkOutputVectorManager"
</pre>
<p>
These lines cause the simulation to obtain random numbers from Akaroa,
and allows data written to selected output vectors to be passed to Akaroa's
global data analyser.
    <br><ul><font size=-1>[For more details on the plugin mechanism these settings make use of,
    see section <a href="#sec411">[14.5.3]</a>.]</font></ul>

<p>Akaroa's RNG is a Combined Multiple Recursive pseudorandom
number generator (CMRG) with a period of approximately <i>2<sup>191</sup></i>
random numbers, and provides a unique stream of random numbers
for every simulation engine. It is vital to obtain random numbers
from Akaroa: otherwise, all simulation processes would run with the same
RNG seeds, and produce exactly the same results!

<p>Then you need to specify which output vectors you want to
be under Akaroa control. By default, all output vectors are under Akaroa
control; the

<pre>
&lt;modulename&gt;.&lt;vectorname&gt;.akaroa=false
</pre>
<p>
setting can be used to make Akaroa ignore specific vectors.
You can use the <tt>*</tt>, <tt>**</tt> wildcards here (see
section <a href="#sec308">[8.7.1]</a>). For example,
if you only want a few vectors be placed under Akaroa,
you can use the following trick:

<pre>
&lt;modulename&gt;.&lt;vectorname1&gt;.akaroa=true
&lt;modulename&gt;.&lt;vectorname2&gt;.akaroa=true
...
**.*.akaroa=false  # catches everything not matched above
</pre>
<p>

<p><p class="subheading">Using shared file systems</p>
<a name="sec:run-sim:using-shared-filesystems"></a>

<p>It is usually practical to have the same physical disk mounted (e.g. via NFS or Samba)
on all computers in the cluster. However, because all OMNeT++ simulation
processes run with the same settings, they would overwrite each other's
output files (e.g. <tt>omnetpp.vec</tt>, <tt>omnetpp.sca</tt>).
Your can prevent this from happening using the
<tt>fname-append-host</tt> ini file entry:

<pre>
[General]
fname-append-host=yes
</pre>
<p>
When turned on, it appends the host name to the names of the output
files (output vector, output scalar, snapshot files).

<p>

<p><H2><A NAME="sec333"/>8.14 Typical issues</H2>

<p><H3><A NAME="sec334"/>8.14.1 Stack problems</H3>

<p><p class="subheading">``Stack violation (<i>FooModule</i> stack too small?) in module <i>bar.foo</i>''</p>
<!--stack!too small-->

<p>OMNeT++ detected that the module has used more stack space than it has
allocated. The solution is to increase the stack for that module type.
You can call the <tt>stackUsage()</tt> from <tt>finish()</tt> to find out
actually how much stack the module used.

<p>
<p class="subheading">``Error: Cannot allocate <i>nn</i> bytes stack for module <i>foo.bar''</i></p>

<p>The resolution depends on whether you are using OMNeT++ on Unix or on Windows.

<p><b>Unix.</b>
If you get the above message, you have to increase the total stack
size<!--stack!size--> (the sum of all coroutine stacks). You can do
so in <tt>omnetpp.ini</tt>:

<pre>
[General]
total-stack-kb = 2048 # 2MB
</pre>
<p>
There is no penalty if you set <tt>total-stack-kb</tt> too high. I
recommend to set it to a few K less than the maximum process stack
size allowed by the operating system (<tt>ulimit -s</tt>; see
next section).

<p>
<b>Windows.</b>
You need to set a <i>low</i> (!) ``reserved stack size''
in the linker options, for example 64K (/stack:65536 linker flag) will do.
The ``reserved stack size'' is an attribute in the Windows exe
files' internal header. It can be set from the linker, or with
the <tt>editbin</tt> Microsoft utility. You can use the <tt>opp_stacktool</tt>
program (which relies on another Microsoft utility called <tt>dumpbin</tt>)
to display reserved stack size for executables.

<p>You need a low reserved stack size because the Win32 Fiber API
which is the mechanism underlying <tt>activity()</tt> uses
this number as coroutine stack size, and with 1MB being the default,
it is easy to run out of the 2GB possible address space (2GB/1MB=2048).

<p>A more detailed explanation follows.
Each fiber has its own stack, by default 1MB (this is the ``reserved''
stack space -- i.e. reserved in the address space, but not the full
1MB is actually ``committed'', i.e. has physical memory assigned to it).
This means that a 2GB address space will run out after 2048 fibers,
which is way too few. (In practice, you won't even be able to create
this many fibers, because physical memory is also a limiting factor).
Therefore, the 1MB reserved stack size (RSS) must be set to a smaller
value: the coroutine stack size requested for the module, plus
the <tt>extra-stack-kb</tt> amount for Cmdenv/Tkenv -- which makes
about 16K with Cmdenv, and about 48K when using Tkenv.
Unfortunately, the CreateFiber() Win32 API doesn't allow the RSS to be
specified. The more advanced CreateFiberEx() API which accepts RSS as
parameter is unfortunately only available from Windows XP.

<p>The alternative is the stacksize parameter stored in the EXE header,
which can be set
via the STACKSIZE .def file parameter, via the /stack linker option,
or on an existing executable using the editbin /stack utility.
This parameter specifies a common RSS for the main program stack,
fiber and thread stacks. 64K should be enough. This is the way
simulation executable should be created: linked with the /stack:65536
option, or the /stack:65536 parameter applied using editbin later.
For example, after applying the editbin /stacksize:65536 command to
dyna.exe, I was able to successfully run the Dyna sample with 8000
Client modules on my Win2K PC with 256M RAM (that means about 12000
modules at runtime, including about 4000 dynamically created modules.)

<p>
<p class="subheading">``Segmentation fault''</p>

<p>On Unix, if you set the total stack size higher, you may get a
segmentation fault during network setup<!--segmentation fault--> (or
during execution if you use dynamically created modules) for exceeding
the operating system limit for maximum stack size. For example, in
Linux 2.4.x, the default stack limit is 8192K (that is, 8MB). The
<tt>ulimit</tt> shell command can be used to modify the
resource limits, and you can raise the allowed maximum stack size
up to 64M.

<pre>
$ ulimit -s 65500
$ ulimit -s
65500
</pre>
<p>
Further increase is only possible if you're root.
Resource limits are inherited by child processes.
The following sequence can be used under Linux to get a shell with
256M stack limit:

<pre>
$ su root
Password:
# ulimit -s 262144
# su andras
$ ulimit -s
262144
</pre>
<p>
If you do not want to go through the above process at each login, you
can change the limit in the PAM configuration files. In Redhat Linux
(maybe other systems too), add the following line to
<tt>/etc/pam.d/login</tt>:

<pre>
session    required    /lib/security/pam_limits.so
</pre>
<p>
and the following line to <tt>/etc/security/limits.conf</tt>:

<pre>
*    hard    stack    65536
</pre>
<p>
<p>
A more drastic solution is to recompile the kernel with a larger stack
limit. Edit <tt>/usr/src/linux/include/linux/sched.h</tt> and increase
<tt>_STK_LIM</tt> from <tt>(8*1024*1024)</tt> to <tt>(64*1024*1024)</tt>.
</p>

<p>Finally, it you're tight with memory, you can switch to Cmdenv. Tkenv
increases the stack size of each module by about 32K<!--stack!for
  Tkenv--> so that user interface code that is called from a
simple module's context can be safely executed.
Cmdenv does not need that much extra stack.

<p>
<p class="subheading">Eventually...</p>

<p>Once you get to the point where you have to adjust the total stack size
to get your program running,
you should probably consider transforming (some of) your <tt>activity()</tt>
simple modules to <tt>handleMessage()</tt>. <tt>activity()</tt> does not
scale well for large simulations.

<p>

<p><H3><A NAME="sec335"/>8.14.2 Memory leaks and crashes</H3>

<p>The most common problems in C++ are associated with memory allocation
(usage of <tt>new</tt> and <tt>delete</tt>):

<p><ul>
   <li><i>memory leaks,</i> that is, forgetting to delete objects
     or memory blocks no longer used;
   <li><i>crashes,</i> usually due to referring to an already deleted
     object or memory block, or trying to delete one for a second time;
   <li><i>heap corruption</i> (enventually leading to crash) due to
     overrunning allocated blocks, i.e. writing past the end of an allocated
     array.
</ul>

<p>By far the most common ways leaking memory in simulation programs
is by not deleting messages (<tt><a href="../api/classcMessage.html">cMessage</a></tt> objects or subclasses).
Both Tkenv and Cmdenv are able to display the number of messages
currently in the simulation,
see e.g. section <a href="#sec321">[8.10.3]</a>.
If you find that the number of messages is steadily increasing,
you need to find where the message objects are. You can do so
by selecting <i>Inspect|From list of all objects...</i> from
the Tkenv menu, and reviewing the list in the dialog that pops up.
(If the model is large, it may take a while for the dialog to appear.)

<p>If the number of messages is stable, it is still possible
you're leaking other <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based objects. You can
also find them using Tkenv's <i>Inspect|From list of all objects...</i>
function.

<p>If you're leaking non-<tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>-based objects or just
memory blocks (<tt>struct</tt>s, <tt>int</tt>/<tt>double</tt>/<tt>struct</tt> arrays,
etc, allocated by <tt>new</tt>), you cannot find them via Tkenv.
You'll probably need a specialized memory debugging tool like
the ones described below.

<p><p class="subheading">Memory debugging tools</p>

<p>If you suspect that you may have memory allocation problems
(crashes associated with double-deletion or accessing already
deleted block, or memory leaks), you can use specialized tools
to track them down.

<p>By far the most efficient, most robust and most versatile tool
is <i>Valgrind</i>, originally developed for debugging KDE.

<p>Other memory debuggers are <i>NJAMD</i>, <i>MemProf</i>,
<i>MPatrol</i>, <i>dmalloc</i> and <i>ElectricFence</i>.
Most of the above tools support tracking down memory leaks as well as
detecting double deletion, writing past the end of an allocated block, etc.

<p>A proven commercial tool <i>Rational Purify</i>. It has
a good reputation and proved its usefulness many times.

<p>
<H3><A NAME="sec336"/>8.14.3 Simulation executes slowly</H3>

<p>What can you do if the simulation executes much slower than you expect?
The best advice that can be given here is that you should
<b>use a good profiler</b> to find out how much time is spent in each
part of the program. Do not make the mistake of omitting this step,
thinking that you know "which part is slow"! Even for experienced
programmers, profiling session is all too often full of surprises.
It often turns out that lots of CPU time is spent in completely
innocent-looking statements, while the big and complex algorithm
doesn't take nearly as much time as expected. <i>Don't assume anything
-- profile before you optimize!</i>
    <br><ul><font size=-1>[And before blaming the simulation kernel for poor performance...]</font></ul>

<p>A really impressive profiler on Linux is the <i>Valgrind</i>-based
<i>callgrind</i>, and its visualizer <i>KCachegrind</i>.
Unfortunately it won't be ported to Windows anytime soon.
On Windows, you're out of luck -- commercial products may help, or,
port your simulation to Linux. The latter goes usually much smoother
than one would expect.

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec337"/>9 Network Graphics And Animation</H1>
<a name="cha:graphics"></a>

<p><H2><A NAME="sec338"/>9.1 Display strings</H2>
<a name="sec:ch-graphics:display-strings"></a>

<p><H3><A NAME="sec339"/>9.1.1 Display string syntax</H3>

<p>Display strings<!--display strings--> specify the arrangement and
appearance of modules in graphical user interfaces (currently only
Tkenv): they control how the objects (compound modules, their
submodules and connections) are displayed. Display strings occur in
NED description's <tt>display:</tt>
phrases.

<p>The display string format is a semicolon-separated list of tags.
Each tag consists of a key (usually one letter), an equal sign
and a comma-separated list of parameters, like:

<pre>
  "p=100,100;b=60,10,rect;o=blue,black,2"
</pre>
<p>
Parameters may be omitted also at the end and also inside the
parameter list, like:

<pre>
  "p=100,100;b=,,rect;o=blue,black"
</pre>
<p>
Module/submodule parameters can be included with the <tt>$name</tt> notation:

<pre>
  "p=$xpos,$ypos;b=rect,60,10;o=$fillcolor,black,2"
</pre>
<p>
Objects that may have display strings are:
<ul>
  <li> <i>submodules</i> -- display string may contain position, arrangement
        (for module vectors), icon, icon color, auxiliary icon, status text,
        communication range (as circle or filled circle), etc.
  <li> <i>connections</i> -- display string can specify positioning, arrow color,
        arrow thickness
  <li> <i>compound modules</i> -- display string can specify background color,
        border color, border thickness
  <li> <i>messages</i> -- display string can specify icon, icon color, etc.
</ul>

<p>The following NED sample shows where to place display strings in the code.

<p><pre>
<b>module</b> ClientServer
    <b>submodules</b>:
        pc: Host;
            <b>display</b>: "p=66,55;i=comp"; // position and icon
        server: Server;
            <b>display</b>: "p=135,73;i=server1";
    <b>connections</b>:
        pc.out --&gt; server.in
            <b>display</b> "m=m,61,40,41,28"; // note missing ":"
        server.out --&gt; pc.in
            <b>display</b> "m=m,15,57,35,69";
    <b>display</b>: "o=#ffffff"; // affects background
<b>endmodule</b>
</pre>

<p>
<H3><A NAME="sec340"/>9.1.2 Submodule display strings</H3>

<p>TODO

<p>Examples:

<pre>
  "p=100,60;i=workstation"
  "p=100,60;b=30,30,rect;o=4"
</pre>
<p>

<p>
<H3><A NAME="sec341"/>9.1.3 Background display strings</H3>

<p>Compound module display strings specify the background. They can contain
the following tags:

<p>TODO

<p>

<p>
<H3><A NAME="sec342"/>9.1.4 Connection display strings</H3>

<p>TODO

<p>Examples:
<pre>
  "m=a;o=blue,3"
</pre>

<p>
<H3><A NAME="sec343"/>9.1.5 Message display strings</H3>

<p>Message objects do not store a display string by default, but you can redefine
the <tt><a href="../api/classcMessage.html">cMessage</a></tt>'s <tt>displayString()</tt> method and make it return
one.

<pre>
const char *CustomPacket::displayString() const
{
    return "i=msg/packet_vs";
}
</pre>
<p>
This display string affects how messages are shown during animation.
By default, they are displayed as a small filled circle, in one of
8 basic colors (the color is determined as <i>message kind modulo 8</i>),
and with the message class and/or name displayed under it
The latter is configurable in the Tkenv Options dialog, and message kind
dependent coloring can also be turned off there.

<p>The following tags can be used in message display strings:

<p>TODO

<p>Examples:

<pre>
   "i=penguin"
</pre>
<p>
<pre>
   "b=15,15,rect;o=white,kind,5"
</pre>

<p>

<p><H2><A NAME="sec344"/>9.2 Colors</H2>
<a name="sec:ch-graphics:colors"></a>

<p><H3><A NAME="sec345"/>9.2.1 Color names</H3>

<p>Any valid Tk color specification is accepted: English color names
(blue, lightgray, wheat) or <i>#rgb</i>, <i>#rrggbb</i> format
(where <i>r</i>,<i>g</i>,<i>b</i> are hex digits).

<p>It is also possible to specify colors in HSB (hue-saturation-brightness) as
<i>@hhssbb</i> (with <i>h</i>, <i>s</i>, <i>b</i> being hex digits).
HSB makes it easier to scale colors e.g. from white to bright red.

<p>You can produce a transparent background by specifying a hyphen (<i>"-"</i>)
as color.

<p>
<H3><A NAME="sec346"/>9.2.2 Icon colorization</H3>

<p>The <tt>"i="</tt> display string tag allows for colorization of icons.
It accepts a target color and a percentage as the degree of colorization.
Percentage has no effect if the target color is missing.
Brightness of icon is also affected -- to keep the original brightness,
specify a color with about 50% brightness (e.g. #808080 mid-grey,
#008000 mid-green).

<p>Examples:

<p><ul>
  <li> <tt>"i=device/server,gold"</tt> creates a gold server icon
  <li> <tt>"i=misc/globe,#808080,100"</tt> makes the icon grayscale
  <li> <tt>"i=block/queue,white,100"</tt> yields a "burnt-in" black-and-white icon
</ul>

<p>Colorization works with both submodule and message icons.

<p>
<H2><A NAME="sec347"/>9.3 The icons</H2>
<a name="sec:ch-graphics:icon-library"></a>

<p><H3><A NAME="sec348"/>9.3.1 The image path</H3>

<p>In the current OMNeT++ version, module icons are PNG or GIF files. The icons shipped
with OMNeT++ are in the <tt>images/</tt> subdirectory. Both the graphical NED editor
and Tkenv need the exact location of this directory to load the icons.

<p>Icons are loaded from all directories in the <i>image path</i>,
a semicolon-separated list of directories.
The default image path is compiled into Tkenv with the value
<tt>"<i>omnetpp-dir</i>/images;./images;./bitmaps"</tt> -- which will work fine
as long as you don't move the directory, and you'll also be able to
load more icons from the <tt>images/</tt> subdirectory of the current
directory. As people usually run simulation models from the model's
directory, this practically means that custom icons placed in the
<tt>images/</tt> subdirectory of the model's directory are automatically
loaded.

<p>The compiled-in image path can be overridden with the <tt>OMNETPP_IMAGE_PATH</tt>
environment variable. The way of setting environment variables is system
specific: in Unix, if you're using the bash shell, adding a line

<pre>
export OMNETPP_IMAGE_PATH="/home/you/images;./images"
</pre>
<p>
to <tt>~/.bashrc</tt> or <tt>~/.bash_profile</tt> will do; on Windows, environment variables
can be set via the <i>My Computer --&gt; Properties</i> dialog.

<p>You can also add to the image path from <tt>omnetpp.ini</tt>, with
the <tt>image-path</tt> setting:

<pre>
[Tkenv]
image-path = "/home/you/model-framework/images;/home/you/extra-images"
</pre>
<p>
The value should be quoted, otherwise the first semicolon separator will be
interpreted as comment sign, which will result in the rest of the
directories being ignored.

<p>
<H3><A NAME="sec349"/>9.3.2 Categorized icons</H3>

<p>Since OMNeT++ 3.0, icons are organized into several categories, represented
by folders. These categories include:

<p><ul>
  <li> block/ - icons for subcomponents (queues, protocols, etc).
  <li> device/ - network devices: servers, hosts, routers, etc.
  <li> abstract/ - symbolic icons for various devices
  <li> misc/ - node, subnet, cloud, building, town, city, etc.
  <li> msg/ - icons that can be used for messages
</ul>

<p>Old (pre-3.0) icons are in the <tt>old/</tt> folder.

<p>Tkenv and GNED now load icons from subdirectories of all directories
of the image path, and these icons can be referenced from display strings
by naming the subdirectory (subdirectories) as well:
<tt>"subdir/icon"</tt>, <tt>"subdir/subdir2/icon"</tt>, etc.

<p>For compatibility, if the display string contains a icon without
a category (i.e. subdirectory) name, OMNeT++ tries it as "old/icon" as well.

<p>
<H3><A NAME="sec350"/>9.3.3 Icon size</H3>

<p>Icons come in various sizes: normal, large, small, very small. Sizes are
encoded into the icon name's suffix: <tt>_l</tt>, <tt>_s</tt>, <tt>_vs</tt>.
In display strings, one can either use the suffix (<tt>"i=device/router_l"</tt>),
or the <tt>"is</tt>" (<i>icon size</i>) display string tag ("i=device/router;is=l").

<p>
<H2><A NAME="sec351"/>9.4 Layouting</H2>
<a name="sec:ch-graphics:layouting"></a>

<p>OMNeT++ implements an automatic layouting feature, using
a variation of the SpringEmbedder algorithm. Modules which have
not been assigned explicit positions via the <tt>"p="</tt> tag will be
automatically placed by the algorithm.

<p>SpringEmbedder is a graph layouting algorithm based on a physical model.
Graph nodes (modules) repent each other like electric charges
of the same sign, and connections are sort of springs which try
to contract and pull the nodes they're attached to. There is also friction
built in, in order to prevent oscillation of the nodes. The layouting algorithm
simulates this physical system until it reaches equilibrium
(or times out). The physical rules above have been slightly tweaked
to get better results.

<p>The algorithm doesn't move any module which has fixed coordinates.
Predefined row, matrix, ring or other arrangements (defined
via the 3rd and further args of the <tt>"p="</tt> tag) will be preserved --
you can think about them as if those modules were attached
to a wooden framework so that they can only move as one unit.

<p>Caveats:

<p><ul>
  <li> If the full graph is too big after layouting, it is scaled
    back so that it fits on the screen, <i>unless it contains
    any fixed-position module</i>. (For obvious reasons: if there's a module
    with manually specified position, we don't want to move that one).
    To prevent rescaling, you can specify a sufficiently large bounding
    box in the background display string, e.g. <tt>"b=2000,3000"</tt>.
  <li> Size is ignored by the present layouter, so longish modules
    (such as an Ethernet segment) may produce funny results.
  <li> The algorithm is prone to produce erratic results, especially
    when the number of submodules is small, or when using predefined
    (matrix, row, ring, etc) layouts. The "Re-layout" toobar button
    can then be very useful. Larger networks usually produce
    satisfactory results.
</ul>

<p>Parameters to the layouter algoritm (repulsive/attractive forces,
number of iterations,random number seed) can be specified via the
<tt>"l="</tt> background display string tag. Its current arguments are
(with default values):
<tt>"l=<i>&lt;repulsion&gt;</i>=10,<i>&lt;attraction&gt;</i>=0.3,
<i>&lt;edgelen&gt;</i>=40,<i>&lt;maxiter&gt;</i>=500,<i>&lt;rng-seed&gt;</i>"</tt>.
The <tt>"l="</tt> tag is somewhat experimental and its arguments
may change in further releases.

<p>
<H2><A NAME="sec352"/>9.5 Enhancing animation</H2>

<p><H3><A NAME="sec353"/>9.5.1 Changing display strings at runtime</H3>

<p>Often it is useful to manipulate the display string at runtime.
Changing colors, icon, or text may convey status change, and
changing a module's position is useful when simulating mobile
networks.

<p>Display strings are stored in <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> objects inside
modules and gates. <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> also lets you manipulate the string.

<p>To get a pointer to the <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> object, you can call
the module's <tt>displayString()</tt> method:

<p><pre>
<a href="../api/classcDisplayString.html">cDisplayString</a> *dispStr = displayString();
</pre>

<p>
<pre>
<a href="../api/classcDisplayString.html">cDisplayString</a> *bgDispStr = parentModule()-&gt;backgroundDisplayString();
</pre>

<p><pre>
<a href="../api/classcDisplayString.html">cDisplayString</a> *gateDispStr = gate("out")-&gt;displayString();
</pre>

<p>
As far as <tt><a href="../api/classcDisplayString.html">cDisplayString</a></tt> is concerned, a display string
(e.g. <tt>"p=100,125;i=cloud"</tt>) is a string that consist of several
<i>tags</i> separated by semicolons, and each tag has a <i>name</i>
and after an equal sign, zero or more <i>arguments</i> separated by commas.

<p>The class facilitates tasks such as finding out what tags a display string
has, adding new tags, adding arguments to existing tags,
removing tags or replacing arguments. The internal storage method allows
very fast operation; it will generally be faster than direct string manipulation.
The class doesn't try to interpret the display string in any way, nor does
it know the meaning of the different tags; it merely parses the string
as data elements separated by semicolons, equal signs and commas.

<p>An example:

<pre>
dispStr-&gt;parse("a=1,2;p=alpha,,3");
dispStr-&gt;insertTag("x");
dispStr-&gt;setTagArg("x",0,"joe");
dispStr-&gt;setTagArg("x",2,"jim");
dispStr-&gt;setTagArg("p",0,"beta");
ev &lt;&lt; dispStr-&gt;getString();  // result: "x=joe,,jim;a=1,2;p=beta,,3"
</pre>
<p>

<p><H3><A NAME="sec354"/>9.5.2 Bubbles</H3>

<p>Modules can let the user know about important events (such as a node
going down or coming up) by displaying a bubble with a short message
("Going down", "Coming up", etc.) This is done by the <tt>bubble()</tt> method
of <tt><a href="../api/classcModule.html">cModule</a></tt>. The method takes the string to be displayed
as a <tt>const char *</tt> pointer.

<p>An example:

<pre>
bubble("Going down!");
</pre>
<p>
If the module contains a lot of code that modifies the display string or
displays bubbles, it is recommended to make these calls conditional
on <tt>ev.isGUI()</tt>. The <tt>ev.isGUI()</tt> call returns <i>false</i>
when the simulation is run under Cmdenv, so one can make the code skip
potentially expensive display string manipulation.

<pre>
if (ev.isGUI())
    bubble("Going down!");
</pre>
<p>

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec355"/>10 Analyzing Simulation Results</H1>
<a name="cha:analyzing-simulation-results"></a>

<p>
<H2><A NAME="sec356"/>10.1 Output vectors</H2>
<a name="sec:ch-ana-sim:output-vectors"></a>

<p>Output vectors are time series data: values with timestamps.
You can use output vectors to record end-to-end delays or
round trip times of packets, queue lengths, queueing times,
link utilization, the number of dropped packets, etc. --
anything that is useful to get a full picture of what happened
in the model during the simulation run.

<p>Output vectors are recorded from simple modules, by <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects
(see section <a href="#sec257">[6.9.1]</a>). Since output vectors usually
record a large amount of data, in <tt>omnetpp.ini</tt> you can disable vectors
or specify a simulation time interval for recording
(see section <a href="#sec310">[8.8]</a>).

<p>All <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects write to the same, common file.
The following sections describe the format of the file, and
how to process it.

<p>
<H3><A NAME="sec357"/>10.1.1 Plotting output vectors with Plove</H3>

<p><p class="subheading">Plove features</p>

<p>Typically, you'll get output vector files as a result of a simulation.
Data written to <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects from
simple modules are written to output vector
files<!--output!vector file-->. You can use Plove to look
into the output vector files and plot vectors from them.

<p>Plove<!--Plove--> is a handy tool for plotting
OMNeT++ output vectors. Line type (lines, dots etc) for each vector can be set
as well as the most frequent drawing options like axis bounds, scaling, titles
and labels. You can save the graphs to files (as Encapsulated Postscript or
raster formats such as GIF) with a click. On Windows, you can also
copy the graph to the clipboard in a vector format (Windows metafile)
and paste it into other applications.
    <br><ul><font size=-1>[Note: prior to OMNeT++ 3.0, Plove has been a front-end to
    gnuplot. This older version of Plove is no longer supported, but it is still
    available in the OMNeT++ source distribution.]</font></ul>

<p>Filtering the results<!--filtering results--> before plotting is
possible. Filters can do averaging, truncation of extreme values,
smoothing, they can do density estimation<!--density estimation--> by
calculating histograms<!--histogram--> etc. Some filters are built
in, and you can create new filters by parameterizing and aggregating existing ones.
You can apply several filters to a vector.

<p>On startup, Plove automatically reads the <tt>.ploverc</tt> file in
your home directory. The file contains general application settings,
including the custom filters you created.

<p>

<p>
<p class="subheading">Usage</p>

<p>First, you load an output vector file (<tt>.vec</tt>) into the left
pane. You can copy vectors from the left
pane to the right pane by clicking the button with the right arrow icon
in the middle.
The PLOT button will initiate plotting the <i>selected</i>
vectors in the right pane. Selection works as in Windows: dragging
and shift+left click selects a range, and ctrl+left click selects/deselects
individual items. To adjust drawing style, change vector title or add
a filter, click the Options... button. This works for several selected
vectors too. Plove accepts nc/mc-like keystrokes: F3, F4, F5, F6, F8,
grey '+' and grey '*'.

<p>
The left pane works as a general storage for vectors you're working
with. You can load several vector files, delete vectors you don't
want to deal with, rename them etc. These changes will not affect
the vector files on disk.
(Plove never modifies the output vector files themselves.)
In the right pane, you can duplicate
vectors if you want to filter the vector and also keep the original.
If you set the right options for a vector but temporarily do
not want it to hang around in the right pane, you can put it
back into the left pane for storage.

<p>

<p><H3><A NAME="sec358"/>10.1.2 Format of output vector files</H3>

<p>An output vector file<!--output!vector file--> contains several
series of data produced during simulation. The file is textual, and it
looks like this:

<p><pre>
<b>mysim.vec:</b>
vector 1   "subnet[4].term[12]"  "response time"  1
1  12.895  2355.66666666
1  14.126  4577.66664666
vector 2   "subnet[4].srvr"  "queue length"  1
2  16.960  2.00000000000.63663666
1  23.086  2355.66666666
2  24.026  8.00000000000.44766536
</pre>

<p>
There two types of lines: vector declaration lines (beginning with
the word <tt>vector</tt>), and data lines.
A <i>vector declaration line</i> introduces a new output vector, and
its columns are: vector Id, module of creation, name of <tt><a href="../api/classcOutVector.html">cOutVector</a></tt>
object, and multiplicity (usually 1). Actual data recorded in this
vector are on <i>data lines</i> which begin with the vector Id.
Further columns on data lines are the simulation time and the recorded value.

<p>

<p>
<H3><A NAME="sec359"/>10.1.3 Working without Plove</H3>

<p>In case you have a large number of repeated experiments, you'll probably
want to automate processing of the output vector files. OMNeT++ lets you
use any tool you see fit for this purpose, because the output
vector files are text files and their format is simple enough to be
processed by common tools such as <i>perl</i>, <i>awk</i>,
<i>octave</i>, etc.

<p><p class="subheading">Extracting vectors from the file</p>

<p>You can use the Unix <tt>grep</tt> tool to extract a particular vector
from the file. As the first step, you must find out the Id of the
vector. You can find the appropriate vector line with a text editor or
you can use <tt>grep</tt> for this purpose:

<pre>
% grep "queue length" vector.vec
</pre>
<p>
Or, you can get the list of all vectors in the file by typing:

<pre>
% grep ^vector vector.vec
</pre>
<p>
This will output the appropriate vector line:

<pre>
vector 6  "subnet[4].srvr"  "queue length"  1
</pre>
<p>
Pick the vector Id, which is 6 in this case, and grep the file
for the vector's data lines:

<pre>
grep ^6 vector.vec &gt; vector6.vec
</pre>
<p>

<p>Now, <tt>vector6.vec</tt> contains the appropriate vector. The only
potential problem is that the vector Id is there at the beginning of
each line and this may be hard to digest for some programs that you
use for post-processing and/or visualization. This problem is
eliminated by the OMNeT++ <tt>splitvec</tt> utility (written in
<tt>awk</tt>), to be discussed in the next section.

<p>

<p>
<p class="subheading">Using splitvec</p>

<p>The <tt>splitvec</tt> script (part of OMNeT++) automates the process described
in the previous section: it breaks the vector file into several files which
contain one vector each. The command

<pre>
% splitvec mysim.vec
</pre>
<p>
would create the files <tt>mysim1.vec</tt>, <tt>mysim2.vec</tt> etc. with
contents similar to the following:

<p><pre>
<b>mysim1.vec:</b>
# vector 1  "subnet[4].term[12]"  "response time"  1
12.895  2355.66666666
14.126  4577.66664666
23.086  2355.66666666

<b>mysim2.vec:</b>
# vector 2  "subnet[4].srvr"  "queue length"  1
16.960  2.00000000000.63663666
24.026  8.00000000000.44766536
</pre>

<p>
As you can see, the vector Id column has been stripped from the files.
The resulting files can be directly loaded e.g. into spreadsheets or other
programs (<a href="#sec363">[10.3]</a>).

<p>
<H2><A NAME="sec360"/>10.2 Scalar statistics</H2>
<a name="sec:ch-ana-sim:output-scalars"></a>

<p>Output vectors capture the transient behaviour of the simulation run.
However, to compare model behaviour under various parameter settings,
output scalars are more useful.

<p><H3><A NAME="sec361"/>10.2.1 Format of output scalar files</H3>

<p>Scalar results are recorded with <tt>recordScalar()</tt> calls,
usually from the <tt>finish()</tt> methods of modules, with code like this:

<pre>
void EtherMAC::finish()
{
    double t = simTime();
    if (t==0) return;

    recordScalar("simulated time", t);
    recordScalar("rx channel idle (%)", 100*totalChannelIdleTime/t);
    recordScalar("rx channel utilization (%)", 100*totalSuccessfulRxTxTime/t);
    recordScalar("rx channel collision (%)", 100*totalCollisionTime);

    recordScalar("frames sent",    numFramesSent);
    recordScalar("frames rcvd",    numFramesReceivedOK);
    recordScalar("bytes sent",     numBytesSent);
    recordScalar("bytes rcvd",     numBytesReceivedOK);
    recordScalar("collisions",     numCollisions);

    recordScalar("frames/sec sent", numFramesSent/t);
    recordScalar("frames/sec rcvd", numFramesReceivedOK/t);
    recordScalar("bits/sec sent",   8*numBytesSent/t);
    recordScalar("bits/sec rcvd",   8*numBytesReceivedOK/t);
}
</pre>
<p>
The corresponding output scalar file (by default, <tt>omnetpp.sca</tt>)
will look like this:

<pre>
run 1 "lan"
scalar "lan.hostA.mac" "simulated time"             120.249243
scalar "lan.hostA.mac" "rx channel idle (%)"        97.5916992
scalar "lan.hostA.mac" "rx channel utilization (%)" 2.40820676
scalar "lan.hostA.mac" "rx channel collision (%)"   0.011312
scalar "lan.hostA.mac" "frames sent"                99
scalar "lan.hostA.mac" "frames rcvd"                3088
scalar "lan.hostA.mac" "bytes sent"                 64869
scalar "lan.hostA.mac" "bytes rcvd"                 3529448
scalar "lan.hostA.mac" "frames/sec sent"            0.823290006
scalar "lan.hostA.mac" "frames/sec rcvd"            25.6799953
scalar "lan.hostA.mac" "bits/sec sent"              4315.63632
scalar "lan.hostA.mac" "bits/sec rcvd"              234808.83
scalar "lan.hostB.mac" "simulated time"             120.249243
scalar "lan.hostB.mac" "rx channel idle (%)"        97.5916992
scalar "lan.hostB.mac" "rx channel utilization (%)" 2.40820676
scalar "lan.hostB.mac" "rx channel collision (%)"   0.011312
[...]
scalar "lan.hostC.mac" "simulated time"             120.249243
scalar "lan.hostC.mac" "rx channel idle (%)"        97.5916992
scalar "lan.hostC.mac" "rx channel utilization (%)" 2.40820676
scalar "lan.hostC.mac" "rx channel collision (%)"   0.011312
[...]

run 2 "lan"
scalar "lan.hostA.mac" "simulated time"             235.678665
[...]
</pre>
<p>
Every <tt>recordScalar()</tt> call generates one "scalar" line in the file.
(If you record statistics objects (<tt>cStatictic</tt> subclasses
such as <tt><a href="../api/classcStdDev.html">cStdDev</a></tt>) via their <tt>recordScalar()</tt> methods,
they'll generate several lines: mean, standard deviation, etc.)
In addition, several simulation runs can record their results into a single file --
this facilitates comparing them, creating x-y plots
(<i>offered load vs throughput</i>-type diagrams), etc.

<p>

<p><H3><A NAME="sec362"/>10.2.2 The Scalars tool</H3>

<p>The <tt>Scalars</tt> program can be used to visualize the contents of the
<tt>omnetpp.sca</tt> file. It can draw bar charts, x-y plots
(e.g. throughput vs offered load), or export data via the clipboard
for more detailed analysis into spreadsheets or other programs.

<p>You can open a scalar file either from the Scalars program's menu
or by specifying it as a command-line argument to Scalars.

<p>The program displays the data in a table with columns showing the
file name, run number, module name where it was recorded, and the value.
There're usually too many rows to get an overview, so you can filter
by choosing from (or editing) the three combo boxes at the top.
(The filters also accept <tt>*</tt>, <tt>**</tt> wildcards.)

<p>You could actually load further scalar files into the window,
and thus analyse them together.

<p>You can copy the selected rows to the clipboard by Edit|Copy or
the corresponding toolbar button, and paste them e.g. into
OpenOffice Calc, MS Excel or Gnumeric.

<p>The bar chart toolbar button creates -- well -- a bar chart
in a new window. You can customize the chart by right-clicking
on it and choosing from the context menu. It can also be exported
to EPS, GIF, or as metafile via the Windows clipbard (the latter
is not available on Unix of course).

<p>

<p><H2><A NAME="sec363"/>10.3 Analysis and visualization tools</H2>
<a name="sec:ana-sim:tools"></a>

<p>Output vector files (or files produced by <tt>splitvec</tt>) and
output scalar files can be analysed and/or plotted by
a number of applications in addition to <tt>Plove</tt> and <tt>Scalars</tt>.
These programs can produce output in various forms (on the screen,
as PostScript, in various image formats, etc.)

<p>One straightforward solution is to import or paste them into spreadsheet
programs such as OpenOffice Calc, Microsoft Excel or GNOME Gnumeric.
These programs have good charting and statistical features, but the number
of rows is usually limited to about 32,000..64,000.
One useful functionality spreadsheets offer for analysing scalar files is
known as <i>PivotTable</i> in Excel, and as <i>DataPilot</i> in in OpenOffice.
The easiest way to import scalar files into them is via copy/paste
from Scalars.

<p>Alternatively, one can use numerical packages such as <i>Octave</i>,
<i>Matlab</i> or the statistics package <i>R</i>.
In addition to their support for statistical computations, they can also
create various plots.

<p>There are also open-source programs directly for plotting, <i>Gnuplot</i>
still being the most commonly used one. Other, potentially more powerful ones
include <i>Grace</i>, <i>ROOT</i> and <i>PlotMTV</i>.

<p>
<H3><A NAME="sec364"/>10.3.1 Grace</H3>

<p><i>Grace</i> (also known as <i>xmgrace</i>, a successor of <i>ACE/gr</i> or
<i>Xmgr</i>) is a GPL-ed powerful data visualization program
with a WYSIWIG point-and-click graphical user interface. It was developed for
Unix, but there is a Windows version, too.

<p>You load the appropriate file by selecting it in a dialog box.
The icon bar and menu commands can be used to customize the graph.

<p>As of June 2003, Grace 1.5.12 can export graphics to (E)PS, PDF, MIF, SVG,
PNM, JPEG and PNG formats. It has many useful features like built-in statistics
and analysis functions (e.g. correlation, histogram), fitting, splines, etc.,
and it also sports its own built-in programming language.

<p>
<H3><A NAME="sec365"/>10.3.2 ROOT</H3>

<p><i>ROOT</i> is a powerful object-oriented data analysis framework,
with strong support for plotting and graphics in general.
ROOT was developed at CERN, and is distributed under a BSD-like license.

<p>ROOT is based on <i>CINT</i>, a ``C/C++ interpreter''
aimed at processing C/C++ scripts. It is probably harder to get started
using ROOT than with either Gnuplot or Grace, but if you are serious
about analysing simulation results, you will find that ROOT provides
power and flexibility that would be unattainable the other two programs.

<p>Curt Brune's page at Stanford (http://www.slac.stanford.edu/~curt/omnet++/)
shows examples what you can achieve using ROOT with OMNeT++.

<p>
<H3><A NAME="sec366"/>10.3.3 Gnuplot</H3>
<!--Gnuplot-->

<p>Gnuplot has an interactive command interface. To plot the data in
<tt>mysim1.vec</tt> and <tt>mysim4.vec</tt> (produced by <tt>splitvec</tt>)
plotted in the same graph, you can type:

<pre>
plot "mysim1.vec" with lines, "mysim4.vec" with lines
</pre>
<p>
To adjust the <i>y</i> range, you would type:

<pre>
set yrange [0:1.2]
replot
</pre>
<p>
Several commands are available to adjust ranges, plotting style, labels,
scaling etc. Gnuplot can also plot 3D graphs. Gnuplot
is available for Windows and other platforms.
On Windows, you can copy the resulting graph to the clipboard from
the Gnuplot window's system menu, then insert it into the application you
are working with.

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec367"/>11 Eventlog</H1>
<a name="cha:eventlog"></a>

<p><H2><A NAME="sec368"/>11.1 Introduction</H2>
The eventlog feature and the related tools are completely new in OMNeT++ 4.0. They aim to
help understanding complex simulation models and to help correctly implementing the
desired component behaviors. Using these tools you will be able to easily examine every
minute detail of the simulation back and forth in terms of simulation time or step-by-step
focusing on the behavior instead of the statistical results of your model.

<p>The eventlog file is created automatically during a simulation run upon explicit request
configurable in the ini file. The resulting file can be viewed in the OMNeT++ IDE using
the Sequence Chart and the Eventlog Table or can be processed by the command line Eventlog
Tool. These tools support filtering the collected data to show you only the relevant parts
focusing on what you are looking for. They allow examining causality relationships and
provide filtering based on simulation times, event numbers, modules and messages.

<p>The simulation kernel records into the eventlog among others: user level messages,
creation and deletion of modules, gates and connections, scheduling of self messages,
sending of messages to other modules either through gates or directly and processing of
messages (that is events). Optionally detailed message data can also be automatically
recorded based on a message filter. The result is an eventlog file which contains detailed
information of the simulation run and later can be used for various purposes.

<p><fontmaroon><em> Unknown LaTeX command </em> \begin </font>note<fontmaroon><em>  </em>  </font>
The eventlog file may become quite large for long running simulations (often hundreds of
Mbytes but occasionally multiple Gbytes), because it contains a lot of information about
the run especially when message detail recording is turned on.

<p>
<H2><A NAME="sec369"/>11.2 Configuration</H2>
To record an eventlog file during the simulation, simply insert the following line into
the ini file.
<pre>
record-eventlog = true
</pre>

<p>Since writing an eventlog file might significantly decrease overall simulation performance
therefore eventlog recording is turned off by default.

<p>
<H3><A NAME="sec370"/>11.2.1 File Name</H3>
The simulation kernel will write the eventlog file during the simulation into the file
specified by the following ini file configuration entry (showing the default file name
pattern here):
<pre>
eventlog-file = ${resultdir}/${configname}-${runnumber}.log
</pre>

<p><H3><A NAME="sec371"/>11.2.2 Recording Intervals</H3>
The size of an eventlog file is approximately proportional to the number of events it
contains. To reduce the file size and speed up the simulation it might be useful to record
only certain events. The following ini file configuration entry instructs the kernel to
record events with simulation time less than 10.2, between 22.2 and 100 and greater than
233.3.
<pre>
eventlog-recording-intervals = ..10.2, 22.2..100, 233.3..
</pre>

<p><H3><A NAME="sec372"/>11.2.3 Recording Modules</H3>
Another factor that affects the size of an eventlog file is the number of modules for
which the simulation kernel records events during the simulation. The following ini file
configuration entry instructs the kernel to record only the events that occurred in any of
the routers having index between 10 and 20 while turns off recording for all other
modules. This configuration key makes sense only for simple modules.
<pre>
**.router[10..20].**.module-eventlog-recording = true
**.module-eventlog-recording = false
</pre>

<p><H3><A NAME="sec373"/>11.2.4 Recording Message Data</H3>
Since recording message data dramatically increases the size of the eventlog file and
additionally slows down the simulation therefore it is turned off by default even if
writing the eventlog is enabled. To turn on message data recording enter a value for the
following configuration key in the ini file:
<pre>
eventlog-message-detail-pattern
</pre>
An example configuration for an IEEE 80211 model that records the field encapsulationMsg
and all other fields which name ends with Address from messages which class name ends with
Frame looks like this:
<pre>
eventlog-message-detail-pattern = *Frame:encapsulatedMsg,*Address
</pre>
An example configuration for a TCP/IP model that records the port and address fields in
all network packets looks like the following:
<pre>
eventlog-message-detail-pattern =
 PPPFrame:encapsulatedMsg|IPDatagram:encapsulatedMsg,*Address|TCPSegment:*Port
</pre>

<p>Take care about long running simulations because they might output eventlog files of
several Gbytes and thus fail due to insufficient disk space.

<p>
<H2><A NAME="sec374"/>11.3 Eventlog Tool</H2>
The Eventlog Tool is a command line tool to process eventlog files. Invoking it without
parameters will display usage information such as available commands and options. The
following are the most useful commands for users.

<p><H3><A NAME="sec375"/>11.3.1 Filter</H3>
The eventlog tool provides off line filtering that is usually applied to the eventlog file
after the simulation has been finished and before actually opening it in the OMNeT++ IDE
or processing it by any other means. Use the filter command and its various options to
specify what should be present in the result file.

<p><H3><A NAME="sec376"/>11.3.2 Echo</H3>
Since the eventlog file format is text based and users are encouraged to implement their
own filters therefore there needs to be a way to check whether an eventlog file is
correct. The echo command provides a way to check this and help users creating custom
filters. Anything not echoed back by the eventlog tool will not be taken into
consideration by the other tools found in the OMNeT++ IDE.

<p>Custom filter tools should filter out whole events only otherwise the consequences are
undefined.

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec377"/>12 Documenting NED and Messages</H1>
<a name="cha:neddoc"></a>

<p><H2><A NAME="sec378"/>12.1 Overview</H2>

<p>OMNeT++ provides a tool which can generate HTML documentation from NED files
and message definitions. Like Javadoc and Doxygen, <tt>opp_neddoc</tt>
makes use of source code comments. <tt>opp_neddoc</tt>-generated
documentation lists simple and compound modules, and presents their details
including description, gates, parameters, unassigned submodule parameters
and syntax-highlighted source code.
The documentation also includes clickable network diagrams (exported via the GNED
graphical editor) and module usage diagrams as well as inheritance diagrams
for messages.

<p><tt>opp_neddoc</tt> works well with Doxygen, which means that it can hyperlink
simple modules and message classes to their C++ implementation classes in
the Doxygen documentation. If you also generate the C++ documentation with some
Doxygen features turned on (such as <i>inline-sources</i> and
<i>referenced-by-relation</i>, combined with
<i>extract-all</i>, <i>extract-private</i> and <i>extract-static</i>),
the result is an easily browsable and very informative presentation of the
source code. Of course, one still has to write documentation comments
in the code.

<p>

<p><H2><A NAME="sec379"/>12.2 Authoring the documentation</H2>

<p>
<H3><A NAME="sec380"/>12.2.1 Documentation comments</H3>

<p>Documentation is embedded in normal comments. All <tt>//</tt> comments
that are in the ``right place'' (from the documentation tool's
point of view) will be included in the generated documentation.
  <br><ul><font size=-1>[In contrast, Javadoc and Doxygen use special comments (those
     beginning with <tt>/**</tt>, <tt>///</tt>, <tt>//&lt;</tt> or a similar
     marker) to distinguish documentation from ``normal'' comments in the
     source code. In OMNeT++ there's no need for that: NED and the message
     syntax is so compact that practically all comments one would want to write
     in them can serve documentation purposes. Still, there is a way to write
     comments that <i>don't</i> make it into the documentation -- by starting
     them with <tt>//#</tt>.]</font></ul>

<p>Example:

<pre>
//
// An ad-hoc traffic generator to test the Ethernet models.
//
simple Gen
    parameters:
        destAddress: string,  // destination MAC address
        protocolId: numeric,  // value for SSAP/DSAP in Ethernet frame
        waitMean: numeric;    // mean for exponential interarrival times
    gates:
        out: out;             // to Ethernet LLC
endsimple
</pre>
<p>
You can also place comments above parameters and gates. This is useful
if they need long explanations. Example:

<pre>
//
// Deletes packets and optionally keeps statistics.
//
simple Sink
    parameters:
        // You can turn statistics generation on and off. This is
        // a very long comment because it has to be described what
        // statistics are collected (or not).
        statistics: bool;
    gates:
        in: in;
endsimple
</pre>
<p>
If you want a comment line <i>not</i> to appear in the documentation,
begin it with <tt>//#</tt>. Those lines will be ignored by the
documentation generation, and can be used to comment out
unused NED code or to make ``private'' comments like <tt>FIXME</tt> or
<tt>TBD</tt>.

<pre>
//
// An ad-hoc traffic generator to test the Ethernet models.
//# FIXME above description needs to be refined
//
simple Gen
    parameters:
        destAddress: string,  // destination MAC address
        protocolId: numeric,  // value for SSAP/DSAP in Ethernet frame
        //# burstiness: numeric;  -- not yet supported
        waitMean: numeric;    // mean for exponential interarrival times
    gates:
        out: out;             // to Ethernet LLC
endsimple
</pre>
<p>

<p><H3><A NAME="sec381"/>12.2.2 Text layout and formatting</H3>

<p>If you write longer descriptions, you'll need text formatting capabilities.
Text formatting works like in Javadoc or Doxygen -- you can break up the
text into paragraphs and create bulleted/numbered lists without
special commands, and use HTML for more fancy formatting.

<p>Paragraphs are separated by empty lines, like in LaTeX or Doxygen.
Lines beginning with `<tt>-</tt>' will be turned into bulleted lists,
and lines beginning with `<tt>-#</tt>' into numbered lists.

<p>Example:

<pre>
//
// Ethernet MAC layer. MAC performs transmission and reception of frames.
//
// Processing of frames received from higher layers:
// - sends out frame to the network
// - no encapsulation of frames -- this is done by higher layers.
// - can send PAUSE message if requested by higher layers (PAUSE protocol,
//   used in switches). PAUSE is not implemented yet.
//
// Supported frame types:
// -# IEEE 802.3
// -# Ethernet-II
//
</pre>
<p>

<p><H3><A NAME="sec382"/>12.2.3 Special tags</H3>

<p><tt>OMNeT++_neddoc</tt> understands the following tags and will render them accordingly:
<tt>@author</tt>, <tt>@date</tt>, <tt>@todo</tt>, <tt>@bug</tt>, <tt>@see</tt>, <tt>@since</tt>,
<tt>@warning</tt>, <tt>@version</tt>. An example usage:

<pre>
//
// @author Jack Foo
// @date 2005-02-11
//
</pre>
<p>

<p><H3><A NAME="sec383"/>12.2.4 Additional text formatting using HTML</H3>

<p>Common HTML tags are understood as formatting commands.
The most useful of these tags are: <tt>&lt;i&gt;..&lt;/i&gt;</tt> (italic),
<tt>&lt;b&gt;..&lt;/b&gt;</tt> (bold), <tt>&lt;tt&gt;..&lt;/tt&gt;</tt> (typewriter font),
<tt>&lt;sub&gt;..&lt;/sub&gt;</tt> (subscript), <tt>&lt;sup&gt;..&lt;/sup&gt;</tt> (superscript),
<tt>&lt;br&gt;</tt> (line break), <tt>&lt;h3&gt;</tt> (heading),
<tt>&lt;pre&gt;..&lt;/pre&gt;</tt> (preformatted text) and <tt>&lt;a href=..&gt;..&lt;/a&gt;</tt> (link),
as well as a few other tags used for table creation (see below).
For example, <tt>&lt;i&gt;Hello&lt;/i&gt;</tt> will be rendered as ``<i>Hello</i>''
(using an italic font).

<p>The complete list of HTML tags interpreted by <tt>opp_neddoc</tt> are:
<tt>&lt;a&gt;</tt>, <tt>&lt;b&gt;</tt>, <tt>&lt;body&gt;</tt>, <tt>&lt;br&gt;</tt>, <tt>&lt;center&gt;</tt>,
<tt>&lt;caption&gt;</tt>, <tt>&lt;code&gt;</tt>, <tt>&lt;dd&gt;</tt>, <tt>&lt;dfn&gt;</tt>, <tt>&lt;dl&gt;</tt>,
<tt>&lt;dt&gt;</tt>, <tt>&lt;em&gt;</tt>, <tt>&lt;form&gt;</tt>, <tt>&lt;font&gt;</tt>, <tt>&lt;hr&gt;</tt>,
<tt>&lt;h1&gt;</tt>, <tt>&lt;h2&gt;</tt>, <tt>&lt;h3&gt;</tt>, <tt>&lt;i&gt;</tt>, <tt>&lt;input&gt;</tt>, <tt>&lt;img&gt;</tt>,
<tt>&lt;li&gt;</tt>, <tt>&lt;meta&gt;</tt>, <tt>&lt;multicol&gt;</tt>, <tt>&lt;ol&gt;</tt>, <tt>&lt;p&gt;</tt>, <tt>&lt;small&gt;</tt>,
<tt>&lt;span&gt;</tt>, <tt>&lt;strong&gt;</tt>,
<tt>&lt;sub&gt;</tt>, <tt>&lt;sup&gt;</tt>, <tt>&lt;table&gt;</tt>, <tt>&lt;td&gt;</tt>, <tt>&lt;th&gt;</tt>, <tt>&lt;tr&gt;</tt>,
<tt>&lt;tt&gt;</tt>, <tt>&lt;kbd&gt;</tt>, <tt>&lt;ul&gt;</tt>, <tt>&lt;var&gt;</tt>.

<p>Any tags not in the above list will not be interpreted as formatting commands
but will be printed verbatim -- for example, <tt>&lt;what&gt;bar&lt;/what&gt;</tt>
will be rendered literally as ``&lt;what&gt;bar&lt;/what&gt;'' (unlike HTML where
unknown tags are simply ignored, i.e. HTML would display ``bar'').

<p>If you insert links to external pages (web sites), its useful to add
the <tt>target="_blank"</tt> attribute to ensure pages come up in a new
browser window and not just in the current frame which looks awkward.
(Alternatively, you can use the <tt>target="_top"</tt> attribute
which replaces all frames in the current browser).

<p>Examples:

<pre>
//
// For more info on Ethernet and other LAN standards, see the
// &lt;a href="http://www.ieee802.org/" target="_blank"&gt;IEEE 802
// Committee's site&lt;/a&gt;.
//
</pre>
<p>
You can also use the <tt>&lt;a href=..&gt;</tt> tag to create links within the page:

<pre>
//
// See the &lt;a href="#resources"&gt;resources&lt;/a&gt; in this page.
// ...
// &lt;a name="resources"&gt;&lt;b&gt;Resources&lt;/b&gt;&lt;/a&gt;
// ...
//
</pre>
<p>
You can use the <tt>&lt;pre&gt;..&lt;/pre&gt;</tt> HTML tag to insert souce code examples
into the documentation. Line breaks and indentation will be preserved,
but HTML tags continue to be interpreted (or you can turn them off
with <tt>&lt;nohtml&gt;</tt>, see later).

<p>Example:

<pre>
// &lt;pre&gt;
// // my preferred way of indentation in C/C++ is this:
// &lt;b&gt;for&lt;/b&gt; (&lt;b&gt;int&lt;/b&gt; i=0; i&lt;10; i++)
// {
//     printf(&lt;i&gt;"%d\n"&lt;/i&gt;, i);
// }
// &lt;/pre&gt;
</pre>
<p>
will be rendered as

<p><pre>
// my preferred way of indentation in C/C++ is this:
<b>for</b> (<b>int</b> i=0; i&lt;10; i++)
{
    printf(<i>"%d\n"</i>, i);
}
</pre>

<p>HTML is also the way to create tables. The example below

<pre>
//
// &lt;table border="1"&gt;
//   &lt;tr&gt;  &lt;th&gt;#&lt;/th&gt; &lt;th&gt;number&lt;/th&gt; &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;1&lt;/td&gt; &lt;td&gt;one&lt;/td&gt;    &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;2&lt;/td&gt; &lt;td&gt;two&lt;/td&gt;    &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;3&lt;/td&gt; &lt;td&gt;three&lt;/td&gt;  &lt;/tr&gt;
// &lt;/table&gt;
//
</pre>
<p>
will be rendered approximately as:

<p><table border>
<TR> <TD align=left>

<p><b>#</b> </TD> <TD align=left> <b>number</b> </TD></TR>
<TR> <TD align=left> 1 </TD> <TD align=left> one </TD></TR>
<TR> <TD align=left> 2 </TD> <TD align=left> two </TD></TR>
<TR> <TD align=left> 3 </TD> <TD align=left> three </TD></TR>
</table>

<p>
<H3><A NAME="sec384"/>12.2.5 Escaping HTML tags</H3>

<p>Sometimes may need to off interpreting HTML tags (<tt>&lt;i&gt;</tt>, <tt>&lt;b&gt;</tt>, etc.)
as formatting instructions, and rather you want them to appear as literal
<tt>&lt;i&gt;</tt>, <tt>&lt;b&gt;</tt> texts in the documentation. You can achieve this via
surrounding the text with the <tt>&lt;nohtml&gt;</tt>...<tt>&lt;/nohtml&gt;</tt> tag.
For example,

<pre>
// Use the &lt;nohtml&gt;&lt;i&gt;&lt;/nohtml&gt; tag (like &lt;tt&gt;&lt;nohtml&gt;&lt;i&gt;this&lt;/i&gt;&lt;/nohtml&gt;&lt;tt&gt;)
// to write in &lt;i&gt;italic&lt;/i&gt;.
</pre>
<p>
will be rendered as ``Use the &lt;i&gt; tag (like <tt>&lt;i&gt;this&lt;/i&gt;</tt>) to write
in <i>italic</i>.''

<p><tt>&lt;nohtml&gt;</tt>...<tt>&lt;/nohtml&gt;</tt> will also prevent <tt>opp_neddoc</tt>
from hyperlinking words that are accidentally the same as an existing
module or message name. Prefixing the word with a backslash will achieve
the same. That is, either of the following will do:

<pre>
// In &lt;nohtml&gt;IP&lt;/nohtml&gt; networks, routing is...
</pre>
<p>
<pre>
// In \IP networks, routing is...
</pre>

<p>Both will prevent hyperlinking the word <i>IP</i> if you happen to have
an <tt>IP</tt> module in the NED files.

<p>

<p><H3><A NAME="sec385"/>12.2.6 Where to put comments</H3>

<p>You have to put the comments where nedtool will find them.
This is a) above the documented item, or b) after the
documented item, on the same line.

<p>If you put it above, make sure there's no blank line left
between the comment and the documented item. Blank lines
detach the comment from the documented item.

<p>Example:
<pre>
// This is wrong! Because of the blank line, this comment is not
// associated with the following simple module!

simple Gen
    parameters:
    ...
endsimple
</pre>

<p>Do not try to comment groups of parameters together. The result
will be awkward.

<p>
<H3><A NAME="sec386"/>12.2.7 Customizing the title page</H3>

<p>The title page is the one that appears in the main frame after
opening the documentation in the browser. By default it contains
a boilerplate text with the generic title <i>``OMNeT++ Model Documentation''</i>.
You probably want to customize that, and at least change the title
to the name of the documented simulation model.

<p>You can supply your own version of the title page adding a <tt>@titlepage</tt>
directive to a file-level comment (a comment that appears at the top of
a NED file, but is separated from the first <tt>import</tt>, <tt>channel</tt>,
<tt>module</tt>, etc. definition by at least one blank line).
In theory you can place your title page definition into
any NED or MSG file, but it is probably a good idea to create
a separate <tt>index.ned</tt> file for it.

<p>The lines you write after the <tt>@titlepage</tt> line up to the next
<tt>@page</tt> line (see later) or the end of the comment will be used
as the title page.
You probably want to begin with a title because the documentation
tool doesn't add one (it lets you have full control over the
page contents). You can use the <tt>&lt;h1&gt;..&lt;/h1&gt;</tt> HTML tag
to define a title.

<p>Example:

<pre>
//
// @titlepage
// &lt;h1&gt;Ethernet Model Documentation&lt;/h1&gt;
//
// This documents the Ethernet model created by David Wu and refined by Andras
// Varga at CTIE, Monash University, Melbourne, Australia.
//
</pre>
<p>

<p><H3><A NAME="sec387"/>12.2.8 Adding extra pages</H3>

<p>You can add new pages to the documentation in a similar way as customizing
the title page. The directive to be used is <tt>@page</tt>, and it can
appear in any file-level comment (see above).

<p>The syntax of the <tt>@page</tt> directive is the following:

<pre>
// @page filename.html, Title of the Page
</pre>
<p>
Please choose a file name that doesn't collide with the files generated
by the documentation tool (such as <tt>index.html</tt>).
The page title you supply will appear on the top of the page as well as
in the page index.

<p>The lines after the <tt>@page</tt> line up to the next <tt>@page</tt> line
or the end of the comment will be used as the page body.
You don't need to add a title because the documentation tool
automatically adds one.

<p>Example:
<pre>
//
// @page structure.html, Directory Structure
//
// The model core model files and the examples have been placed
// into different directories. The &lt;tt&gt;examples/&lt;/tt&gt; directory...
//
//
// @page examples.html, Examples
// ...
//
</pre>

<p>You can create links to the generated pages using standard HTML,
using the <tt>&lt;a href="..."&gt;...&lt;/a&gt;</tt> tag. All HTML files are
placed in a single directory, so you don't have to worry about
specifying directories.

<p>Example:
<pre>
//
// @titlepage
// ...
// The structure of the model is described &lt;a href="structure.html"&gt;here&lt;/a&gt;.
//
</pre>

<p>
<H3><A NAME="sec388"/>12.2.9 Incorporating externally created pages</H3>

<p>You may want to create pages outside the documentation tool
(e.g. using a HTML editor) and include them in the documentation.
This is possible, all you have to do is declare such pages with
the <tt>@externalpage</tt> directive in any of the NED files, and
they will be added to the page index. The pages can then be linked to
from other pages using the HTML <tt>&lt;a href="..."&gt;...&lt;/a&gt;</tt> tag.

<p>The <tt>@externalpage</tt> directive is similar in syntax
<tt>@page</tt>:

<pre>
// @externalpage filename.html, Title of the Page
</pre>
<p>
The documentation tool does not check if the page exists
or not. It is your responsibility to copy them manually into
the directory of the generated documentation and then to make
sure the hyperlinks work.

<p>

<p><H2><A NAME="sec389"/>12.3 Invoking opp_neddoc</H2>

<p>The <tt>opp_neddoc</tt> tool accepts the following command-line options:

<p>
<pre>
opp_neddoc - NED and MSG documentation tool, part of OMNeT++
(c) 2003-2004 Andras Varga

Generates HTML model documentation from .ned and .msg files.

Usage: opp_neddoc options files-or-directories ...
 -a, --all    process all *.ned and *.msg files recursively
              ('opp_neddoc -a' is equivalent to 'opp_neddoc .')
 -o &lt;dir&gt;     output directory, defaults to ./html
 -t &lt;filename&gt;, --doxytagfile &lt;filename&gt;
              turn on generating hyperlinks to Doxygen documentation;
              &lt;filename&gt; specifies name of XML tag file generated by Doxygen
 -d &lt;dir&gt;, --doxyhtmldir &lt;dir&gt;
              directory of Doxygen-generated HTML files, relative to the
              opp_neddoc output directory (-o option). -t option must also be
              present to turn on linking to Doxygen. Default: ../api-doc/html
 -n, --no-figures
              do not generate diagrams
 -p, --no-unassigned-pars
              do not document unassigned parameters
 -x, --no-diagrams
              do not generate usage and inheritance diagrams
 -z, --no-source
              do not generate source code listing
 -s, --silent suppress informational messages
 -g, --debug  print invocations of external programs and other info
 -h, --help   displays this help text

Files specified as arguments are parsed and documented. For directories as
arguments, all .ned and .msg files under them (in that directory subtree) are
documented. Wildcards are accepted and they are NOT recursive, e.g.
foo/*.ned does NOT process files in foo/bar/ or any other subdirectory.

Bugs:  (1) handles only files with .ned and .msg extensions, other files are
silently ignored; (2) does not filter out duplicate files (they will show up
multiple times in the documentation); (3) on Windows, file names are handled
case sensitively.
</pre>

<p>
<H3><A NAME="sec390"/>12.3.1 Multiple projects</H3>

<p>The generated <tt>tags.xml</tt> can be used to generate other documentation
that refers to pages in this documentation via HTML links.

<p>
<H2><A NAME="sec391"/>12.4 How does opp_neddoc work?</H2>

<p><tt>*.ned</tt> and <tt>*.msg</tt> files are collected (e.g. via the <tt>find</tt>
command if you used the <tt>-a</tt> option on Unix) and processed
with <tt>nedtool</tt>. <tt>nedtool</tt> parses them and outputs the resulting syntax
tree in XML -- a single large XML file which contains all files.

<p>The <tt>*.ned</tt> files are processed with the <tt>-c</tt> (export-diagrams-and-exit)
option of <tt>gned</tt>. This causes <tt>gned</tt> to export diagrams for the
compound modules in Postscript. Postscript files are then converted
to GIFs using <tt>convert</tt> (part of the ImageMagick package).
<tt>gned</tt> also exports an <tt>images.xml</tt> file which describes which
image was generated from which compound module, and also contains
additional info (coordinates of submodule rectangles and icons in the image)
for creating clickable image maps.

<p>The XML file containing parsed NED and message files is then processed
with an XSLT stylesheet to generate HTML. XSLT is a very powerful way
of converting an XML document into another XML (or HTML, or text) document.
Additionally, the stylesheet reads <tt>images.xml</tt> and uses its contents
to make the compound module images clickable.
The stylesheet also outputs a <tt>tags.xml</tt> file which describes what is documented
in which .html file, so that external documentation can link to this one.

<p>As a final step, the comments in the generated HTML file are processed
with a perl script. The perl script also performs syntax hightlighting
of the source listings in the HTML, and puts hyperlinks on module,
channel, message, etc. names. (It uses the info in the <tt>tags.xml</tt> file
for the latter task.) This last step, comment formatting and source code
coloring whould have been very difficult to achieve from XSLT, which
(at least in its 1.0 version of the standard) completely lacks powerful
string manipulation functions. (Not even simple find/replace
is supported in strings, let alone regular expressions. Perhaps the
2.0 version of XSLT will improve on this.)

<p>The whole process is controlled by the <tt>opp_neddoc</tt> script.

<p>

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec392"/>13 Parallel Distributed Simulation</H1>
<a name="cha:parallel-execution"></a>


<H2><A NAME="sec393"/>13.1 Introduction to Parallel Discrete Event Simulation</H2>

<p>OMNeT++ supports parallel execution<!--parallel simulation--> of large
simulations. The following paragraphs provide a brief picture
of the problems and methods of parallel
discrete event simulation (PDES<!--PDES-->). Interested readers are
strongly encouraged to look into the literature.

<p>For parallel execution, the model is to be partitioned into several
LPs (logical processes) that will be simulated independently on
different hosts or processors. Each LP will have its own local
Future Event Set, thus they will maintain their own local simulation
times. The main issue with parallel simulations is keeping LPs
synchronized in order to avoid violating the causality of events.
Without synchronization, a message sent by one LP could arrive in
another LP when the simulation time in the receiving LP has already
passed the timestamp (arrival time) of the message. This would break
causality<!--event!causality--> of events in the receiving LP.

<p>There are two broad categories of parallel simulation algorithms
that differ in the way they handle causality problems outlined
above:

<p><ol>
  <li><b>Conservative algorithms</b><!--parallel simulation!conservative-->
    prevents incausalities from happening. The Null Message Algorithm
    exploits knowledge of the time when LPs send messages to other LPs,
    and uses `null' messages to propagate this information to other LPs.
    If an LP knows it won't receive any messages from other
    LPs until <i>t+&Delta; t</i> simulation time, it may advance until
    <i>t+&Delta; t</i> without the need for external synchronization.
    Conservative simulation tends to converge to sequential simulation
    (slowed down by communication between LPs) if there's not
    enough parallelism in the model, or parallelism is not exploited
    by sending a sufficient number of `null' messages.

<p>  <li><b>Optimistic synchronization</b><!--parallel simulation!optimistic-->
    allows incausalities to occur, but detects and
    repairs them. Repairing involves rollbacks to a previous state,
    sending out anti-messages to cancel messages sent out during the
    period that is being rolled back, etc.  Optimistic synchronization
    is extremely difficult to implement, because it requires periodic
    state saving and the ability to restore previous states. In any
    case, implementing optimistic synchronization in OMNeT++ would
    require -- in addition to a more complicated simulation kernel --
    writing significantly more complex simple<!--module!simple-->
    module code from the user.  Optimistic synchronization may be slow
    in cases of excessive rollbacks.
</ol>

<p>
<H2><A NAME="sec394"/>13.2 Assessing available parallelism in a simulation model</H2>

<p>OMNeT++ currently supports conservative synchronization
via the classic Chandy-Misra-Bryant (or null message) algorithm
[<a href="#bib-chandymisra79">chandymisra79</a>].
To assess how efficiently a simulation can be parallelized
with this algorithm, we'll need the following variables:

<p><ul>
  <li><i>P</i> <i>performance</i> represents the number of events processed per
    second (ev/sec).
       <br><ul><font size=-1>[Notations: <i>ev:</i> events, <i>sec:</i> real seconds,
       <i>simsec:</i> simulated seconds]</font></ul>
    <i>P</i> depends on the performance of the hardware and the computation-intensiveness
    of processing an event. <i>P</i> is independent of the size of the model.
    Depending on the nature of the simulation model and the performance of the
    computer, <i>P</i> is usually in the range of 20,000..500,000 ev/sec.
  <li><i>E</i> <i>event density</i> is the number of events that occur per
    simulated second (ev/simsec). <i>E</i> depends on the model only, and not
    where the model is executed. <i>E</i> is determined by the size, the detail level
    and also the nature of the simulated system (e.g. cell-level ATM models
    produce higher <i>E</i> values than call center simulations.)
  <li><i>R</i> <i>relative speed</i> measures the simulation time advancement
    per second (simsec/sec). <i>R</i> strongly depends on both the model and
    on the software/hardware environment where the model executes.
    Note that <i>R = P/E</i>.
  <li><i>L</i> <i>lookahead</i> is measured in simulated seconds (simsec).
    When simulating telecommunication networks and using link delays as
    lookahead, <i>L</i> is typically in the msimsec-<i>&mu;</i>simsec range.
  <li><i>&tau;</i> <i>latency</i> (sec) characterizes the parallel simulation hardware.
    <i>&tau;</i> is the latency of sending a message from one LP to another. <i>&tau;</i>
    can be determined using simple benchmark programs. The authors' measurements
    on a Linux cluster interconnected via a 100Mb Ethernet switch using MPI
    yielded <i>&tau;</i>=22<i>&mu;</i>s which is consistent with measurements reported
    in [<a href="#bib-ongfarrell2000">ongfarrell2000</a>]. Specialized hardware such as
    Quadrics Interconnect [<a href="#bib-quadrics">quadrics</a>] can provide <i>&tau;</i>=5<i>&mu;</i>s or better.
</ul>

<p>In large simulation models, <i>P</i>, <i>E</i> and <i>R</i> usually stay relatively constant
(that is, display little fluctuations in time). They are also intuitive and
easy to measure. The OMNeT++ displays these values on the GUI while the simulation
is running, see Figure <a href="#fig:perfbar-screenshot">below</a>. Cmdenv can also be configured
to display these values.

<p>
  <div align=center>
    <img src="perfbar-screenshot.png">
    <center><i>Figure: Performance bar in OMNeT++ showing <i>P</i>, <i>R</i> and <i>E</i></i></center>
    <a name="fig:perfbar-screenshot"></a>
  </div>

<p>
After having approximate values of <i>P</i>, <i>E</i>, <i>L</i> and <i>&tau;</i>,
calculate the <i>&lambda;</i> <i>coupling factor</i> as the ratio of <i>LE</i> and <i>&tau; P</i>:

<p><i>&lambda; = (LE) / (&tau; P)</i>

<p>Without going into the details: if the resulting <i>&lambda;</i> value is at
minimum larger than one, but rather in the range 10..100, there is
a good change that the simulation will perform well when run in
parallel. With <i>&lambda; &lt; 1</i>, poor performance is guaranteed.
For details see the paper [<a href="#bib-ParsimCrit03">ParsimCrit03</a>].

<p>
<H2><A NAME="sec395"/>13.3 Parallel distributed simulation support in OMNeT++</H2>

<p><H3><A NAME="sec396"/>13.3.1 Overview</H3>

<p>This chapter presents the parallel simulation architecture
of OMNeT++. The design allows simulation models to be run
in parallel without code modification -- it only requires configuration.
The implementation relies on the approach of placeholder modules
and proxy gates to instantiate the model on different LPs --
the placeholder approach allows simulation techniques such as
topology discovery and direct message sending to work unmodified with
PDES. The architecture is modular and extensible, so it can
serve as a framework for research on parallel simulation.

<p>The OMNeT++ design places a big emphasis on
<i>separation of models from experiments</i>. The main rationale
is that usually a large number of simulation experiments need to be done
on a single model before a conclusion can be drawn about the real system.
Experiments tend to be ad-hoc and change much faster than simulation
models, thus it is a natural requirement to be able to
carry out experiments without disturbing the simulation model itself.

<p>Following the above principle, OMNeT++ allows simulation models
to be executed in parallel without modification. No special instrumentation
of the source code or the topology description is needed,
as partitioning and other PDES configuration is entirely described
in the configuration files.

<p>OMNeT++ supports the Null Message Algorithm with static
topologies, using link delays as lookahead. The laziness of null message
sending can be tuned. Also supported is the Ideal Simulation Protocol
(ISP) introduced by Bagrodia in 2000 [<a href="#bib-bagrodia00">bagrodia00</a>]. ISP is
a powerful research vehicle to measure the efficiency of
PDES algorithms, both optimistic and conservative;
more precisely, it helps determine the maximum speedup achievable
by any PDES algorithm for a particular model and simulation environment.
In OMNeT++, ISP can be used for benchmarking the performance of the
Null Message Algorithm.
Additionally, models can be executed without any synchronization, which
can be useful for educational purposes (to demonstrate the need for
synchronization) or for simple testing.

<p>For the communication between LPs (logical processes), OMNeT++
primarily uses MPI, the Message Passing Interface standard
[<a href="#bib-mpiforum94">mpiforum94</a>].  An alternative communication mechanism is based on
named pipes, for use on shared memory multiprocessors without the need
to install MPI.  Additionally, a file system based communication mechanism
is also available. It communicates via text files created in a shared
directory, and can be useful for educational purposes (to analyse or
demonstate messaging in PDES algorithms) or to debug PDES algorithms.
Implementation of a shared memory-based communication mechanism is also planned
for the future, to fully exploit the power of multiprocessors without
the overhead of and the need to install MPI.

<p>Nearly every model can be run in parallel. The constraints are the following:
<ul>
  <li>modules may communicate via sending messages only (no direct method call
        or member access) unless mapped to the same processor
  <li>no global variables
  <li>there are some limitations on direct sending (no sending to a <i>sub</i>module
        of another module, unless mapped to the same processor)
  <li>lookahead must be present in the form of link delays
  <li>currently static topologies are supported (we are working on a
      research project that aims to eliminate this limitation)
</ul>

<p>PDES support in OMNeT++ follows a modular and extensible architecture.
New communication mechanisms can be added by implementing a compact
API (expressed as a C++ class) and registering the implementation --
after that, the new communications mechanism can be selected for use
in the configuration.

<p>New PDES synchronization algorithms can be added in a similar way.
PDES algorithms are also represented by C++ classes that have
to implement a very small API
to integrate with the simulation kernel.
Setting up the model on various LPs as well as relaying
model messages across LPs is already taken care of and
not something the implementation of the synchronization algorithm
needs to worry about (although it can intervene if needed,
because the necessary hooks are provided).

<p>The implementation of the Null Message Algorithm is also
modular in itself in that the lookahead discovery can be plugged
in via a defined API. Currently implemented lookahead
discovery uses link delays, but it is possible to
implement more sophisticated ones and select them in the
configuration.

<p>

<p><H3><A NAME="sec397"/>13.3.2 Parallel Simulation Example</H3>

<p>We will use the Parallel CQN example simulation for demonstrating the
PDES capabilities of OMNeT++.
The model consists of <i>N</i> tandem queues where each tandem consists
of a switch and <i>k</i> single-server queues with exponential service times
(Figure <a href="#fig:cqn-model">below</a>).
The last queues are looped back to their switches. Each switch
randomly chooses the first queue of one of the tandems as destination,
using uniform distribution. The queues and switches are connected
with links that have nonzero propagation delays.
Our OMNeT++ model for CQN wraps tandems into compound modules.

<p>

<p>  <div align=center>
    <img src="cqn-model.png">
    <center><i>Figure: The Closed Queueing Network (CQN) model</i></center>
    <a name="fig:cqn-model"></a>
  </div>

<p>
To run the model in parallel, we assign tandems to different LPs
(Figure <a href="#fig:cqn-partitioning">below</a>). Lookahead is provided
by delays on the marked links.

<p>
  <div align=center>
    <img src="cqn-partitioning.png">
    <center><i>Figure: Partitioning the CQN model</i></center>
    <a name="fig:cqn-partitioning"></a>
  </div>

<p>
To run the CQN model in parallel, we have to configure it for parallel
execution. In OMNeT++, the configuration is in a text file called
<tt>omnetpp.ini</tt>. For configuration, first we have to specify
partitioning, that is, assign modules to processors. This is done
by the following lines:

<pre>
[Partitioning]
*.tandemQueue[0]**.partition-id = 0
*.tandemQueue[1]**.partition-id = 1
*.tandemQueue[2]**.partition-id = 2
</pre>
<p>
The numbers after the equal sign identify the LP.

<p>Then we have to select the communication library and the parallel
simulation algorithm, and enable parallel simulation:

<pre>
[General]
parallel-simulation=true
parsim-communications-class = "cMPICommunications"
parsim-synchronization-class = "cNullMessageProtocol"
</pre>
<p>
When the parallel simulation is run, LPs are represented
by multiple running instances of the same program.
When using LAM-MPI [<a href="#bib-lammpi">lammpi</a>], the mpirun program (part of LAM-MPI)
is used to launch the program on the desired processors.
When named pipes or file communications is selected, the opp_prun
OMNeT++ utility can be used to start the processes.
Alternatively, one can run the processes by hand (the -p flag
tells OMNeT++ the index of the given LP and the total number of LPs):

<pre>
./cqn -p0,3 &
./cqn -p1,3 &
./cqn -p2,3 &
</pre>
<p>
For PDES, one will usually want to select the command-line user interface,
and redirect the output to files. (OMNeT++ provides the necessary
configuration options.)

<p>The graphical user interface of OMNeT++ can also be used
(as evidenced by Figure <a href="#fig:parsim-screenshot">below</a>),
independent of the selected communication mechanism.
The GUI interface can be useful for educational or demonstation purposes.
OMNeT++ displays debugging output about the Null Message Algorithm,
EITs and EOTs can be inspected, etc.

<p>


<p>
  <div align=center>
    <img src="parsim-screenshot.png">
    <center><i>Figure: Screenshot of CQN running in three LPs</i></center>
    <a name="fig:parsim-screenshot"></a>
  </div>

<p>

<p>
<H3><A NAME="sec398"/>13.3.3 Placeholder modules, proxy gates</H3>

<p>When setting up a model partitioned to several LPs,
OMNeT++ uses placeholder modules and proxy gates.
In the local LP, placeholders represent sibling submodules
that are instantiated on other LPs.
With placeholder modules, every module has all of its siblings
present in the local LP -- either as placeholder or as the ``real thing''.
Proxy gates take care of forwarding messages to the LP where
the module is instantiated (see Figure <a href="#fig:plach">below</a>).

<p>The main advantage of using placeholders is that algorithms such as
topology discovery embedded in the model can be used with PDES unmodified.
Also, modules can use direct message sending to any sibling module,
including placeholders. This is so because the destination of direct message
sending is an input gate of the destination module -- if the destination
module is a placeholder, the input gate will be a proxy gate which
transparently forwards the messages to the LP where the ``real'' module
was instantiated. A limitation is that the destination of direct message
sending cannot be a <i>submodule</i> of a sibling (which is
probably a bad practice anyway, as it violates encapsulation),
simply because placeholders are empty and so its submodules are
not present in the local LP.

<p>Instantiation of compound modules is slightly more complicated.
Since submodules can be on different LPs, the compound module may
not be ``fully present'' on any given LP, and it may have to be
present on several LPs (wherever it has submodules instantiated).
Thus, compound modules are instantiated wherever they have
at least one submodule instantiated, and are represented by placeholders
everywhere else (Figure <a href="#fig:inst">below</a>).

<p>

<p>  <div align=center>
    <img src="placeholders.png">
    <center><i>Figure: Placeholder modules and proxy gates</i></center>
    <a name="fig:plach"></a>
  </div>

<p>

<p>  <div align=center>
    <img src="placeholders2.png">
    <center><i>Figure: Instantiating compound modules</i></center>
    <a name="fig:inst"></a>
  </div>

<p>

<p>
<H3><A NAME="sec399"/>13.3.4 Configuration</H3>

<p>Parallel simulation configuration is the <tt>[General]</tt> section of <tt>omnetpp.ini</tt>.

<p><table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=left colspan=2><b>[General]</b></TD></TR>
<TR> <TD align=left>
parallel-simulation = &lt;true/false&gt;<br>
default: false
</TD> <TD align=left>
Enables parallel distributed simulation. The following configuration
entries are only examined if <tt>parallel-simulation=true</tt>
</TD></TR>
<TR> <TD align=left>
parsim-debug = &lt;true/false&gt;<br>
default: true
</TD> <TD align=left>
Enables debugging output
</TD></TR>
<TR> <TD align=left>
parsim-mpicommunications-mpibuffer = &lt;bytes&gt;<br>
default: 256K * (numPartitions-1) + 16K
</TD> <TD align=left>
Size of MPI send buffer to allocate; see MPI_Buffer_attach()
MPI call. If the buffer is too small, a deadlock can occur.
</TD></TR>
<TR> <TD align=left>
parsim-namedpipecommunications-prefix = &lt;string&gt;<br>
default: "omnetpp" or "comm/"
</TD> <TD align=left>
Controls the naming of named pipes.
Windows: default value is "omnetpp", which means that pipe names will be of the form
"\\.\pipe\omnetpp-xx-yy"
(where xx and yy are numbers).
Unix: default value is "comm/", which means that the named pipes will
be created with the name "comm/pipe-xx-yy". The "comm/" subdirectory must
already exist when the simulation is launched.
</TD></TR>
<TR> <TD align=left>
parsim-filecommunications-prefix = &lt;string&gt;<br>
default: "comm/"
</TD> <TD align=left>
(see below)
</TD></TR>
<TR> <TD align=left>
parsim-filecommunications-preserve-read = &lt;true/false&gt;<br>
default: false
</TD> <TD align=left>
(see below)
</TD></TR>
<TR> <TD align=left>
parsim-filecommunications-read-prefix = &lt;string&gt;<br>
default: "comm/read/"
</TD> <TD align=left>
The above 3 options control the <tt>cFileCommunications</tt> class.
By default, it deletes files that were read. By enabling the
"preserve-read" setting, you can make it move read files to
another directory instead ("comm/read/" by default).
BEWARE: for mysterious reasons, it appears that there cannot be more
than about 19800 files in a directory. When that point is reached,
an exception is thrown somewhere inside the standard C library, which
materializes itself in OMNeT++ as an "Error: (null)" message...
Strangely, this can be reproduced in both Linux and Windows.
</TD></TR>
<TR> <TD align=left>
parsim-nullmessageprotocol-lookahead-class = &lt;class name string&gt;<br>
default: "cLinkDelayLookahead"
</TD> <TD align=left>
Selects the lookahead class for the Null Message Algorithm; the
class must be subclassed from cNMPLookahead.
</TD></TR>
<TR> <TD align=left>
parsim-nullmessageprotocol-laziness = &lt;0..1&gt;<br>
default: 0.5
</TD> <TD align=left>
Controls how often the Null Message Algorithm should send out null
messages; the value is understood in proportion to the lookahead,
e.g. 0.5 means every lookahead/2 simsec.
</TD></TR>
<TR> <TD align=left>
parsim-idealsimulationprotocol-tablesize = &lt;int&gt;<br>
default: 100,000
</TD> <TD align=left>
Size of chunks (in table entries) in which the external events
file (recorded by cISPEventLogger) should be loaded.
(one entry is 8 bytes, so 100,000 corresponds to ~800K allocated
memory)

<p></table>

<p>

<p>
When you are using cross-mounted home directories (the simulation's
directory is on a disk mounted on all nodes of the cluster),
a useful configuration setting is

<pre>
[General]
fname-append-host=yes
</pre>
<p>
It will cause the host names to be appended to the names of
all output vector files, so that partitions do not overwrite each other's
output files. (See section <a href="#sec332">[8.13.3]</a>)

<p>

<p>

<p><H3><A NAME="sec400"/>13.3.5 Design of PDES Support in OMNeT++</H3>

<p>Design of PDES support in OMNeT++ follows a layered approach,
with a modular and extensible architecture. The overall
architecture is depicted in Figure <a href="#fig:parsim-arch">below</a>.

<p>
  <div align=center>
    <img src="parsim-arch.png">
    <center><i>Figure: Architecture of OMNeT++ PDES implementation</i></center>
    <a name="fig:parsim-arch"></a>
  </div>

<p>
The parallel simulation subsytem is an optional component
itself, which can be removed from the simulation kernel
if not needed. It consists of three layers, from the bottom up:
communication layer, partitioning layer and synchronization layer.

<p>The purpose of the <i>Communication layer</i> is to
provide elementary messaging services between partitions for the
upper layer. The services include send, blocking receive,
nonblocking receive and broadcast. The send/receive operations
work with <i>buffers</i>, which encapsulate packing and unpacking
operations for primitive C++ types. The message class and
other classes in the simulation library can pack and unpack
themselves into such buffers. The Communications layer API
is defined in the <tt>cFileCommunications</tt> interface
(abstract class); specific implementations like the MPI
one (<tt>cMPICommunications</tt>) subclass from this,
and encapsulate MPI send/receive calls. The matching buffer
class <tt>cMPICommBuffer</tt> encapsulates MPI pack/unpack
operations.

<p>The <i>Partitioning layer</i> is responsible for instantiating
modules on different LPs according to the partitioning specified
in the configuration, for configuring proxy gates.
During the simulation, this layer also ensures that cross-partition
simulation messages reach their destinations. It intercepts messages
that arrive at proxy gates and transmits them to the destination LP
using the services of the communication layer. The receiving LP
unpacks the message and injects it at the gate the proxy gate points at.
The implementation basically encapsulates the
<tt>cParsimSegment</tt>, <tt>cPlaceHolderModule</tt>,
<tt>cProxyGate</tt> classes.

<p>The <i>Synchronization layer</i> encapsulates the parallel
simulation algorithm. Parallel simulation algorithms are also represented
by classes, subclassed from the <tt>cParsimSynchronizer</tt> abstract class.
The parallel simulation algorithm is invoked on the following hooks:
event scheduling, processing model messages outgoing from the LP,
and messages (model messages or internal messages) arriving
from other LPs. The first hook, event scheduling is a function
invoked by the simulation kernel to determine the next simulation
event; it also has full access to the future event set (FES<!--FES-->) and
can add/remove events for its own use.
Conservative parallel simulation algorithms will use this hook
to block the simulation if the next event is unsafe, e.g. the
null message algorithm implementation (<tt>cNullMessageProtocol</tt>)
blocks the simulation if an EIT has been reached until a null message
arrives (see [<a href="#bib-bagrodia00">bagrodia00</a>] for terminology); also it uses
this hook to periodically send null messages. The second hook
is invoked when a model message is sent to another LP;
the null message algorithm uses this hook to piggyback null
messages on outgoing model messages. The third hook is invoked
when any message arrives from other LPs, and it allows the
parallel simulation algorithm to process its own internal messages
from other partitions; the null message algorithm processes
incoming null messages here.

<p>The null message protocol implementation itself is modular,
it employs a separate, configurable lookahead discovery object.
Currently only link delay based lookahead discovery has been
implemented, but it is possible to implement more sophisticated
ones.

<p>The Ideal Simulation Protocol (ISP; see [<a href="#bib-bagrodia00">bagrodia00</a>])
implementation consists in fact of two parallel simulation
protocol implementations:
the first one is based on the null message algorithm and
additionally records the external events (events received
from other LPs) to a trace file; the second one executes
the simulation using the trace file to find out which
events are safe and which are not.

<p>Note that although we implemented a conservative protocol,
the provided API itself would allow implementing optimistic
protocols, too. The parallel simulation algorithm has
access to the executing simulation model, so it could perform
saving/restoring model state if model objects support this
  <br><ul><font size=-1>[Unfortunately, support for state saving/restoration
  needs to be individually and manually added to each class
  in the simulation, including user-programmed simple modules.]</font></ul>.

<p>We also expect that because of the modularity, extensibility and
clean internal architecture of the parallel simulation subsystem,
the OMNeT++ framework has the potential to become a preferred platform
for PDES research.

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec401"/>14 Customization and Embedding</H1>
<a name="cha:opp-design"></a>

<p><H2><A NAME="sec402"/>14.1 Architecture</H2>

<p>OMNeT++ has a modular architecture. The following diagram shows the
high-level architecture of OMNeT++ simulations:

<p>
  <div align=center>
    <img src="usmanFig18.png">
    <center><i>Figure: Architecture of OMNeT++ simulation programs</i></center>
  </div>

<p>
The rectangles in the picture represent components:

<p><ul>
  <li><b>Sim</b> is the simulation kernel and class
    library<!--simulation!kernel-->. Sim exists as a library you link
    your simulation program with.
       <br><ul><font size=-1>[Use of dynamic (shared) libraries is also possible, but
       for simplicity we'll use the word <i>linking</i> here.]</font></ul>

  <li><b>Envir</b> is another library which contains all code
    that is common to all user interfaces. <tt>main()</tt> is also in Envir.
    Envir provides services like ini file handling for specific user interface
    implementations. Envir presents itself towards Sim and the executing model
    via the <tt>ev</tt> facade object, hiding all other user interface internals.
    Some aspects of Envir can be customized<!--customization--> via plugin
    interfaces. Embedding OMNeT++ into applications<!--embedding--> can
    be achieved implementing a new user interface in addition to Cmdenv and Tkev,
    or by replacing Envir with another implementation of <tt>ev</tt>
    (see sections <a href="#sec411">[14.5.3]</a> and
    <a href="#sec403">[14.2]</a>.)
  <li><b>Cmdenv and Tkenv</b> are specific user interface
    implementations. A simulation is linked with
    either Cmdenv or Tkenv.
  <li>The <b>Model Component Library</b> consists of simple module definitions and
    their C++ implementations, compound module types, channels, networks,
    message types and in general everything that belongs to models and
    has been linked into the simulation program. A simulation program is
    able to run any model that has all necessary components linked in.
  <li>The <b>Executing Model</b> is the model that has been set up
    for simulation. It contains objects (modules, channels, etc.) that
    are all instances of components in the model component library.
</ul>

<p>The arrows in the figure show how components interact with
each other:

<p><ul>
  <li><b>Executing Model vs Sim</b>. The simulation kernel
    manages the future events and invokes modules in the executing model
    as events occur. The modules of the executing model are stored
    in the main object of Sim, <tt>simulation</tt> (of class <tt><a href="../api/classcSimulation.html">cSimulation</a></tt>).
    In turn, the executing model calls functions in the
    simulation kernel and uses classes in the Sim library.
  <li><b>Sim vs Model Component Library</b>. The simulation kernel
    instantiates simple modules and other components when the simulation model
    is set up at the beginning of the simulation run. It also refers
    to the component library when dynamic module creation is used.
    The machinery for registering and looking up components in the model
    component library is implemented as part of Sim.
  <li><b>Executing Model vs Envir</b>. The <tt>ev</tt> object, logically
    part of Envir, is the facade of the user interface towards the executing model.
    The model uses <tt>ev</tt> to write debug logs (<tt>ev&lt;&lt;</tt>, <tt>ev.printf()</tt>).
  <li><b>Sim vs Envir</b>. Envir is in full command of what
    happens in the simulation program. Envir contains the <tt>main()</tt> function
    where execution begins. Envir determines which models should be set up
    for simulation, and instructs Sim to do so. Envir contains the main
    simulation loop (<i>determine-next-event</i>, <i>execute-event</i>
    sequence) and invokes the simulation kernel for the necessary
    functionality (event scheduling and event execution are implemented in Sim).
    Envir catches and handles errors and exceptions that occur
    in the simulation kernel or in the library
    classes during execution. Envir presents a single facade object (<tt>ev</tt>)
    that represents the environment (user interface) toward Sim -- no Envir
    internals are visible to Sim or the executing model.
    During simulation model setup, Envir supplies parameter values for
    Sim when Sim asks for them. Sim writes output vectors via Envir,
    so one can redefine the output vector storing mechanism by changing Envir.
    Sim and its classes use Envir to print debug information.
  <li><b>Envir vs Tkenv and Cmdenv</b>. Envir defines <tt>TOmnetApp</tt>
    as a base class for user interfaces, and Tkenv and Cmdenv both subclass
    from <tt>TOmnetApp</tt>. The <tt>main()</tt> function provided as part of Envir
    determines the appropriate user interface class (subclassed from
    <tt>TOmnetApp</tt>), creates an instance and runs it -- whatever
    happens next (opening a GUI window or running as a command-line program)
    is decided in the <tt>run()</tt> method of the appropriate <tt>TOmnetApp</tt>
    subclass. Sim's or the model's calls on the <tt>ev</tt> object are
    simply forwarded to the <tt>TOmnetApp</tt> instance. Envir presents
    a framework and base functionality to Tkenv and Cmdenv via the methods of
     <tt>TOmnetApp</tt> and some other classes.)
</ul>

<p>
<H2><A NAME="sec403"/>14.2 Embedding OMNeT++</H2>
<a name="sec:ch-opp-design:embedding"></a>

<p>This section discusses the issues of embedding the simulation kernel
or a simulation model into a larger application.

<p>What you'll absolutely need for a simulation to run is the Sim library. You
probably do not want to keep the appearance of the simulation program, so
you do not want Cmdenv and Tkenv. You may or may not want to keep Envir.
You can keep Envir if its philosophy and the infrastructure it provides
(<tt>omnetpp.ini</tt>, certain command-line options etc.) fit into your
design. Then your application, the embedding program will take the place of
Cmdenv and Tkenv.

<p>If Envir does not fit your needs (for example, you want the model
parameters to come from a database not from <tt>omnetpp.ini</tt>), then you
have to replace it. Your Envir replacement (the embedding application,
practically) must implement the <tt><a href="../api/classcEnvir.html">cEnvir</a></tt> member functions from
<tt>envir/cenvir.h</tt>, but you have full control over the simulation.

<p>Normally, code that sets up a network or builds the internals of a
compound module comes from compiled NED source.  You may not like the
restriction that your simulation program can only simulate networks
whose setup code is linked in. No problem; your program can contain
pieces of code similar to what is currently generated by nedtool and then
it can build any network whose components (primarily the simple modules)
are linked in. Moreover, it is possible to write an integrated environment
where you can put together a network using a graphical editor and right
after that you can run it, without intervening NED compilation and
linkage.

<p>

<p>

<p><H2><A NAME="sec404"/>14.3 Sim: the simulation kernel and class library</H2>

<p>There is little to say about Sim here, since chapters
<a href="#sec154">[4]</a> and <a href="#sec222">[6]</a>,
and part of chapter <a href="#sec205">[5]</a> are all about
this topic. Classes covered in those chapters are documented
in more detail in the API Reference generated by Doxygen.
What we can do here is elaborating on some internals
that have not been covered in the general chapters.

<p>The source code for the simulation kernel<!--simulation!kernel-->
and class library reside in the <tt>src/sim/</tt> subdirectory.

<p>
<H3><A NAME="sec405"/>14.3.1 The global simulation object</H3>

<p>The global <tt>simulation</tt> object is an instance of <tt><a href="../api/classcSimulation.html">cSimulation</a></tt>.
It stores the model, and encapsulates much of the functionality
of setting up and running a simulation model.

<p><tt>simulation</tt> has two basic roles:

<p><ul>
  <li>it stores modules of the executing model
  <li>it holds the future event set (FES<!--FES-->) object
</ul>

<p>

<p><H3><A NAME="sec406"/>14.3.2 The coroutine package</H3>

<p>The coroutine package is in fact made up of two coroutine
packages<!--coroutine-->:

<p><ul>
  <li> A portable coroutine package creates all coroutine stacks
     inside the main stack. It is based on Kofoed's solution[<a href="#bib-Kofoed95">Kofoed95</a>].
     It allocates stack by deep-deep recursions and then plays with
     <tt>setjmp()</tt> and <tt>longjmp()</tt> to switch from one to another.

<p>  <li> On Windows, the Fiber functions (<tt>CreateFiber()</tt>,
     <tt>SwitchToFiber()</tt>, etc) are used, which are part of
     the standard Win32 API.
</ul>

<p>The coroutines are represented by the <tt><a href="../api/classcCoroutine.html">cCoroutine</a></tt>
class. <tt><a href="../api/classcSimpleModule.html">cSimpleModule</a></tt> has <tt><a href="../api/classcCoroutine.html">cCoroutine</a></tt> as one a
base class.

<p>

<p><H2><A NAME="sec407"/>14.4 The Model Component Library</H2>

<p>All model components (simple module definitions and their C++
implementations, compound module types, channels, networks,
message types, etc.) that you compile and link into a simulation
program are registered in the Model Component Library.
Any model that has all its necessary components in the
component library of the simulation program can be run by that
simulation program.

<p>If your simulation program is linked with Cmdenv or Tkenv,
you can have the contents of its component library printed,
using the -h switch.

<pre>
% ./fddi -h

OMNeT++ Discrete Event Simulation  (C) 1992-2004 Andras Varga
...
Available networks:
  FDDI1
  NRing
  TUBw
  TUBs

Available modules:
  FDDI_MAC
  FDDI_MAC4Ring
  ...

Available channels:
  ...
End run of OMNeT++
</pre>
<p>
Information on components are kept on registration lists.
There are macros for registering components (that is, for adding
them to the registeration lists):
<tt><tt>Define_Module()</tt></tt>, <tt><tt>Define_Module_Like()</tt></tt>,
<tt><tt>Define_Network()</tt></tt>, <tt><tt>Define_Function()</tt></tt>,
<tt>Register_Class()</tt>, and a few others. For components defined
in NED files, the macro calls are generated by the NED compiler;
in other cases you have to write them in your C++ source.

<p>Let us see the module registrations as an example. The

<pre>
Define_Module(FIFO);
</pre>
<p>
macro expands to the following code:

<pre>
static <a href="../api/classcModule.html">cModule</a> *FIFO__create(const char *name, <a href="../api/classcModule.html">cModule</a> *parentmod)
{
    return new FIFO(name, parentmod);
}

EXECUTE_ON_STARTUP( FIFO__mod,
    modtypes.instance()-&gt;add(
       new <a href="../api/classcModuleType.html">cModuleType</a>("FIFO","FIFO",(ModuleCreateFunc)FIFO__create)
    );
)
</pre>
<p>
When the simulation program starts up, a new <tt><a href="../api/classcModuleType.html">cModuleType</a></tt>
object will be added to the <tt>modtypes</tt> object, which holds the list
of available module types. The <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object will act as a factory:
when its create() method is called it will produce a new module object
of class <tt>FIFO</tt> via the above static function <tt>FIFO__create</tt>.

<p>The <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object also stores the name of the corresponding
NED module declaration. This makes it possible to add the gates and parameters
declared in NED to the module when it is created.

<p>The machinery for managing the registration lists are part
of the Sim library. Registration lists are implemented
as global objects.

<p>The registration lists are:

<p><table border>
<TR> <TD align=left>

<b>List variable</b>
</TD> <TD align=left>
<b>Macro/</b><br>
<b>Objects on list</b>
</TD> <TD align=left>
<b>Function</b> </TD></TR>
<TR> <TD align=left> <tt>networks</tt>
</TD> <TD align=left>
<tt><tt>Define_Network()</tt></tt> <br>
<br>
<tt><tt>cNetworkType</tt></tt>
</TD> <TD align=left>
 List of available networks<!--network!list of-->.
Every <tt>cNetworkType</tt> object is a factory for a specific
network type. That is, a <tt>cNetworkType</tt> object has methods
for setting up a specific network.
<tt>Define_Network()</tt> macros occur in the code generated by the NED
compiler.</TD></TR>
<TR> <TD align=left> <tt>modtypes</tt>
</TD> <TD align=left>
<tt><tt>Define_Module()</tt>,</tt> <br>
<tt><tt>Define_Module_Like()</tt>,</tt>  <br>
<br>
<tt><tt><a href="../api/classcModuleType.html">cModuleType</a></tt></tt>
</TD> <TD align=left>
 List of available module types.
Every <tt><a href="../api/classcModuleType.html">cModuleType</a></tt> object is a factory for a specific module
type. Usually, <tt>Define_Module()</tt> macros for compound modules occur in
the code generated by the NED compiler; for simple modules,
the <tt>Define_Module()</tt> lines are added by the user.</TD></TR>
<TR> <TD align=left> <tt>channeltypes</tt>
</TD> <TD align=left>
<tt>Define_Channel()</tt> <br>
<br>
<tt><a href="../api/classcChannelType.html">cChannelType</a></tt>
</TD> <TD align=left>
 List of channel types.
Every <tt><a href="../api/classcChannelType.html">cChannelType</a></tt> object acts as a factory for a channel type,
a class derived from <tt><a href="../api/classcChannel.html">cChannel</a></tt>. </TD></TR>
<TR> <TD align=left> <tt>classes</tt>
</TD> <TD align=left>
<tt>Register_Class()</tt> <br>
<br>
<tt>cClassRegister</tt>
</TD> <TD align=left>
 List of available classes of which one can create
an instance.
Every <tt>cClassRegister</tt> object is a factory for objects
of a specific class. The list is used by the <tt>createOne()</tt> function:
it can create an object of any class, given the class name as a string.
(E.g. the statement <tt>ptr = createOne("<a href="../api/classcArray.html">cArray</a>")</tt> creates a <tt><a href="../api/classcArray.html">cArray</a></tt> object.)
To enable a class to work with <tt>createOne()</tt>, one has to register it using the
<tt>Register_Class(classname)</tt> macro</TD></TR>
<TR> <TD align=left> <tt>functions</tt>
</TD> <TD align=left>
<tt><tt>Define_Function()</tt></tt> <br>
<br>
<tt><tt>cFunctionType</tt></tt>
</TD> <TD align=left>
 List of functions taking <tt>double</tt>s and returning a <tt>double</tt>
(see type <tt>MathFuncNoArg</tt>...<tt>MathFunc3Args</tt>).
A <tt>cFunctionType</tt> object holds a pointer to the function and knows
how many arguments it takes.</TD></TR>
</table>

<p>

<p><H2><A NAME="sec408"/>14.5 Envir, Tkenv and Cmdenv</H2>

<p>The source code for the user interface of OMNeT++ resides in the
<tt>src/envir/</tt> directory (common part) and in the <tt>src/cmdenv/</tt>,
<tt>src/tkenv/</tt> directories.

<p>The classes in the user interface are <i>not</i> derived from <tt><a href="../api/classcOwnedObject.html">cOwnedObject</a></tt>,
they are completely separated from the simulation kernel.

<p>

<p><H3><A NAME="sec409"/>14.5.1 The main() function</H3>

<p>The <tt>main()</tt> function of OMNeT++ simply sets up the user
interface and runs it. Actual simulation is done in
<tt><a href="../api/classcEnvir.html">cEnvir</a>::run()</tt> (see later).

<p>

<p><H3><A NAME="sec410"/>14.5.2 The <a href="../api/classcEnvir.html">cEnvir</a> interface</H3>

<p>The <tt><a href="../api/classcEnvir.html">cEnvir</a></tt> class has only one instance, a global object
called <tt>ev</tt>:

<pre>
<a href="../api/classcEnvir.html">cEnvir</a> ev;
</pre>
<p>
<tt><a href="../api/classcEnvir.html">cEnvir</a></tt> basically a facade, its member functions
contain little code. <tt><a href="../api/classcEnvir.html">cEnvir</a></tt> maintains a pointer to a
dynamically allocated simulation application object (derived from
<tt>TOmnetApp</tt>, see later) which does all actual work.

<p>
<tt><a href="../api/classcEnvir.html">cEnvir</a></tt> member functions perform the following groups of tasks:
<ul>
  <li> I/O for module activities; the actual implementation is different
    for each user interface (e.g. stdin/stdout for Cmdenv, windowing
    in Tkenv)
  <li> <a href="../api/classcEnvir.html">cEnvir</a> provides methods for the simulation kernel to
    access configuration information (for example, module parameter settings)
  <li> <a href="../api/classcEnvir.html">cEnvir</a> also provides methods that are called by simulation kernel to
    notify the user interface of certain events (an object was deleted;
    a module was created or deleted; a message was sent or delivered, etc.)
</ul>

<p>
<H3><A NAME="sec411"/>14.5.3 Customizing Envir</H3>
<a name="sec:ch-opp-design:customization"></a>

<p>Certain aspects of Envir can be customized via plugin interfaces.
The following plugin interfaces are supported:

<p><ul>
   <li><tt><a href="../api/classcRNG.html">cRNG</a></tt>. Interface for the random number generator.
   <li><tt><a href="../api/classcScheduler.html">cScheduler</a></tt>. The scheduler class. This plugin interface
     allows for implementing real-time, hardware-in-the-loop, distributed
     and distributed parallel simulation.
   <li><tt><a href="../api/classcConfiguration.html">cConfiguration</a></tt>. It defines a class
     from which all configuration will be obtained. In other words, it
     option lets you replace <tt>omnetpp.ini</tt> with some other implementation,
     e.g. database input.
   <li><tt><a href="../api/classcOutputScalarManager.html">cOutputScalarManager</a></tt>. It handles recording the scalar output data,
     output via the <a href="../api/classcModule.html">cModule</a>::recordScalar() family of functions.
     The default output scalar manager is <tt>cFileOutputScalarManager</tt>,
     defined in the Envir library.
   <li><tt><a href="../api/classcOutputVectorManager.html">cOutputVectorManager</a></tt>. It handles recording the output
     for <tt><a href="../api/classcOutVector.html">cOutVector</a></tt> objects.
     The default output vector manager is <tt>cFileOutputVectorManager</tt>,
     defined in the Envir library.
   <li><tt><a href="../api/classcSnapshotManager.html">cSnapshotManager</a></tt>. It provides an output stream to which
     snapshots are written (see section <a href="#sec265">[6.10.5]</a>).
     The default snapshot manager is <tt>cFileSnapshotManager</tt>,
     defined in the Envir library.
</ul>

<p>The classes (<tt><a href="../api/classcRNG.html">cRNG</a></tt>, <tt><a href="../api/classcScheduler.html">cScheduler</a></tt>, etc.) are documented in
the API Reference.

<p>To actually implement and select a plugin for use:

<p><ol>
   <li> Subclass the given interface class (e.g. for a custom RNG, <tt><a href="../api/classcRNG.html">cRNG</a></tt>)
     to create your own version.
   <li> Register the class by putting the <tt>Register_Class(MyRNGClass)</tt>
     line into the C++ source.
   <li> Compile and link your interface class into the OMNeT++ simulation
     executable. IMPORTANT: make sure the executable actually contains
     the code of your class! Over-optimizing linkers (esp. on Unix)
     tend to leave out code to which there seem to be no external reference.
   <li> Add an entry to <tt>omnetpp.ini</tt> to tell Envir use your class
     instead of the default one. For RNGs, this setting is <tt>rng-class</tt>
     in the <tt>[General]</tt> section.
</ol>

<p>Ini file entries that allow you to select your
plugin classes are <tt>configuration-class</tt>, <tt>scheduler-class</tt>,
<tt>rng-class</tt>, <tt>outputvectormanager-class</tt>,
<tt>outputscalarmanager-class</tt> and <tt>snapshotmanager-class</tt>,
documented in section <a href="#"></a>.

<p><p class="subheading">How plugin classes can access the configuration</p>

<p>The configuration is available to plugin classes via the <tt>config()</tt>
method of <tt><a href="../api/classcEnvir.html">cEnvir</a></tt>, which returns a pointer to the configuration
object (<tt><a href="../api/classcConfiguration.html">cConfiguration</a></tt>). This enables plugin classes to have
their own config entries.

<p>An example which reads the <tt>parsim-debug</tt> boolean entry from the
<tt>[General]</tt> section, with <tt>true</tt> as default:

<pre>
bool debug = ev.config()-&gt;getAsBool("General", "parsim-debug", true);
</pre>
<p>

<p><p class="subheading">Startup sequence for the configuration plugin</p>

<p>For the configuration plugin, the startup sequence is the following
(see <tt><a href="../api/classcEnvir.html">cEnvir</a>::setup()</tt> in the source code):

<p><ol>
  <li> First, <tt>omnetpp.ini</tt> (or the ini file(s) specified via the "-f"
     command-line option) are read.
  <li> Shared libraries in <tt>[General]/load-libs</tt> are loaded.
     (Also the ones specified with the "-l" command-line option.)
  <li> <tt>[General]/configuration-class</tt> is examined, and if it is present,
     a configuration object of the given class is instantiated.
     The configuration object may read further entries from the
     ini file (e.g. database connect parameters, or XML file name).
  <li> The original <tt>omnetpp.ini</tt> <tt>cInifile</tt> configuration
     object is deleted. No other settings are taken from it.
  <li> <tt>[General]/load-libs</tt> from the new configuration object is
     processed.
  <li> Then everything goes on as normally, using the new configuration
     object.
</ol>

<p>

<p><H3><A NAME="sec412"/>14.5.4 Implementation of the user interface: simulation applications</H3>

<p>The base class for simulation application is <tt>TOmnetApp</tt>.
Specific user interfaces such as <tt>TCmdenv</tt>,
<tt>TOmnetTkApp</tt> are derived from <tt>TOmnetApp</tt>.

<p><tt>TOmnetApp</tt>'s member functions are almost all virtual.
<ul>
  <li>Some of them implement the <tt><a href="../api/classcEnvir.html">cEnvir</a></tt> functions
    (described in the previous section)
  <li>Others implement the common part of all user interfaces (for
    example: reading options from the configuration files; making the
    options effective within the simulation kernel)
  <li>The <tt>run()</tt> function is pure virtual (it is different
    for each user interface).
</ul>

<p><tt>TOmnetApp</tt>'s data members:
<ul>
  <li>a pointer to the object holding configuration file contents
    (type <tt>cInifile</tt>);
  <li>the options and switches that can be set from the
    configuration file (these members begin with <tt>opt_</tt>)
</ul>

<p>Simulation applications:
<ul>
  <li>add new configuration options
  <li>provide a <tt>run()</tt> function

<p>  <li>implement functions left empty in <tt>TOmnetApp</tt> (like
    <tt>breakpointHit()</tt>, <tt>objectDeleted()</tt>).
</ul>

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec413"/>15 NED Reference</H1>
<a name="cha:ned-ref"></a>

<p><H2><A NAME="sec414"/>15.1 Syntax</H2>

<p><H3><A NAME="sec415"/>15.1.1 NED file extension</H3>

<p>NED files have the <tt>.ned</tt> file name suffix. This is mandatory, and
cannot be overridden.

<p><H3><A NAME="sec416"/>15.1.2 NED file encoding</H3>

<p>NED files are read as 8-bit-clean ASCII. This permits NED files saved
in UTF-8, or any character set compatible with ASCII (8859-1, etc).

<p><fontmaroon><em> Unknown LaTeX command </em> \begin </font>note<fontmaroon><em>  </em>  </font>
    There is no official way to determine the encoding of a NED file. It is up
    to the user to configure the correct encoding in text editors and other
    tools that are used to edit or process NED files.

<p>
Keywords and other syntactic elements in NED are ASCII, and identifiers must be
ASCII as well. Comments and string literals may contain characters above
127. String literals (e.g. in parameter values) will be passed to the C++ code
as <tt>const char *</tt> without any conversion.

<p>Line ending may be either CR or CRLF, regardless of platform.

<p>
<H3><A NAME="sec417"/>15.1.3 Reserved words</H3>

<p>Authors have to take care that no reserved words are used as identifiers.
The reserved words of the NED language are:

<p><tt>allowunconnected bool channel channelinterface connections const
default double extends false for gates if import index inout input int like
module moduleinterface network output package parameters property simple
sizeof string submodules this true types volatile xml xmldoc</tt>

<p>
<H3><A NAME="sec418"/>15.1.4 Identifiers</H3>

<p>Identifiers must be composed of letters of the English alphabet (a-z, A-Z),
numbers (0-9) and underscore ``_''. Identifiers may only begin with a
letter or underscore.

<p>The recommended way to compose identifiers from multiple words is to
capitalize the beginning of each word (<i>camel case</i>).

<p><H3><A NAME="sec419"/>15.1.5 Case sensitivity</H3>

<p>Keywords and identifiers in the NED language are case sensitive. For example,
<tt>TCP</tt> and <tt>Tcp</tt> are two different names.

<p><H3><A NAME="sec420"/>15.1.6 Literals</H3>

<p><p class="subheading">String literals</p>

<p>String literals use double quotes. The following C-style backslash
escapes are recognized: <tt>\b</tt>, <tt>\f</tt>, <tt>\n</tt>, <tt>\r</tt>,
<tt>\t</tt>, <tt>\\</tt>, <tt>\"</tt>, and <tt>\xhh</tt> where <i>h</i> is a
hexadecimal digit.

<p><p class="subheading">Numeric constants</p>

<p>Numeric constants are accepted in their usual decimal or
scientific notations.

<p><p class="subheading">Quantity constants</p>

<p>A quantity constant has the form <i>(&lt;numeric-constant&gt; &lt;unit&gt;)+</i>, for
example <tt>12.5mW</tt> or <tt>3h 15min 37.2s</tt>. When multiple units are present,
they have to be convertible into each other (i.e. refer to the same physical
quantity).

<p>Section <a href="#sec456">[15.15.7]</a> lists the units recognized by OMNeT++.
Other units can be used as well, the only downside being that OMNeT++ will not be
able to perform conversions on them.

<p><H3><A NAME="sec421"/>15.1.7 Comments</H3>

<p>Comments can be placed anywhere in the NED file, with the usual C++
syntax: comments begin with a double slash `//', and last until
the end of the line.

<p><H3><A NAME="sec422"/>15.1.8 Grammar</H3>

<p>The grammar of the NED language can be found in Appendix
<a href="#sec457">[16]</a>.

<p><H2><A NAME="sec423"/>15.2 Built-in definitions</H2>
<a name="ch-ned-ref:sec:built-in-defs"></a>

<p>The NED language has the following built-in definitions, all in the <tt>ned</tt>
package: channels <tt>IdealChannel</tt> and <tt>BasicChannel</tt>, and module
interfaces <tt>IBidirectionalChannel</tt> and <tt>IUnidirectionalChannel</tt>; the
latter two are reserved for future use.

<pre>
package ned;

@namespace("");

channel IdealChannel {
    @class(<a href="../api/classcIdealChannel.html">cIdealChannel</a>);
}

channel BasicChannel {
    @class(<a href="../api/classcBasicChannel.html">cBasicChannel</a>);
    bool disabled = false;
    double delay = 0s @unit(s);
    double error = 0;
    double datarate = 0bps @unit(bps);
}

moduleinterface IBidirectionalChannel {
    gates:
        inout a;
        inout b;
}

moduleinterface IUnidirectionalChannel {
    gates:
        input i;
        output o;
}
</pre>
<p>

<p>
<H2><A NAME="sec424"/>15.3 Packages</H2>

<p>NED supports hierarchical namespaces called <i>packages</i>. The solution
is roughly modelled after Java's packages, with minor changes.
<H3><A NAME="sec425"/>15.3.1 Package declaration</H3>

<p>The package of the declarations in a NED file is determined by the package
declaration in the file (<tt>package</tt> keyword). A NED file may contain at
most one package declaration. If there is no package declaration, the file's
contents is in the <i>default package</i>.

<p><H3><A NAME="sec426"/>15.3.2 Directory structure, package.ned</H3>

<p>Like in Java, the directory of a NED file must match the package
declaration. However, it is possible to omit directories at the top which do
not contain any NED files (like the typical <tt>/org/<i>&lt;projectname&gt;</i></tt>
directories in Java).

<p>The top of a directory tree containing NED files is named a <i>NED source
folder</i>. The <tt>package.ned</tt> file direcly in a NED source folder plays a
special role.

<p>If there is no toplevel <tt>package.ned</tt> or it contains no package declaration,
the declared package of a NED file in the folder <tt><i>&lt;srcfolder&gt;</i>/x/y/z</tt>
<i>must</i> be <tt>x.y.z</tt>.
If there is a toplevel <tt>package.ned</tt> and it declares to be in package
<tt>a.b</tt>, then any NED file in the folder <tt><i>&lt;srcfolder&gt;</i>/x/y/z</tt>
<i>must</i> have the declared package <tt>a.b.x.y.z</tt>.

<p>
    <tt>package.ned</tt> files are allowed in other folders as well, but they
    are not treated specially, i.e. they cannot be used to define the package
    they are in.

<p>
<H2><A NAME="sec427"/>15.4 Name uniqueness</H2>

<p>All component type names must be unique.

Identifier names within a component must be unique. That is, submodule
or inner type cannot be named the same, or the same as a gate or
parameter of the parent module.

<p>

<p><H2><A NAME="sec428"/>15.5 Type name resolution</H2>

<p>Names from other NED files can be referred to either by fully qualified
name ("inet.protocols.network.ip.RoutingTable"), or by short name
("RoutingTable") if the name is visible.

<p>Visible names are:
<ul>
  <li> anything from the same package;
  <li> imported names.
</ul>

<p><H3><A NAME="sec429"/>15.5.1 Imports</H3>

<p>Imports have a similar syntax to Java, but they are more flexible with wildcards.
All of the following are legal:
<pre>
import inet.protocols.network.ip.RoutingTable;
import inet.protocols.network.ip.*;
import inet.protocols.network.ip.Ro*Ta*;
import inet.protocols.*.ip.*;
import inet.**.RoutingTable;
</pre>

<p>One asterisk "*" stands for "any character sequence not containing
period"; two asterisks mean "any character sequence which may
contain period". No other wildcards are recognized.

<p>An import not containing wildcard MUST match an existing NED type.
However, it is legal for an import that does contain wildcards
not to match any NED type (although that might generate a warning.)

<p>Inner types may not be referred to outside their enclosing types.

<p><H3><A NAME="sec430"/>15.5.2 Base types and submodules</H3>

<p>Fully qualified names and simple names are accepted. Simple names
are looked up among the inner types of the enclosing type (compound
module), then using imports, then in the same package.

<p>
<H3><A NAME="sec431"/>15.5.3 Parametric module types ("like" submodules)</H3>

<p>Lookup of the actual module type for "like" submodules differs for normal
lookups. This lookup ignores the imports in the file altogether.
Instead, it collects all modules that support the given interface
and match the given type name string (i.e. end in the same simple name,
or have the same fully qualified name). The result must be exactly
one module type.

<p>The algorithm for parametric channel types works in the same way.

<p>
<H3><A NAME="sec432"/>15.5.4 Network name in the ini file</H3>

<p>Simple (unqualified) names are tried with the same package as the
ini file is in (provided it's in a NED directory).

<p>
<H2><A NAME="sec433"/>15.6 Inheritance</H2>

<p><ul>
  <li> A simple module may only extend a simple module.
  <li> A compound module may only extend a compound module.
  <li> A channel may only extend a channel.
  <li> A module interface may only extend a module interface (or several module
        interfaces).
  <li> A channel interface may only extend a channel interface (or several
        channel interfaces).
</ul>

A <tt>network</tt> is a shorthand for a compound module with the <tt>@isNetwork</tt>
property set, so the same rules apply to it as to compound modules.

<p>Inheritance may:
<ul>
  <li> add new properties, parameters, gates, inner types, submodules,
        connections
  <li> modify inherited properties, and properties of inherited parameters and
        gates
  <li> it may NOT modify inherited submodules, connections and inner types
</ul>

<p>XXX
- parameter once assigned in base class or type MUST be allowed to be
  set to a different value in subclass/place of usage!!!

<p>XXX
- rules of inheritance:
    o for inner types:
       - can I define an inner type with the same name in subclasses? NO
    o for properties:
       - contents will be merged (rules like for display strings: values on
         same key and same position will overwrite old ones)
    o for parameters:
       - type cannot be redefined
       - value may be redefined in subclasses or place of usage
    o for gates:
       - type cannot be redefined
       - vector size may be redefined in subclasses or place of usage
    o for gate/parameter properties:
       - extra properties can be added
       - existing properties can be overridden/extended like for standalone properties (?)
    o for submodules:
       - new submodules may be added, but inherited ones cannot be modified
    o for connections:
       - new connections may be added, but inherited ones cannot be modified

<p>See other rules for specifics.

<p><H2><A NAME="sec434"/>15.7 Simple modules</H2>

<p>XXX

<p><H2><A NAME="sec435"/>15.8 Channels</H2>

<p>XXX

<p>\section[C++ class for simple modules/channels]Determining the implementation
C++ class for simple modules and channels

<p>The procedure for determiming the C++ implementation class for simple modules
and for channels are identical. It goes as follows (we are going to say
<i>component</i> instead of <i>``simple module or channel''</i>):

<p>If the component extends another component and has no
<tt>@class</tt> property, the C++ implementation class is inherited from the base
type.

<p>If the component contains has a <tt>@class</tt> property, the C++ class
name will be composed of the <i>current namespace</i> (see
<a href="#sec436">[15.8.1]</a>) and the value of the <tt>@class</tt>
property. The <tt>@class</tt> property should contain a single value.

<p>
    The <tt>@class</tt> property may itself contain a namespace declaration (ie.
    may contain ``<tt>::</tt>'').

<p>
If the component contains no <tt>@class</tt> property and has no base
class, the C++ class name will be composed of the <i>current namespace</i> and the
unqualified name of the component.

<p>
    NED subclassing does not imply subclassing the C++ implementation. If you
    want to subclass a simple module or channel in NED as well as in C++, you
    explicitly need the to specify the <tt>@class</tt> property, otherwise the
    derived simple module or channel will continue to use the C++ class from its
    super type.

<p><H3><A NAME="sec436"/>15.8.1 Current namespace</H3>
<a name="cha:ned-ref:current-namespace"></a>

<p>The <i>current namespace</i> is the value of the first <tt>@namespace</tt>
property found while searching the following order:
<ol>
  <li> the current NED file
  <li> the <tt>package.ned</tt> file in the current package
  <li> the <tt>package.ned</tt> file of the parent package or the first ancestor
        package searching upwards
</ol>

<p>The <tt>@namespace</tt> property should contain a single value.

<p>
    This was considered and discarded: <tt>module X extends ASimple</tt>
    instead of <tt>simple X extends ASimple</tt>. It was proposed because
    otherwise, if base type's implementation gets changed from simple to compound, all
    subclasses will have to be changed. Idea discarded because the confusion
    this would create is worse than the problem itself.

<p>

<p><H2><A NAME="sec437"/>15.9 Interfaces</H2>

<p>An interface (module interface or channel interface) may NOT contain
parameter assignment or parameter default value assignment. An interface
may NOT contain inner types. (Rationale: what use would they be?).

<p>A module or channel type that implements ("like") an interface is
required to have at least the parameters and, for modules, the gates
defined in the interface, with the same types.

<p>Regarding properties, parameter properties and gate properties defined
in the interface: the module or channel is required to have those properties,
with at least the same values. It may have additional properties,
and properties may add more keys and values (see property inheritance.)

<p>
<H2><A NAME="sec438"/>15.10 Compound modules</H2>

<p>Extra params CANNOT be added in submodules and connection channelspecs --
they can only be added in new types.

<p>FIXME: submodules
FIXME: connections

<p><H2><A NAME="sec439"/>15.11 Networks</H2>

<p><H3><A NAME="sec440"/>15.11.1 The network keyword</H3>

<p>A network declared with the <tt>network</tt> keyword is equivalent to a compound
module (<tt>module</tt> keyword) with the <tt>@isNetwork(true)</tt> property.

<p><H3><A NAME="sec441"/>15.11.2 The @isNetwork property</H3>

<p>The <tt>@isNetwork</tt> property is only accepted on simple modules and
compound modules. The value may be empty, true or false:

<pre>
@isNetwork;
@isNetwork();
@isNetwork(true);
@isNetwork(false);
</pre>
<p>
The empty value corresponds to <tt>@isNetwork(true)</tt>.

<p>The <tt>@isNetwork</tt> property does NOT get inherited, that is, a subclass
of a module with <tt>@isNetwork</tt> set does NOT automatically become a network.
The <tt>@isNetwork</tt> property needs to be explicitly added to the subclass
to make it a network.

<p><fontmaroon><em> Unknown LaTeX command </em> \begin </font>rationale<fontmaroon><em>  </em>  </font>
	Subclassing may introduce changes to a module that make it unfit to be used
	as a network.

<p>

<p>
<H2><A NAME="sec442"/>15.12 Properties</H2>

<p><H3><A NAME="sec443"/>15.12.1 Property inheritance</H3>

<p>Generally, properties may be modified via inheritance. Inheritance may:

<p><ul>
    <li> add new keys
    <li> add/overwrite values for existing keys
    <li> remove a value from an existing key (by using the special value '-')
</ul>

<p>

<p><H2><A NAME="sec444"/>15.13 Parameters</H2>

<p><H3><A NAME="sec445"/>15.13.1 Parameter inheritance</H3>

<p>Default values for parameters may be overridden in subclasses.

<p>Parameter (non-default) assignments may also be overridden in subclasses.

<p>
    The latter is needed for ease of use of channels and their <tt>delay</tt>,
    <tt>error</tt>, <tt>datarate</tt> parameters.

<p>
<H3><A NAME="sec446"/>15.13.2 The @unit property</H3>

<p>A parameter may have a <tt>@unit</tt> property to associate it with a physical
unit. The <tt>@unit</tt> property should contain one string value for the default
key. Examples:

<pre>
@unit("s")
@unit(s)
@unit("second")
@unit(second)
</pre>
<p>
When present, values assigned to the parameter must be in the
same or in a compatible (that is, convertible) unit.
Examples:

<pre>
  double a @unit(s) = 5s;  // OK
  double a @unit(s) = 5;   // error: should be 5s
  double a @unit(s) = 5kg; // error: incompatible unit
</pre>
<p>
@unit behavior for non-numeric parameters (string, XML) is unspecified
(may be ignored or may be an error).

<p>The @unit property of a parameter may NOT be modified via inheritance.

<p>Example:
<pre>
simple A {
    double p @unit(s);
}
simple B extends A {
    p @unit(mW);  // illegal: cannot override @unit
}
</pre>

<p>

<p><H2><A NAME="sec447"/>15.14 Gates</H2>

<p><H3><A NAME="sec448"/>15.14.1 Rules for gate vector sizes</H3>

<p>Gate vector sizes may NOT be overridden in subclasses.

<p>

<p><H2><A NAME="sec449"/>15.15 Expressions</H2>
<a name="ch-ned-ref:sec:expressions"></a>

<p>FIXME TODO:
- @unit and expression evaluation wrt units
- rules for resolving an identifier in an expression

<p>In the NED language there are a number of places where
expressions<!--ned!expressions--> are expected.

<p>Expressions have a C-style syntax. They are built with the usual math
operators<!--math operators-->; they can use parameters taken by
value or by reference; call C functions; contain random and input
values etc.

<p>When an expression is used for a parameter value, it is evaluated
each time the parameter value is accessed (unless the parameter is
declared <tt>const</tt>, see <a href="#sec140">[3.12.1]</a>). This means
that a simple module querying a non-const parameter during simulation
may get different values every time (e.g. if the value involves a
random variable, or it contains other parameters taken by reference).
Other expressions (including <tt>const</tt> parameter values)
are evaluated only once.

<p>XML-type parameters can be used to conveniently access external
XML files or parts of them. XML-type parameters can be assigned
with the <tt>xmldoc()</tt> operator, also described in this section.

<p>
<H3><A NAME="sec450"/>15.15.1 Referencing parameters</H3>

<p>Expressions can use the parameters of the enclosing compound module
(the one being defined) and of submodules defined earlier in NED file.
The syntax for the latter is <tt>submod.param</tt> or <tt>submod[index].param</tt>.

<p>There are two keywords that you can use with a parameter name:
<tt>ancestor</tt> and <tt>ref</tt>.  The first one (<tt>ancestor</tt> <i>param</i>)
means that if compound module doesn't have such a parameter,
further modules up in the module hierarchy will be searched for the parameter.
<tt>ancestor</tt> is considered bad practice because it violates the encapsulation
principle and can only be checked at runtime. It is provided for the
rare case when it is really needed.

<p><tt>ref</tt> <i>param</i> takes the parameter by reference, meaning that
runtime changes to the parameter will propagate to all modules which
take that parameter by reference. Like <tt>ancestor</tt>, <tt>ref</tt>
should also be used very sparingly. One possible use is tuning a model
at runtime, in search for an optimum: one defines a parameter
at the highest level of the model, and lets other modules take it by reference --
then if you change the parameter value at runtime
(manually or from a simple module), it will affect the whole model.
In another setup, reference parameters may be used to propagate
status values to neighbouring modules.

<p>

<p><H3><A NAME="sec451"/>15.15.2 Operators</H3>
<!--ned!expressions!operators-->

<p>The operators supported in NED are similar to C/C++ operators,
with the following differences:

<p><ul>
  <li>^ is used for power-of (and not bitwise XOR as in C)
  <li>## is used for logical XOR (same as != between logical values), and
        # is used for bitwise XOR
  <li>the precedence of bitwise operators (&amp;, |, #) have been raised
        to bind stronger than relational operations. This precedence is usually
        more convenient than the C/C++ one.
</ul>

<p>All values are represented as <tt>double</tt>s. For the bitwise operators,
<tt>double</tt>s are converted to <tt>unsigned long</tt>
  <br><ul><font size=-1>[In case you are worried about <tt>long</tt> values being not accurately
  represented in <tt>double</tt>s, this is not the case. IEEE-754 <tt>double</tt>s
  have 52 bit mantissas, and integer numbers in that range are represented
  without rounding errors.]</font></ul>
using the C/C++ builtin conversion (type cast), the operation is performed,
then the result is converted back to <tt>double</tt>.
Similarly, for the logical operators &amp;&amp;, || and ##,
the operands are converted to <tt>bool</tt> using the C/C++ builtin
conversion (type cast), the operation is performed, then the result
is converted back to <tt>double</tt>. For modulus (%), the operands are
converted to <tt>long</tt>.

<p>Here's the complete list of operators, in order of decreasing precendence:

<p><table border>
<TR> <TD align=left>

<p><b>Operator</b>                   </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <tt>-</tt>, <tt>!</tt>, <it>~</it> </TD> <TD align=left> unary minus, negation, bitwise complement </TD></TR>
<TR> <TD align=left> <tt>^</tt>         </TD> <TD align=left> power-of </TD></TR>
<TR> <TD align=left> <tt>*</tt>, <tt>/</tt>, <tt>%</tt>       </TD> <TD align=left> multiply, divide, modulus </TD></TR>
<TR> <TD align=left> <tt>+</tt>, <tt>-</tt>                 </TD> <TD align=left> add, subtract </TD></TR>
<TR> <TD align=left> <tt>&lt;&lt;</tt>, <tt>&gt;&gt;</tt>               </TD> <TD align=left> bitwise shift </TD></TR>
<TR> <TD align=left> <tt>&amp;</tt>, <tt>|</tt>, <tt>#</tt>      </TD> <TD align=left> bitwise and, or, xor </TD></TR>
<TR> <TD align=left> <tt>==</tt>                         </TD> <TD align=left> equal </TD></TR>
<TR> <TD align=left> <tt>!=</tt>                         </TD> <TD align=left> not equal </TD></TR>
<TR> <TD align=left> <tt>&gt;</tt>, <tt>&gt;=</tt>                </TD> <TD align=left> greater, greater or equal </TD></TR>
<TR> <TD align=left> <tt>&lt;</tt>, <tt>&lt;=</tt>                </TD> <TD align=left> less, less or equal </TD></TR>
<TR> <TD align=left> <tt>&amp;&amp;</tt>, <tt>||</tt>, <tt>##</tt> </TD> <TD align=left> logical operators and, or, xor </TD></TR>
<TR> <TD align=left> <tt>?:</tt>                         </TD> <TD align=left> the C/C++ ``inline if'' </TD></TR>
</table>
<H3><A NAME="sec452"/>15.15.3 The <tt>sizeof()</tt> and <tt>index</tt> operators</H3>

<p>A useful operator is <tt>sizeof()</tt><!--ned!sizeof()-->, which gives the
size of a vector gate<!--gate!vector-->. The <tt>index</tt>
operator<!--ned!index operator--> gives the index of the current
submodule in its module vector.

<p>FIXME TBD:
- sizeof() resolution:
    IN SUBMODULE SCOPE:
        sizeof(foo): must refer to a parent module gate vector, or
                     sibling submodule vector (there cannot be ambiguity
                     here, because of the name uniqueness rule above)
                     NOTE: IT CANNOT REFER TO LOCAL GATE VECTOR !!!
        sizeof(this.foo): refers to local gate vector
        sizeof(foo.bar): refers to gatevector of sibling submodule
    IN CONNECTION SCOPE:
        same as above, only sizeof(this.foo) does not make sense
    IN [PARENT] MODULE SCOPE:
        sizeof(foo), sizeof(this.foo): refers to that module's gatevector
        sizeof(foo.bar): makes no sense (thus illegal)

<p>- "index" operator: it always returns the same (sub)module's index in whose "parameters"
   block it is defined. It is NOT POSSIBLE to obtain the parent module's index.

<p>
<H3><A NAME="sec453"/>15.15.4 The <tt>xmldoc()</tt> operator</H3>

<p>The <tt>xmldoc()</tt> operator can be used to assign XML-type parameters,
that is, point them to XML files or to specific elements inside XML files.

<p><tt>xmldoc()</tt> has two flavours: one accepts a file name, the second accepts
a file name plus an XPath-like expression which selects an element
inside the XML file. Examples:

<p><pre>
xmlparam = <b>xmldoc</b>("someconfig.xml");
xmlparam = <b>xmldoc</b>("someconfig.xml", "/config/profile[@id='2']");
</pre>

<p>OMNeT++ supports a subset of the XPath 1.0 specification; details are
documented below.

<p>From the C++ code you'd access the XML element like this:

<pre>
<a href="../api/classcXMLElement.html">cXMLElement</a> *rootelement = par("xmlparam").xmlValue();
</pre>
<p>
The <tt><a href="../api/classcXMLElement.html">cXMLElement</a></tt> class provides a DOM-like access to the XML document.
You can then navigate the document tree, extract the information you need,
and store it in variables or your internal data structure.
<tt><a href="../api/classcXMLElement.html">cXMLElement</a></tt> is documented in Chapter <a href="#sec222">[6]</a>.

<p>You can also read XML parameters from omnetpp.ini:

<pre>
[Parameters]
**.interface[*].config = xmldoc("conf.xml")
</pre>
<p>
or

<pre>
[Parameters]
**.interface[*].config = xmldoc("all-in-one.xml", "/config/interfaces/interface[2]")
</pre>
<p>

<p><H3><A NAME="sec454"/>15.15.5 XML documents and the XPath subset supported</H3>

<p><tt>xmldoc()</tt> with two arguments accepts a path expression
to select an element within the document. The expression syntax is
similar to XPath.

<p>If the expression matches several elements, the first element
(in preorder depth-first traversal) will be selected. (This is
unlike XPath, which selects all matching nodes.)

<p>The expression syntax is the following:
<ul>
  <li> An expression consists of <i>path components</i> (or "steps")
        separated by "<tt>/</tt>" or "<tt>//</tt>".
  <li> A path component can be an element tag name, "<tt>*</tt>", "<tt>.</tt>"
        or "<tt>..</tt>".
  <li> "<tt>/</tt>" means child element (just as in <tt>/usr/bin/gcc</tt>);
        "<tt>//</tt>" means an element any levels under the current element.
  <li> "<tt>.</tt>", "<tt>..</tt>" and "<tt>*</tt>" mean the current element,
        the parent element, and an element with any tag name, respectively.
  <li> Element tag names and "<tt>*</tt>" can have an optional predicate
        in the form "<tt>[position]</tt>" or "<tt>[@attribute='value']</tt>".
        Positions start from zero.
  <li> Predicate of the form "<tt>[@attribute=<i>$param</i>]</tt>" are also
        accepted, where <tt><i>$param</i></tt> can be one of:
        <tt>$MODULE_FULLPATH</tt>,
        <tt>$MODULE_FULLNAME</tt>,
        <tt>$MODULE_NAME</tt>,
        <tt>$MODULE_INDEX</tt>,
        <tt>$MODULE_ID</tt>,
        <tt>$PARENTMODULE_FULLPATH</tt>,
        <tt>$PARENTMODULE_FULLNAME</tt>,
        <tt>$PARENTMODULE_NAME</tt>,
        <tt>$PARENTMODULE_INDEX</tt>,
        <tt>$PARENTMODULE_ID</tt>,
        <tt>$GRANDPARENTMODULE_FULLPATH</tt>,
        <tt>$GRANDPARENTMODULE_FULLNAME</tt>,
        <tt>$GRANDPARENTMODULE_NAME</tt>,
        <tt>$GRANDPARENTMODULE_INDEX</tt>,
        <tt>$GRANDPARENTMODULE_ID</tt>.
</ul>

<p><H3><A NAME="sec455"/>15.15.6 Functions</H3>
<!--ned!functions-->

<p>The functions available in NED are listed in Appendix
<a href="#sec459">[18]</a>.

<p><H3><A NAME="sec456"/>15.15.7 Physical units</H3>
<a name="ch-ned-ref:sec:units"></a>

<p>The following physical units will be recorgnized in constants. Other units can
be used as well, the only downside being that OMNeT++ will not be able to
perform conversions on them.

<p><table border>
<TR> <TD align=center>

<p>  <b>Unit</b> </TD> <TD align=center> <b>Name</b> </TD> <TD align=right> <b>Value</b> </TD></TR>
<TR> <TD align=center>   s </TD> <TD align=center> second </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   d </TD> <TD align=center> day </TD> <TD align=right> 86400s </TD></TR>
<TR> <TD align=center>   h </TD> <TD align=center> hour </TD> <TD align=right> 3600s </TD></TR>
<TR> <TD align=center>   min </TD> <TD align=center> minute </TD> <TD align=right> 60s </TD></TR>
<TR> <TD align=center>   ms </TD> <TD align=center> millisecond </TD> <TD align=right> 1e-3s </TD></TR>
<TR> <TD align=center>   us </TD> <TD align=center> microsecond </TD> <TD align=right> 1e-6s </TD></TR>
<TR> <TD align=center>   ns </TD> <TD align=center> nanosecond </TD> <TD align=right> 1e-9s </TD></TR>
<TR> <TD align=center>   ps </TD> <TD align=center> picosecond </TD> <TD align=right> 1e-12s </TD></TR>
<TR> <TD align=center>   bps </TD> <TD align=center> bit/sec </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   Kbps </TD> <TD align=center> kilobit/sec </TD> <TD align=right> 1e3bps </TD></TR>
<TR> <TD align=center>   Mbps </TD> <TD align=center> megabit/sec </TD> <TD align=right> 1e6bps </TD></TR>
<TR> <TD align=center>   Gbps </TD> <TD align=center> gigabit/sec </TD> <TD align=right> 1e9bps </TD></TR>
<TR> <TD align=center>   Tbps </TD> <TD align=center> terabit/sec </TD> <TD align=right> 1e12bps </TD></TR>
<TR> <TD align=center>   B </TD> <TD align=center> byte </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   KB </TD> <TD align=center> kilobyte </TD> <TD align=right> 1024B </TD></TR>
<TR> <TD align=center>   MB </TD> <TD align=center> megabyte </TD> <TD align=right> 1.04858e6B </TD></TR>
<TR> <TD align=center>   GB </TD> <TD align=center> gigabyte </TD> <TD align=right> 1.07374e9B </TD></TR>
<TR> <TD align=center>   TB </TD> <TD align=center> terabyte </TD> <TD align=right> 1.09951e12B </TD></TR>
<TR> <TD align=center>   b </TD> <TD align=center> bit </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   m </TD> <TD align=center> meter </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   km </TD> <TD align=center> kilometer </TD> <TD align=right> 1e3m </TD></TR>
<TR> <TD align=center>   cm </TD> <TD align=center> centimeter </TD> <TD align=right> 1e-2m </TD></TR>
<TR> <TD align=center>   mm </TD> <TD align=center> millimeter </TD> <TD align=right> 1e-3m </TD></TR>
<TR> <TD align=center>   W </TD> <TD align=center> watt </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   mW </TD> <TD align=center> milliwatt </TD> <TD align=right> 1e-3W </TD></TR>
<TR> <TD align=center>   Hz </TD> <TD align=center> herz </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kHz </TD> <TD align=center> kiloherz </TD> <TD align=right> 1e3Hz </TD></TR>
<TR> <TD align=center>   MHz </TD> <TD align=center> megaherz </TD> <TD align=right> 1e6Hz </TD></TR>
<TR> <TD align=center>   GHz </TD> <TD align=center> gigaherz </TD> <TD align=right> 1e9Hz </TD></TR>
<TR> <TD align=center>   g </TD> <TD align=center> gram </TD> <TD align=right> 1e-3kg </TD></TR>
<TR> <TD align=center>   kg </TD> <TD align=center> kilogram </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   J </TD> <TD align=center> joule </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kJ </TD> <TD align=center> kilojoule </TD> <TD align=right> 1e3J </TD></TR>
<TR> <TD align=center>   MJ </TD> <TD align=center> megajoule </TD> <TD align=right> 1e6J </TD></TR>
<TR> <TD align=center>   V </TD> <TD align=center> volt </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   kV </TD> <TD align=center> kilovolt </TD> <TD align=right> 1e3V </TD></TR>
<TR> <TD align=center>   mV </TD> <TD align=center> millivolt </TD> <TD align=right> 1e-3V </TD></TR>
<TR> <TD align=center>   A </TD> <TD align=center> amper </TD> <TD align=right> </TD></TR>
<TR> <TD align=center>   mA </TD> <TD align=center> milliamper </TD> <TD align=right> 1e-3A </TD></TR>
<TR> <TD align=center>   uA </TD> <TD align=center> microamper </TD> <TD align=right> 1e-6A </TD></TR>
</table>

<p>



<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec457"/>16 NED Language Grammar</H1>
<a name="cha:ned-language-grammar"></a>

<p>This appendix contains the grammar for the NED language<!--ned!language-->.

<p>In the NED language, space, horizontal tab and new line characters count
as delimiters, so one or more of them is required between two elements of the
description which would otherwise be unseparable.

<p>'//' (two slashes) may be used to write comments that last to the end of the line.

<p>The language is fully case sensitive.

<p>Notation:
<ul>
  <li>rule syntax is that of <i>bison</i>/<i>yacc</i>
  <li>uppercase words are terminals, lowercase words are nonterminals
  <li><tt>NAME</tt>, <tt>STRINGCONSTANT</tt>, <tt>INTCONSTANT</tt>,
        <tt>REALCONSTANT</tt> represent identifier names and string,
        integer and real number literals (defined as in the C language)
  <li>other terminals represent keywords in all lowercase
</ul>

<p>

<pre>
nedfile
        : definitions
        |
        ;

definitions
        : definitions definition
        | definition
        ;

definition
        : packagedeclaration
        | import
        | propertydecl
        | fileproperty
        | channeldefinition
        | channelinterfacedefinition
        | simplemoduledefinition
        | compoundmoduledefinition
        | networkdefinition
        | moduleinterfacedefinition
        | ';'
        ;

packagedeclaration
        : PACKAGE dottedname ';'
        ;

dottedname
        : dottedname '.' NAME
        | NAME
        ;

import
        : IMPORT importspec ';'
        ;

importspec
        : importspec '.' importname
        | importname
        ;

importname
        : importname NAME
        | importname '*'
        | importname '**'
        | NAME
        | '*'
        | '**'
        ;

propertydecl
        : propertydecl_header opt_inline_properties ';'
        | propertydecl_header '(' opt_propertydecl_keys ')' opt_inline_properties ';'
        ;

propertydecl_header
        : PROPERTY '@' NAME
        | PROPERTY '@' NAME '[' ']'
        ;

opt_propertydecl_keys
        : propertydecl_keys
        |
        ;

propertydecl_keys
        : propertydecl_keys ';' propertydecl_key
        | propertydecl_key
        ;

propertydecl_key
        : NAME
        ;

fileproperty
        : property_namevalue ';'
        ;

channeldefinition
        : channelheader '{'
            opt_paramblock
          '}'
        ;

channelheader
        : CHANNEL NAME
           opt_inheritance
        ;

opt_inheritance
        :
        | EXTENDS extendsname
        | LIKE likenames
        | EXTENDS extendsname LIKE likenames
        ;

extendsname
        : dottedname
        ;

likenames
        : likenames ',' likename
        | likename
        ;

likename
        : dottedname
        ;

channelinterfacedefinition
        : channelinterfaceheader '{'
            opt_paramblock
          '}'
        ;

channelinterfaceheader
        : CHANNELINTERFACE NAME
           opt_interfaceinheritance
        ;

opt_interfaceinheritance
        : EXTENDS extendsnames
        |
        ;

extendsnames
        : extendsnames ',' extendsname
        | extendsname
        ;

simplemoduledefinition
        : simplemoduleheader '{'
            opt_paramblock
            opt_gateblock
          '}'
        ;

simplemoduleheader
        : SIMPLE NAME
          opt_inheritance
        ;

compoundmoduledefinition
        : compoundmoduleheader '{'
            opt_paramblock
            opt_gateblock
            opt_typeblock
            opt_submodblock
            opt_connblock
          '}'
        ;

compoundmoduleheader
        : MODULE NAME
          opt_inheritance
        ;

networkdefinition
        : networkheader '{'
            opt_paramblock
            opt_gateblock
            opt_typeblock
            opt_submodblock
            opt_connblock
          '}'
        ;

networkheader
        : NETWORK NAME
          opt_inheritance
        ;

moduleinterfacedefinition
        : moduleinterfaceheader '{'
            opt_paramblock
            opt_gateblock
          '}'
        ;

moduleinterfaceheader
        : MODULEINTERFACE NAME
           opt_interfaceinheritance
        ;

opt_paramblock
        : opt_params
        | PARAMETERS ':'
          opt_params
        ;

opt_params
        : params
        |
        ;

params
        : params paramsitem
        | paramsitem
        ;

paramsitem
        : param
        | property
        ;

param
        : param_typenamevalue
        | pattern_value
        ;

param_typenamevalue
        : param_typename opt_inline_properties ';'
        | param_typename opt_inline_properties '=' paramvalue opt_inline_properties ';'
        ;

param_typename
        : opt_volatile paramtype NAME
        | NAME
        ;

pattern_value
        : '/' pattern '/' '=' paramvalue
        ;

paramtype
        : DOUBLE
        | INT
        | STRING
        | BOOL
        | XML
        ;

opt_volatile
        : VOLATILE
        |
        ;

paramvalue
        : expression
        | DEFAULT '(' expression ')'
        ;

opt_inline_properties
        : inline_properties
        |
        ;

inline_properties
        : inline_properties property_namevalue
        | property_namevalue
        ;

pattern
        : pattern pattern_elem
        | pattern_elem
        ;

pattern_elem
        : '.'
        | '*'
        | '?'
        | '**'
        | NAME
        | INTCONSTANT
        | '..'
        | '[' pattern ']'
        | '{' pattern '}'
        | IMPORT | PACKAGE | PROPERTY
        | MODULE | SIMPLE | NETWORK | CHANNEL | MODULEINTERFACE | CHANNELINTERFACE
        | EXTENDS | LIKE
        | DOUBLE | INT | STRING | BOOL | XML | VOLATILE
        | INPUT | OUTPUT | INOUT | IF | FOR
        | TYPES | PARAMETERS | GATES | SUBMODULES | CONNECTIONS | ALLOWUNCONNECTED
        | TRUE | FALSE | THIS | DEFAULT | CONST | SIZEOF | INDEX | XMLDOC
        ;

property
        : property_namevalue ';'
        ;

property_namevalue
        : property_name
        | property_name '(' opt_property_keys ')'
        ;

property_name
        : '@' NAME
        | '@' NAME '[' NAME ']'
        ;

opt_property_keys
        : property_keys
        ;

property_keys
        : property_keys ';' property_key
        | property_key
        ;

property_key
        : NAME '=' property_values
        | property_values
        ;

property_values
        : property_values ',' property_value
        | property_value
        ;

property_value
        : NAME
        | '$' NAME
        | STRINGCONSTANT
        | TRUE
        | FALSE
        | INTCONSTANT
        | REALCONSTANT
        | quantity
        | '-'
        |
        ;

opt_gateblock
        : gateblock
        |
        ;

gateblock
        : GATES ':'
          opt_gates
        ;

opt_gates
        : gates
        |
        ;

gates
        : gates gate
        | gate
        ;

gate
        : gate_typenamesize
          opt_inline_properties ';'
        ;

gate_typenamesize
        : gatetype NAME
        | gatetype NAME '[' ']'
        | gatetype NAME vector
        | NAME
        | NAME '[' ']'
        | NAME vector
        ;

gatetype
        : INPUT
        | OUTPUT
        | INOUT
        ;

opt_typeblock
        : typeblock
        |
        ;

typeblock
        : TYPES ':'
           opt_localtypes
        ;

opt_localtypes
        : localtypes
        |
        ;

localtypes
        : localtypes localtype
        | localtype
        ;

localtype
        : propertydecl
        | channeldefinition
        | channelinterfacedefinition
        | simplemoduledefinition
        | compoundmoduledefinition
        | networkdefinition
        | moduleinterfacedefinition
        | ';'
        ;

opt_submodblock
        : submodblock
        |
        ;

submodblock
        : SUBMODULES ':'
          opt_submodules
        ;

opt_submodules
        : submodules
        |
        ;

submodules
        : submodules submodule
        | submodule
        ;

submodule
        : submoduleheader ';'
        | submoduleheader '{'
          opt_paramblock
          opt_gateblock
          '}' opt_semicolon
        ;

submoduleheader
        : submodulename ':' dottedname
        | submodulename ':' likeparam LIKE dottedname
        ;

submodulename
        : NAME
        |  NAME vector
        ;

likeparam
        : '&lt;' '&gt;'
        | '&lt;' expression '&gt;'
        ;

opt_connblock
        : connblock
        |
        ;

connblock
        : CONNECTIONS ALLOWUNCONNECTED ':'
          opt_connections
        | CONNECTIONS ':'
          opt_connections
        ;

opt_connections
        : connections
        |
        ;

connections
        : connections connectionsitem
        | connectionsitem
        ;

connectionsitem
        : connectiongroup
        | connection opt_loops_and_conditions ';'
        ;

connectiongroup
        : opt_loops_and_conditions '{'
          connections '}' opt_semicolon
        ;

opt_loops_and_conditions
        : loops_and_conditions
        |
        ;

loops_and_conditions
        : loops_and_conditions ',' loop_or_condition
        | loop_or_condition
        ;

loop_or_condition
        : loop
        | condition
        ;

loop
        : FOR NAME '=' expression '..' expression
        ;

connection
        : leftgatespec '--&gt;' rightgatespec
        | leftgatespec '--&gt;' channelspec '--&gt;' rightgatespec
        | leftgatespec '&lt;--' rightgatespec
        | leftgatespec '&lt;--' channelspec '&lt;--' rightgatespec
        | leftgatespec '&lt;--&gt;' rightgatespec
        | leftgatespec '&lt;--&gt;' channelspec '&lt;--&gt;' rightgatespec
        ;

leftgatespec
        : leftmod '.' leftgate
        | parentleftgate
        ;

leftmod
        : NAME vector
        | NAME
        ;

leftgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

parentleftgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

rightgatespec
        : rightmod '.' rightgate
        | parentrightgate
        ;

rightmod
        : NAME
        | NAME vector
        ;

rightgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

parentrightgate
        : NAME opt_subgate
        | NAME opt_subgate vector
        | NAME opt_subgate '++'
        ;

opt_subgate
        : '$' NAME
        |
        ;

channelspec
        : channelspec_header
        | channelspec_header '{'
            opt_paramblock
          '}'
        ;

channelspec_header
        :
        | dottedname
        | likeparam LIKE dottedname
        ;

condition
        : IF expression
        ;

vector
        : '[' expression ']'
        ;

expression
        :
          expr
        | xmldocvalue
        ;

xmldocvalue
        : XMLDOC '(' stringliteral ',' stringliteral ')'
        | XMLDOC '(' stringliteral ')'
        ;

expr
        : simple_expr
        | '(' expr ')'
        | CONST '(' expr ')'
        | expr '+' expr
        | expr '-' expr
        | expr '*' expr
        | expr '/' expr
        | expr '%' expr
        | expr '^' expr
        | '-' expr
        | expr '==' expr
        | expr '!=' expr
        | expr '&gt;' expr
        | expr '&gt;=' expr
        | expr '&lt;' expr
        | expr '&lt;=' expr
        | expr '&&' expr
        | expr '||' expr
        | expr '##' expr
        | '!' expr
        | expr '&' expr
        | expr '|' expr
        | expr '#' expr
        | '~' expr
        | expr '&lt;&lt;' expr
        | expr '&gt;&gt;' expr
        | expr '?' expr ':' expr
        | INT '(' expr ')'
        | DOUBLE '(' expr ')'
        | STRING '(' expr ')'
        | NAME '(' ')'
        | NAME '(' expr ')'
        | NAME '(' expr ',' expr ')'
        | NAME '(' expr ',' expr ',' expr ')'
        | NAME '(' expr ',' expr ',' expr ',' expr ')'
        | NAME '(' expr ',' expr ',' expr ',' expr ',' expr ')'
        | NAME '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | NAME '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | NAME '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | NAME '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        | NAME '(' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
        ;

simple_expr
        : identifier
        | special_expr
        | literal
        ;

identifier
        : NAME
        | THIS '.' NAME
        | NAME '.' NAME
        | NAME '[' expr ']' '.' NAME
        ;

special_expr
        : INDEX
        | INDEX '(' ')'
        | SIZEOF '(' identifier ')'
        ;

literal
        : stringliteral
        | boolliteral
        | numliteral
        ;

stringliteral
        : STRINGCONSTANT
        ;

boolliteral
        : TRUE
        | FALSE
        ;

numliteral
        : INTCONSTANT
        | REALCONSTANT
        | quantity
        ;

quantity
        : quantity INTCONSTANT NAME
        | quantity REALCONSTANT NAME
        | INTCONSTANT NAME
        | REALCONSTANT NAME
        ;

opt_semicolon
        : ';'
        |
        ;

</pre>

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec458"/>17 NED XML Binding</H1>
<a name="cha:ned-xml-binding"></a>

<p>This appendix shows the DTD for the XML binding of the NED language and
message definitions.

<pre>
&lt;!ELEMENT files ((ned-file|msg-file)*)&gt;

&lt;!--
  **  NED-2.
  --&gt;

&lt;!ELEMENT ned-file (comment*, (package|import|property-decl|property|channel|
                    channel-interface|simple-module|compound-module|module-interface)*)&gt;
&lt;!ATTLIST ned-file
     filename           CDATA     #REQUIRED
     version            CDATA     "2"&gt;

&lt;!-- comments and whitespace; comments include '//' marks. Note that although
     nearly all elements may contain comment elements, there are places
     (e.g. within expressions) where they are ignored by the implementation.
     Default value is a space or a newline, depending on the context.
 --&gt;
&lt;!ELEMENT comment EMPTY&gt;
&lt;!ATTLIST comment
     locid              NMTOKEN   #REQUIRED
     content            CDATA     #IMPLIED&gt;

&lt;!ELEMENT package (comment*)&gt;
&lt;!ATTLIST package
     name               CDATA     #REQUIRED&gt;

&lt;!ELEMENT import (comment*)&gt;
&lt;!ATTLIST import
     import-spec        CDATA     #REQUIRED&gt;

&lt;!ELEMENT property-decl (comment*, property-key*, property*)&gt;
&lt;!ATTLIST property-decl
     name               NMTOKEN   #REQUIRED
     is-array           (true|false) "false"&gt;

&lt;!ELEMENT extends (comment*)&gt;
&lt;!ATTLIST extends
     name               CDATA     #REQUIRED&gt;

&lt;!ELEMENT interface-name (comment*)&gt;
&lt;!ATTLIST interface-name
     name               CDATA     #REQUIRED&gt;

&lt;!ELEMENT simple-module (comment*, extends?, interface-name*, parameters?, gates?)&gt;
&lt;!ATTLIST simple-module
     name               NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT module-interface (comment*, extends*, parameters?, gates?)&gt;
&lt;!ATTLIST module-interface
     name               NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT compound-module (comment*, extends?, interface-name*,
                           parameters?, gates?, types?, submodules?, connections?)&gt;
&lt;!ATTLIST compound-module
     name               NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT channel-interface (comment*, extends*, parameters?)&gt;
&lt;!ATTLIST channel-interface
     name                NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT channel (comment*, extends?, interface-name*, parameters?)&gt;
&lt;!ATTLIST channel
     name                NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT parameters (comment*, (property|param|pattern)*)&gt;
&lt;!ATTLIST parameters
    is-implicit         (true|false)  "false"&gt;

&lt;!ELEMENT param (comment*, expression?, property*)&gt;
&lt;!ATTLIST param
     type               (double|int|string|bool|xml) #IMPLIED
     is-volatile        (true|false)  "false"
     name               NMTOKEN   #REQUIRED
     value              CDATA     #IMPLIED
     is-default         (true|false)  "false"&gt;

&lt;!ELEMENT pattern (comment*, expression?, property*)&gt;
&lt;!ATTLIST pattern
     pattern            CDATA     #REQUIRED
     value              CDATA     #IMPLIED
     is-default         (true|false)  "false"&gt;

&lt;!ELEMENT property (comment*, property-key*)&gt;
&lt;!ATTLIST property
     is-implicit        (true|false) "false"
     name               NMTOKEN   #REQUIRED
     index              NMTOKEN   #IMPLIED&gt;

&lt;!ELEMENT property-key (comment*, literal*)&gt;
&lt;!ATTLIST property-key
     name               CDATA     #IMPLIED&gt;

&lt;!ELEMENT gates (comment*, gate*)&gt;

&lt;!ELEMENT gate (comment*, expression?, property*)&gt;
&lt;!ATTLIST gate
     name               NMTOKEN   #REQUIRED
     type               (input|output|inout) #IMPLIED
     is-vector          (true|false) "false"
     vector-size        CDATA     #IMPLIED&gt;

&lt;!ELEMENT types (comment*, (channel|channel-interface|simple-module|
                               compound-module|module-interface)*)&gt;

&lt;!ELEMENT submodules (comment*, submodule*)&gt;

&lt;!ELEMENT submodule (comment*, expression*, parameters?, gates?)&gt;
&lt;!ATTLIST submodule
     name               NMTOKEN   #REQUIRED
     type               CDATA     #IMPLIED
     like-type          CDATA     #IMPLIED
     like-param         CDATA     #IMPLIED
     vector-size        CDATA     #IMPLIED&gt;

&lt;!ELEMENT connections (comment*, (connection|connection-group)*)&gt;
&lt;!ATTLIST connections
     allow-unconnected (true|false) "false"&gt;

&lt;!ELEMENT connection (comment*, expression*, channel-spec?, (loop|condition)*)&gt;
&lt;!ATTLIST connection
     src-module          NMTOKEN   #IMPLIED
     src-module-index    CDATA     #IMPLIED
     src-gate            NMTOKEN   #REQUIRED
     src-gate-plusplus  (true|false) "false"
     src-gate-index      CDATA     #IMPLIED
     src-gate-subg       (i|o)     #IMPLIED
     dest-module         NMTOKEN   #IMPLIED
     dest-module-index   CDATA     #IMPLIED
     dest-gate           NMTOKEN   #REQUIRED
     dest-gate-plusplus (true|false) "false"
     dest-gate-index     CDATA     #IMPLIED
     dest-gate-subg      (i|o)     #IMPLIED
     arrow-direction    (l2r|r2l|bidir) #REQUIRED&gt;

&lt;!ELEMENT channel-spec (comment*, expression*, parameters?)&gt;
&lt;!ATTLIST channel-spec
     type               CDATA     #IMPLIED
     like-type          CDATA     #IMPLIED
     like-param         CDATA     #IMPLIED&gt;

&lt;!ELEMENT connection-group (comment*, (loop|condition)*, connection*)&gt;

&lt;!ELEMENT loop (comment*, expression*)&gt;
&lt;!ATTLIST loop
     param-name          NMTOKEN   #REQUIRED
     from-value          CDATA     #IMPLIED
     to-value            CDATA     #IMPLIED&gt;

&lt;!ELEMENT condition (comment*, expression?)&gt;
&lt;!ATTLIST condition
     condition           CDATA     #IMPLIED&gt;

&lt;!--
  **  Expressions
  --&gt;

&lt;!ELEMENT expression (comment*, (operator|function|ident|literal))&gt;
&lt;!ATTLIST expression
     target              CDATA     #IMPLIED&gt;

&lt;!ELEMENT operator (comment*, (operator|function|ident|literal)+)&gt;
&lt;!ATTLIST operator
     name                CDATA     #REQUIRED&gt;

&lt;!-- functions, "index", "const" and "sizeof" --&gt;
&lt;!ELEMENT function (comment*, (operator|function|ident|literal)*)&gt;
&lt;!ATTLIST function
     name                NMTOKEN   #REQUIRED&gt;

&lt;!-- Ident is either a parameter reference or an identifier for 'sizeof' operator
     format is 'name' or 'module.name' or 'module[n].name'. If there's a child,
     that's the module index n.
--&gt;
&lt;!ELEMENT ident (comment*, (operator|function|ident|literal)?)&gt;
&lt;!ATTLIST ident
     module              CDATA     #IMPLIED
     name                NMTOKEN   #REQUIRED&gt;


&lt;!ELEMENT literal (comment*)&gt;
&lt;!-- Note: value is in fact REQUIRED, but empty attr value should
     also be accepted because that represents the "" string literal;
     "spec" is for properties, to store the null value and "-",
     the antivalue. Unit can only be present with "double".
 --&gt;
&lt;!ATTLIST literal
     type  (double|int|string|bool|spec)  #REQUIRED
     unit                CDATA     #IMPLIED
     text                CDATA     #IMPLIED
     value               CDATA     #IMPLIED&gt;

&lt;!--**********************************************************************--&gt;

&lt;!--
**
** Message Definitions (MSG)
**
--&gt;

&lt;!ELEMENT msg-file (comment*, (namespace|property-decl|property|cplusplus|struct-decl|class-decl|message-decl|enum-decl|
                     enum|message|class|struct)*)&gt;

&lt;!ATTLIST msg-file
     filename            CDATA     #IMPLIED
     version             CDATA     "2"&gt;

&lt;!ELEMENT namespace (comment*)&gt;
&lt;!ATTLIST namespace
     name                CDATA     #REQUIRED&gt;  &lt;!-- note: not NMTOKEN because it may contain "::" --&gt;

&lt;!ELEMENT cplusplus (comment*)&gt;
&lt;!ATTLIST cplusplus
     body                CDATA     #REQUIRED&gt;

&lt;!-- C++ type announcements --&gt;

&lt;!ELEMENT struct-decl (comment*)&gt;
&lt;!ATTLIST struct-decl
     name                NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT class-decl (comment*)&gt;
&lt;!ATTLIST class-decl
     name                NMTOKEN   #REQUIRED
     is-cobject      (true|false)  "false"&gt;

&lt;!ELEMENT message-decl (comment*)&gt;
&lt;!ATTLIST message-decl
     name                NMTOKEN   #REQUIRED&gt;

&lt;!ELEMENT enum-decl (comment*)&gt;
&lt;!ATTLIST enum-decl
     name                NMTOKEN   #REQUIRED&gt;

&lt;!-- Enums --&gt;

&lt;!ELEMENT enum (comment*, enum-fields?)&gt;
&lt;!ATTLIST enum
     name                NMTOKEN   #REQUIRED
     extends-name        NMTOKEN   #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT enum-fields (comment*, enum-field*)&gt;

&lt;!ELEMENT enum-field (comment*)&gt;
&lt;!ATTLIST enum-field
     name                NMTOKEN   #REQUIRED
     value               CDATA     #IMPLIED&gt;

&lt;!-- Message, class, struct --&gt;

&lt;!ELEMENT message (comment*, (property|field)*)&gt;
&lt;!ATTLIST message
     name                NMTOKEN   #REQUIRED
     extends-name        NMTOKEN   #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT class (comment*, (property|field)*)&gt;
&lt;!ATTLIST class
     name                NMTOKEN   #REQUIRED
     extends-name        NMTOKEN   #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT struct (comment*, (property|field)*)&gt;
&lt;!ATTLIST struct
     name                NMTOKEN   #REQUIRED
     extends-name        NMTOKEN   #IMPLIED
     source-code         CDATA     #IMPLIED&gt;

&lt;!ELEMENT field (comment*)&gt;
&lt;!ATTLIST field
     name                NMTOKEN   #REQUIRED
     data-type           CDATA     #IMPLIED
     is-abstract     (true|false)  "false"
     is-readonly     (true|false)  "false"
     is-vector       (true|false)  "false"
     vector-size         CDATA     #IMPLIED
     enum-name           NMTOKEN   #IMPLIED
     default-value       CDATA     #IMPLIED&gt;

&lt;!--
  **  'unknown' is used internally to represent elements not in this NED DTD
  --&gt;
&lt;!ELEMENT unknown        ANY&gt;
&lt;!ATTLIST unknown
     element             CDATA     #REQUIRED&gt;


</pre>
<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec459"/>18 NED Functions</H1>
<a name="cha:ned-functions"></a>

<p>This appendix lists the functions that can be used in NED
expressions and ini files:


<p>
<pre>
acos : (double) -&gt; double
ancestorIndex : (long) -&gt; long
asin : (double) -&gt; double
atan : (double) -&gt; double
atan2 : (double,double) -&gt; double
bernoulli : (double[,long]) -&gt; long
beta : (double,double[,long]) -&gt; double
binomial : (long,double[,long]) -&gt; long
cauchy : (quantity,quantity[,long]) -&gt; quantity
ceil : (double) -&gt; double
chi_square : (long[,long]) -&gt; double
choose : (long,string) -&gt; string
contains : (string,string) -&gt; bool
convertUnit : (quantity,string) -&gt; quantity
cos : (double) -&gt; double
double : (any) -&gt; double
dropUnit : (quantity) -&gt; double
endsWith : (string,string) -&gt; bool
erlang_k : (long,quantity[,long]) -&gt; quantity
exp : (double) -&gt; double
exponential : (quantity[,long]) -&gt; quantity
fabs : (quantity) -&gt; quantity
floor : (double) -&gt; double
fmod : (quantity,quantity) -&gt; quantity
fullName : () -&gt; string
fullPath : () -&gt; string
gamma_d : (double,quantity[,long]) -&gt; quantity
genk_exponential : (double,double) -&gt; double
genk_intuniform : (double,double,double) -&gt; double
genk_normal : (double,double,double) -&gt; double
genk_truncnormal : (double,double,double) -&gt; double
genk_uniform : (double,double,double) -&gt; double
geometric : (double[,long]) -&gt; long
hypot : (double,double) -&gt; double
indexOf : (string,string) -&gt; long
int : (any) -&gt; long
intuniform : (long,long[,long]) -&gt; long
length : (string) -&gt; long
log : (double) -&gt; double
log10 : (double) -&gt; double
lognormal : (double,double[,long]) -&gt; double
max : (quantity,quantity) -&gt; quantity
min : (quantity,quantity) -&gt; quantity
negbinomial : (long,double[,long]) -&gt; long
normal : (quantity,quantity[,long]) -&gt; quantity
parentIndex : () -&gt; long
pareto_shifted : (double,quantity,quantity[,long]) -&gt; quantity
poisson : (double[,long]) -&gt; long
pow : (double,double) -&gt; double
replace : (string,string,string[,long]) -&gt; string
replaceFirst : (string,string,string[,long]) -&gt; string
replaceUnit : (quantity,string) -&gt; quantity
sin : (double) -&gt; double
sqrt : (double) -&gt; double
startsWith : (string,string) -&gt; bool
string : (any) -&gt; string
student_t : (long[,long]) -&gt; double
substring : (string,long[,long]) -&gt; string
substringAfter : (string,string) -&gt; string
substringAfterLast : (string,string) -&gt; string
substringBefore : (string,string) -&gt; string
substringBeforeLast : (string,string) -&gt; string
tail : (string,long) -&gt; string
tan : (double) -&gt; double
toLower : (string) -&gt; string
toUpper : (string) -&gt; string
triang : (quantity,quantity,quantity[,long]) -&gt; quantity
trim : (string) -&gt; string
truncnormal : (quantity,quantity[,long]) -&gt; quantity
uniform : (quantity,quantity[,long]) -&gt; quantity
unitOf : (quantity) -&gt; string
weibull : (quantity,quantity[,long]) -&gt; quantity
</pre>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec460"/>19 Message Definitions Grammar</H1>
<a name="cha:msg-language-grammar"></a>

<p>This appendix contains the grammar for the message definitions
language.

<p>In the language, space, horizontal tab and new line characters count
as delimiters, so one or more of them is required between two elements of the
description which would otherwise be unseparable.

<p>'//' (two slashes) may be used to write comments that last to the end of the line.

<p>The language is fully case sensitive.

<p>Notation:
<ul>
  <li>rule syntax is that of <i>bison</i>/<i>yacc</i>
  <li>uppercase words are terminals, lowercase words are nonterminals
  <li><tt>NAME</tt>, <tt>CHARCONSTANT</tt>, <tt>STRINGCONSTANT</tt>, <tt>INTCONSTANT</tt>,
        <tt>REALCONSTANT</tt> represent identifier names and string, character,
        integer and real number literals (defined as in the C language)
  <li>other terminals represent keywords in all lowercase
</ul>

<p>Nonterminals ending in <tt>_old</tt> are present so that message files
from the previous versions of OMNeT++ (3.x) can be parsed.


<pre>


msgfile
        : definitions
        ;

definitions
        : definitions definition
        |
        ;

definition
        : namespace_decl
        | cplusplus
        | struct_decl
        | class_decl
        | message_decl
        | enum_decl
        | enum
        | message
        | class
        | struct
        ;

namespace_decl
        : NAMESPACE namespacename ';'

namespacename
        : namespacename ':' ':' NAME
        | NAME
        ;

cplusplus
        : CPLUSPLUS '{{' ... '}}' opt_semicolon
        ;

struct_decl
        : STRUCT NAME ';'
        ;

class_decl
        : CLASS NAME ';'
        | CLASS NONCOBJECT NAME ';'
        ;

message_decl
        : MESSAGE NAME ';'
        ;

enum_decl
        : ENUM NAME ';'
        ;

enum
        : ENUM NAME '{'
          opt_enumfields '}' opt_semicolon
        | ENUM NAME EXTENDS NAME '{'
          opt_enumfields '}' opt_semicolon
        ;

opt_enumfields
        : enumfields
        |
        ;

enumfields
        : enumfields enumfield
        | enumfield
        ;

enumfield
        : NAME ';'
        | NAME '=' enumvalue ';'
        ;

message
        : message_header body
        ;

class
        : class_header body
        ;

struct
        : struct_header body
        ;

message_header
        : MESSAGE NAME '{'
        | MESSAGE NAME EXTENDS NAME '{'
        ;

class_header
        : CLASS NAME '{'
        | CLASS NAME EXTENDS NAME '{'
        ;

struct_header
        : STRUCT NAME '{'
        | STRUCT NAME EXTENDS NAME '{'
        ;

body
        : opt_fields_and_properties
          opt_propertiesblock_old
          opt_fieldsblock_old
          '}' opt_semicolon
        ;

opt_fields_and_properties
        : fields_and_properties
        |
        ;

fields_and_properties
        : fields_and_properties field
        | fields_and_properties property
        | field
        | property
        ;

field
        : fieldmodifiers fielddatatype NAME
           opt_fieldvector opt_fieldenum opt_fieldvalue ';'
        | fieldmodifiers NAME
           opt_fieldvector opt_fieldenum opt_fieldvalue ';'
        ;

fieldmodifiers
        : ABSTRACT
        | READONLY
        | ABSTRACT READONLY
        | READONLY ABSTRACT
        |
        ;

fielddatatype
        : NAME
        | NAME '*'
        | CHAR
        | SHORT
        | INT
        | LONG
        | UNSIGNED CHAR
        | UNSIGNED SHORT
        | UNSIGNED INT
        | UNSIGNED LONG
        | DOUBLE
        | STRING
        | BOOL
        ;

opt_fieldvector
        : '[' INTCONSTANT ']'
        | '[' NAME ']'
        | '[' ']'
        |
        ;

opt_fieldenum
        : ENUM '(' NAME ')'
        |
        ;

opt_fieldvalue
        : '=' fieldvalue
        |
        ;

fieldvalue
        : fieldvalue fieldvalueitem
        | fieldvalueitem
        ;

fieldvalueitem
        : STRINGCONSTANT
        | CHARCONSTANT
        | INTCONSTANT
        | REALCONSTANT
        | TRUE
        | FALSE
        | NAME
        | '?' | ':' | '&&' | '||' | '##' | '==' | '!=' | '&gt;' | '&gt;=' | '&lt;' | '&lt;='
        | '&' | '|' | '#' | '&lt;&lt;' | '&gt;&gt;'
        | '+' | '-' | '*' | '/' | '%' | '^' | '&' | UMIN | '!' | '~'
        | '.' | ',' | '(' | ')' | '[' | ']'
        ;

enumvalue
        : INTCONSTANT
        | '-' INTCONSTANT
        | NAME
        ;

quantity
        : quantity INTCONSTANT NAME
        | quantity REALCONSTANT NAME
        | INTCONSTANT NAME
        | REALCONSTANT NAME
        ;

property
        : property_namevalue ';'
        ;

property_namevalue
        : property_name
        | property_name '(' opt_property_keys ')'
        ;

property_name
        : '@' NAME
        | '@' NAME '[' NAME ']'
        ;

opt_property_keys
        : property_keys
        ;

property_keys
        : property_keys ';' property_key
        | property_key
        ;

property_key
        : NAME '=' property_values
        | property_values
        ;

property_values
        : property_values ',' property_value
        | property_value
        ;

property_value
        : NAME
        | '$' NAME
        | STRINGCONSTANT
        | TRUE
        | FALSE
        | INTCONSTANT
        | REALCONSTANT
        | quantity
        | '-'
        |
        ;

opt_fieldsblock_old
        : FIELDS ':'
          opt_fields_old
        |
        ;

opt_fields_old
        : fields_old
        |
        ;

fields_old
        : fields_old field
        | field
        ;

opt_propertiesblock_old
        : PROPERTIES ':'
          opt_properties_old
        |
        ;

opt_properties_old
        : properties_old
        |
        ;

properties_old
        : properties_old property_old
        | property_old
        ;

property_old
        : NAME '=' property_value ';'
        ;

opt_semicolon : ';' | ;

</pre>

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec461"/>20 Display String Tags</H1>
<a name="cha:display-string-tags"></a>

<p>This appendix lists all display string tags.


<table border>
<TR> <TD align=left>

<p><b>Tag[argument index] - name</b> </TD> <TD align=left> <b>Description</b>
</TD></TR>
<TR> <TD align=left>
<b>p</b>[0] - x
</TD> <TD align=left>
X position of the center of the icon/shape; defaults to automatic graph layouting
</TD></TR>
<TR> <TD align=left>
<b>p</b>[1] - y
</TD> <TD align=left>
Y position of the center of the icon/shape; defaults to automatic graph layouting
</TD></TR>
<TR> <TD align=left>
<b>p</b>[2] - arrangement
</TD> <TD align=left>
Arrangement of submodule vectors. Values: row (r), column (c), matrix (m), ring (ri), exact (x)
</TD></TR>
<TR> <TD align=left>
<b>p</b>[3] - arr. par1
</TD> <TD align=left>
Depends on arrangement: matrix =&gt; ncols, ring =&gt; rx, exact =&gt; dx, row =&gt; dx, column =&gt; dy
</TD></TR>
<TR> <TD align=left>
<b>p</b>[4] - arr. par2
</TD> <TD align=left>
Depends on arrangement: matrix =&gt; dx, ring =&gt; ry, exact =&gt; dy
</TD></TR>
<TR> <TD align=left>
<b>p</b>[5] - arr. par3
</TD> <TD align=left>
Depends on arrangement: matrix =&gt; dy
</TD></TR>
<TR> <TD align=left>
<b>b</b>[0] - width
</TD> <TD align=left>
Width of object. Default: 40
</TD></TR>
<TR> <TD align=left>
<b>b</b>[1] - height
</TD> <TD align=left>
Height of object. Default: 24
</TD></TR>
<TR> <TD align=left>
<b>b</b>[2] - shape
</TD> <TD align=left>
Shape of object. Values: rectangle (rect), oval (oval). Default: rect
</TD></TR>
<TR> <TD align=left>
<b>b</b>[3] - fill color
</TD> <TD align=left>
Fill color of the object (colorname or #RRGGBB or @HHSSBB). Default: #8080ff
</TD></TR>
<TR> <TD align=left>
<b>b</b>[4] - border color
</TD> <TD align=left>
Border color of the object (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>b</b>[5] - border width
</TD> <TD align=left>
Border width of the object. Default: 2
</TD></TR>
<TR> <TD align=left>
<b>i</b>[0] - icon
</TD> <TD align=left>
An icon representing the object
</TD></TR>
<TR> <TD align=left>
<b>i</b>[1] - icon color
</TD> <TD align=left>
A color to colorize the icon (colorname or #RRGGBB or @HHSSBB)
</TD></TR>
<TR> <TD align=left>
<b>i</b>[2] - icon colorization %
</TD> <TD align=left>
Amount of colorization in percent. Default: 30
</TD></TR>
<TR> <TD align=left>
<b>is</b>[0] - icon size
</TD> <TD align=left>
The size of the image. Values: very small (vs), small (s), normal (n), large (l), very large (vl)
</TD></TR>
<TR> <TD align=left>
<b>i2</b>[0] - overlay icon
</TD> <TD align=left>
An icon added to the upper right corner of the original image
</TD></TR>
<TR> <TD align=left>
<b>i2</b>[1] - overlay icon color
</TD> <TD align=left>
A color to colorize the overlay icon (colorname or #RRGGBB or @HHSSBB)
</TD></TR>
<TR> <TD align=left>
<b>i2</b>[2] - overlay icon colorization %
</TD> <TD align=left>
Amount of colorization in percent. Default: 30
</TD></TR>
<TR> <TD align=left>
<b>r</b>[0] - range
</TD> <TD align=left>
Radius of the range indicator
</TD></TR>
<TR> <TD align=left>
<b>r</b>[1] - range fill color
</TD> <TD align=left>
Fill color of the range indicator (colorname or #RRGGBB or @HHSSBB)
</TD></TR>
<TR> <TD align=left>
<b>r</b>[2] - range border color
</TD> <TD align=left>
Border color of the range indicator (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>r</b>[3] - range border width
</TD> <TD align=left>
Border width of the range indicator. Default: 1
</TD></TR>
<TR> <TD align=left>
<b>q</b>[0] - queue object
</TD> <TD align=left>
Displays the length of the named queue object
</TD></TR>
<TR> <TD align=left>
<b>t</b>[0] - text
</TD> <TD align=left>
Additional text to display
</TD></TR>
<TR> <TD align=left>
<b>t</b>[1] - text position
</TD> <TD align=left>
Position of the text. Values: left (l), right (r), top (t). Default: t
</TD></TR>
<TR> <TD align=left>
<b>t</b>[2] - text color
</TD> <TD align=left>
Color of the displayed text (colorname or #RRGGBB or @HHSSBB). Default: blue
</TD></TR>
<TR> <TD align=left>
<b>tt</b>[0] - tooltip
</TD> <TD align=left>
Tooltip to be displayed over the object
</TD></TR>
<TR> <TD align=left>
<b>bgp</b>[0] - bg x
</TD> <TD align=left>
Module background horizontal offset
</TD></TR>
<TR> <TD align=left>
<b>bgp</b>[1] - bg y
</TD> <TD align=left>
Module background vertical offset
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[0] - bg width
</TD> <TD align=left>
Width of the module background rectangle
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[1] - bg height
</TD> <TD align=left>
Height of the module background rectangle
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[2] - bg fill color
</TD> <TD align=left>
Background fill color (colorname or #RRGGBB or @HHSSBB). Default: grey82
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[3] - bg border color
</TD> <TD align=left>
Border color of the module background rectangle (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>bgb</b>[4] - bg border width
</TD> <TD align=left>
Border width of the module background rectangle. Default: 2
</TD></TR>
<TR> <TD align=left>
<b>bgtt</b>[0] - bg tooltip
</TD> <TD align=left>
Tooltip to be displayed over the module's background
</TD></TR>
<TR> <TD align=left>
<b>bgi</b>[0] - bg image
</TD> <TD align=left>
An image to be displayed as a module background
</TD></TR>
<TR> <TD align=left>
<b>bgi</b>[1] - bg image mode
</TD> <TD align=left>
How to arrange the module's background image. Values: fix (f), tile (t), stretch (s), center (c). Default: fixed
</TD></TR>
<TR> <TD align=left>
<b>bgg</b>[0] - grid tick distance
</TD> <TD align=left>
Distance between two major ticks measured in units
</TD></TR>
<TR> <TD align=left>
<b>bgg</b>[1] - grid minor ticks
</TD> <TD align=left>
Minor ticks per major ticks. Default: 1
</TD></TR>
<TR> <TD align=left>
<b>bgg</b>[2] - grid color
</TD> <TD align=left>
Color of the grid lines (colorname or #RRGGBB or @HHSSBB). Default: grey
</TD></TR>
<TR> <TD align=left>
<b>bgl</b>[0] - layout seed
</TD> <TD align=left>
Seed value for layout algorithm
</TD></TR>
<TR> <TD align=left>
<b>bgl</b>[1] - layout algorithm
</TD> <TD align=left>
Algorithm for child layouting
</TD></TR>
<TR> <TD align=left>
<b>bgs</b>[0] - pixels per unit
</TD> <TD align=left>
Number of pixels per distance unit
</TD></TR>
<TR> <TD align=left>
<b>bgs</b>[1] - unit name
</TD> <TD align=left>
Name of distance unit
</TD></TR>
<TR> <TD align=left>
<b>ls</b>[0] - line color
</TD> <TD align=left>
Connection color (colorname or #RRGGBB or @HHSSBB). Default: black
</TD></TR>
<TR> <TD align=left>
<b>ls</b>[1] - line width
</TD> <TD align=left>
Connection line width. Default: 1
</TD></TR>
<TR> <TD align=left>
<b>ls</b>[2] - line style
</TD> <TD align=left>
Connection line style. Values: solid (s), dotted (d), dashed (da). Default: solid
</TD></TR>
<TR> <TD align=left>
</table>

<p>

<p>
<H2><A NAME="sec462"/>20.1 Message display strings</H2>

<p>
<table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>oval</b>
</TD> <TD align=left>
 Ellipse with the given <i>height</i> and <i>width</i>.

<p>Defaults: <i>width</i>=10, <i>height</i>=10</TD></TR>
<TR> <TD align=left> <b>b=</b><i>width</i>,<i>height</i>,<b>rect</b>
</TD> <TD align=left>
 Rectangle with the given <i>height</i> and <i>width</i>.

<p>Defaults: <i>width</i>=10, <i>height</i>=10</TD></TR>
<TR> <TD align=left> <b>o=</b><i>fillcolor</i>,<i>outlinecolor</i>,<i>borderwidth</i>
</TD> <TD align=left>
 Specifies options for the rectangle or oval.
For color notation, see section <a href="#sec344">[9.2]</a>.

<p>Defaults: <i>fillcolor</i>=red, <i>outlinecolor</i>=black,
<i>borderwidth</i>=1</TD></TR>
<TR> <TD align=left> <b>i=</b><i>iconname</i>,<i>color</i>,<i>percentage</i>
</TD> <TD align=left>
 Use the named icon. It can be colorized, and percentage
specifies the amount of colorization. If color name is <tt>"kind"</tt>,
a message kind dependent colors is used (like default behaviour).

<p>Defaults: <i>iconname</i>: no default -- if no icon name is present, a small
red solid circle will be used;
<i>color</i>: no coloring; <i>percentage</i>: 30%</TD></TR>
<TR> <TD align=left> <b>tt=</b><i>tooltip-text</i>
</TD> <TD align=left>
 Displays the given text in a tooltip when the user moves
the mouse over the message icon.</TD></TR>
<TR> <TD align=left>
</table>

<p>

<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec463"/>21 Configuration Options</H1>
<a name="cha:config-options"></a>

<p><H2><A NAME="sec464"/>21.1 Configuration Options</H2>

<p>This section lists all configuration options that are available in ini files.
A similar list can be obtained from any simulation executable by running it
with the <tt>-h configdetails</tt> option.

<pre>
&lt;object-full-path&gt;.apply-default=&lt;bool&gt;, default:false; per-object setting
    Applies to module parameters: whether NED default values should be assigned
    if present.

cmdenv-autoflush=&lt;bool&gt;, default:false; per-run setting
    Call fflush(stdout) after each event banner or status update; affects both
    express and normal mode. Turning on autoflush may have a performance
    penalty, but it can be useful with printf-style debugging for tracking down
    program crashes.

cmdenv-config-name=&lt;string&gt;; global setting
    Specifies the name of the configuration to be run (for a value `Foo',
    section [Config Foo] will be used from the ini file). See also
    cmdenv-runs-to-execute=. The -c command line option overrides this setting.

&lt;object-full-path&gt;.cmdenv-ev-output=&lt;bool&gt;, default:true; per-object setting
    When cmdenv-express-mode=false: whether Cmdenv should print debug messages
    (ev&lt;&lt;) from the selected modules.

cmdenv-event-banner-details=&lt;bool&gt;, default:false; per-run setting
    When cmdenv-express-mode=false: print extra information after event
    banners.

cmdenv-event-banners=&lt;bool&gt;, default:true; per-run setting
    When cmdenv-express-mode=false: turns printing event banners on/off.

cmdenv-express-mode=&lt;bool&gt;, default:true; per-run setting
    Selects ``normal'' (debug/trace) or ``express'' mode.

cmdenv-extra-stack=&lt;double&gt;, unit="B", default:8KB; global setting
    Specifies the extra amount of stack that is reserved for each activity()
    simple module when the simulation is run under Cmdenv.

cmdenv-interactive=&lt;bool&gt;, default:false; global setting
    Defines what Cmdenv should do when the model contains unassigned
    parameters. In interactive mode, it asks the user. In non-interactive mode
    (which is more suitable for batch execution), Cmdenv stops with an error.

cmdenv-message-trace=&lt;bool&gt;, default:false; per-run setting
    When cmdenv-express-mode=false: print a line per message sending (by
    send(),scheduleAt(), etc) and delivery on the standard output.

cmdenv-module-messages=&lt;bool&gt;, default:true; per-run setting
    When cmdenv-express-mode=false: turns printing module ev&lt;&lt; output on/off.

cmdenv-output-file=&lt;filename&gt;; global setting
    When a filename is specified, Cmdenv redirects standard output into the
    given file. This is especially useful with parallel simulation. See the
    `fname-append-host' option as well.

cmdenv-performance-display=&lt;bool&gt;, default:true; per-run setting
    When cmdenv-express-mode=true: print detailed performance information.
    Turning it on results in a 3-line entry printed on each update, containing
    ev/sec, simsec/sec, ev/simsec, number of messages created/still
    present/currently scheduled in FES.

cmdenv-runs-to-execute=&lt;string&gt;; global setting
    Specifies which runs to execute from the selected configuration (see
    cmdenv-config-name=). It accepts a comma-separated list of run numbers or
    run number ranges, e.g. 1,3..4,7..9. If the value is missing, Cmdenv
    executes all runs in the selected configuration. The -r command line option
    overrides this setting.

cmdenv-status-frequency=&lt;int&gt;, default:100000; per-run setting
    When cmdenv-express-mode=true: print status update every n events. Typical
    values are 100,000...1,000,000.

configuration-class=&lt;string&gt;; global setting
    Part of the Envir plugin mechanism: selects the class from which all
    configuration information will be obtained. This option lets you replace
    omnetpp.ini with some other implementation, e.g. database input. The
    simulation program still has to bootstrap from an omnetpp.ini (which
    contains the configuration-class setting). The class should implement the
    <a href="../api/classcConfiguration.html">cConfiguration</a> interface.

constraint=&lt;string&gt;; per-run setting
    For scenarios. Contains an expression that iteration variables (${} syntax)
    must satisfy for that simulation to run. Example: $i &lt; $j+1.

cpu-time-limit=&lt;double&gt;, unit="s"; per-run setting
    Stops the simulation when CPU usage has reached the given limit. The
    default is no limit.

debug-on-errors=&lt;bool&gt;, default:false; global setting
    When set to true, runtime errors will cause the simulation program to break
    into the C++ debugger (if the simulation is running under one, or
    just-in-time debugging is activated). Once in the debugger, you can view
    the stack trace or examine variables.

description=&lt;string&gt;; per-run setting
    Descriptive name for the given simulation configuration. Descriptions get
    displayed in the run selection dialog.

eventlog-file=&lt;filename&gt;, default:${resultdir}/${configname}-${runnumber}.log; per-run setting
    Name of the event log file to generate.

eventlog-message-detail-pattern=&lt;custom&gt;; per-run setting
    A list of patterns separated by '|' character which will be used to write
    message detail information into the event log for each message sent during
    the simulation. The message detail will be presented in the sequence chart
    tool. Each pattern starts with an object pattern optionally followed by ':'
    character and a comma separated list of field patterns. In both patterns
    and/or/not/* and various field matcher expressions can be used. The object
    pattern matches to class name, the field pattern matches to field name by
    default.
      EVENTLOG-MESSAGE-DETAIL-PATTERN := ( DETAIL-PATTERN '|' )* DETAIL_PATTERN
      DETAIL-PATTERN := OBJECT-PATTERN [ ':' FIELD-PATTERNS ]
      OBJECT-PATTERN := MATCHER-EXPRESSION
      FIELD-PATTERNS := ( FIELD-PATTERN ',' )* FIELD_PATTERN
      FIELD-PATTERN := MATCHER-EXPRESSION
    Examples (enter them without quotes):
      "*": captures all fields of all messages
      "*Frame:*Address,*Id": captures all fields named somethingAddress and
    somethingId from messages of any class named somethingFrame
      "MyMessage:declaredOn(MyMessage)": captures instances of MyMessage
    recording the fields declared on the MyMessage class
      "*:(not declaredOn(<a href="../api/classcMessage.html">cMessage</a>) and not declaredOn(<a href="../api/classcNamedObject.html">cNamedObject</a>) and not
    declaredOn(<a href="../api/classcObject.html">cObject</a>))": records user-defined fields from all messages

eventlog-recording-intervals=&lt;custom&gt;; per-run setting
    Interval(s) when events should be recorded. Syntax: [&lt;from&gt;]..[&lt;to&gt;],...
    That is, both start and end of an interval are optional, and intervals are
    separated by comma. Example: ..100, 200..400, 900..

experiment-label=&lt;string&gt;, default:${configname}; per-run setting
    Identifies the simulation experiment (which consists of several,
    potentially repeated measurements). This string gets recorded into result
    files, and may be referred to during result analysis.

extends=&lt;string&gt;; per-run setting
    Name of the configuration this section is based on. Entries from that
    section will be inherited and can be overridden. In other words,
    configuration lookups will fall back to the base section.

fingerprint=&lt;string&gt;; per-run setting
    The expected fingerprint, suitable for crude regression tests. If present,
    the actual fingerprint is calculated during simulation, and compared
    against the expected one.

fname-append-host=&lt;bool&gt;, default:false; global setting
    Turning it on will cause the host name and process Id to be appended to the
    names of output files (e.g. omnetpp.vec, omnetpp.sca). This is especially
    useful with distributed simulation.

ini-warnings=&lt;bool&gt;, default:false; global setting
    Currently ignored. Accepted for backward compatibility.

load-libs=&lt;filenames&gt;; global setting
    A space-separated list of dynamic libraries to be loaded on startup. The
    libraries should be given without the `.dll' or `.so' suffix -- that will
    be automatically appended.

max-module-nesting=&lt;int&gt;, default:50; per-run setting
    The maximum allowed depth of submodule nesting. This is used to catch
    accidental infinite recursions in NED.

measurement-label=&lt;string&gt;, default:${iterationvars}; per-run setting
    Identifies the measurement within the experiment. This string gets recorded
    into result files, and may be referred to during result analysis.

&lt;object-full-path&gt;.module-eventlog-recording=&lt;bool&gt;, default:true; per-object setting
    Enables recording events on a per module basis. This is meaningful for
    simple modules only.
    Example:
     **.router[10..20].**.module-eventlog-recording = true
     **.module-eventlog-recording = false

ned-path=&lt;string&gt;; global setting
    A semicolon-separated list of directories which will be appended to the
    NEDPATH environment variable. The directories will be regarded as roots of
    the NED package hierarchy, and all NED files will be loaded from the
    subdirectories under them.

network=&lt;string&gt;; per-run setting
    The name of the network to be simulated.

num-rngs=&lt;int&gt;, default:1; per-run setting
    The number of random number generators.

output-scalar-file=&lt;filename&gt;, default:${resultdir}/${configname}-${runnumber}.sca; per-run setting
    Name for the output scalar file.

output-scalar-file-append=&lt;bool&gt;, default:false; per-run setting
    What to do when the output scalar file already exists: append to it
    (OMNeT++ 3.x behavior), or delete it and begin a new file (default).

output-scalar-precision=&lt;int&gt;, default:14; per-run setting
    The number of significant digits for recording data into the output scalar
    file. The maximum value is ~15 (IEEE double precision).

output-vector-file=&lt;filename&gt;, default:${resultdir}/${configname}-${runnumber}.vec; per-run setting
    Name for the output vector file.

output-vector-precision=&lt;int&gt;, default:14; per-run setting
    The number of significant digits for recording data into the output vector
    file. The maximum value is ~15 (IEEE double precision). This setting has no
    effect on the "time" column of output vectors, which are represented as
    fixed-point numbers and always get recorded precisely.

output-vectors-memory-limit=&lt;double&gt;, unit="B", default:16MB; per-run setting
    Total memory that can be used for buffering output vectors. Larger values
    produce less fragmented vector files (i.e. cause vector data to be grouped
    into larger chunks), and therefore allow more efficient processing later.

outputscalarmanager-class=&lt;string&gt;, default:cFileOutputScalarManager; global setting
    Part of the Envir plugin mechanism: selects the output scalar manager class
    to be used to record data passed to recordScalar(). The class has to
    implement the <a href="../api/classcOutputScalarManager.html">cOutputScalarManager</a> interface.

outputvectormanager-class=&lt;string&gt;, default:cIndexedFileOutputVectorManager; global setting
    Part of the Envir plugin mechanism: selects the output vector manager class
    to be used to record data from output vectors. The class has to implement
    the <a href="../api/classcOutputVectorManager.html">cOutputVectorManager</a> interface.

parallel-simulation=&lt;bool&gt;, default:false; global setting
    Enables parallel distributed simulation.

&lt;object-full-path&gt;.param-record-as-scalar=&lt;bool&gt;, default:false; per-object setting
    Applicable to module parameters: specifies whether the module parameter
    should be recorded into the output scalar file. Set it for parameters whose
    value you'll need for result analysis.

parsim-communications-class=&lt;string&gt;, default:cFileCommunications; global setting
    If parallel-simulation=true, it selects the class that implements
    communication between partitions. The class must implement the
    <a href="../api/classcParsimCommunications.html">cParsimCommunications</a> interface.

parsim-debug=&lt;bool&gt;, default:true; global setting
    With parallel-simulation=true: turns on printing of log messages from the
    parallel simulation code.

parsim-filecommunications-prefix=&lt;string&gt;, default:comm/; global setting
    When cFileCommunications is selected as parsim communications class:
    specifies the prefix (directory+potential filename prefix) for creating the
    files for cross-partition messages.

parsim-filecommunications-preserve-read=&lt;bool&gt;, default:false; global setting
    When cFileCommunications is selected as parsim communications class:
    specifies that consumed files should be moved into another directory
    instead of being deleted.

parsim-filecommunications-read-prefix=&lt;string&gt;, default:comm/read/; global setting
    When cFileCommunications is selected as parsim communications class:
    specifies the prefix (directory) where files will be moved after having
    been consumed.

parsim-idealsimulationprotocol-tablesize=&lt;int&gt;, default:100000; global setting
    When cIdealSimulationProtocol is selected as parsim synchronization class:
    specifies the memory buffer size for reading the ISP event trace file.

parsim-namedpipecommunications-prefix=&lt;string&gt;, default:omnetpp; global setting
    When cNamedPipeCommunications is selected as parsim communications class:
    selects the name prefix for Windows named pipes created.

parsim-nullmessageprotocol-laziness=&lt;double&gt;, default:0.5; global setting
    When cNullMessageProtocol is selected as parsim synchronization class:
    specifies the laziness of sending null messages. Values in the range [0,1)
    are accepted. Laziness=0 causes null messages to be sent out immediately as
    a new EOT is learned, which may result in excessive null message traffic.

parsim-nullmessageprotocol-lookahead-class=&lt;string&gt;, default:cLinkDelayLookahead; global setting
    When cNullMessageProtocol is selected as parsim synchronization class:
    specifies the C++ class that calculates lookahead. The class should
    subclass from cNMPLookahead.

parsim-synchronization-class=&lt;string&gt;, default:cNullMessageProtocol; global setting
    If parallel-simulation=true, it selects the parallel simulation algorithm.
    The class must implement the cParsimSynchronizer interface.

&lt;object-full-path&gt;.partition-id=&lt;string&gt;; per-object setting
    With parallel simulation: in which partition the module should be
    instantiated. Specify numeric partition ID, or a comma-separated list of
    partition IDs for compound modules that span across multiple partitions.
    Ranges ("5..9") and "*" (=all) are accepted too.

perform-gc=&lt;bool&gt;, default:false; global setting
    Whether the simulation kernel should delete on network cleanup the
    simulation objects not deleted by simple module destructors. Not
    recommended.

print-undisposed=&lt;bool&gt;, default:true; global setting
    Whether to report objects left (that is, not deallocated by simple module
    destructors) after network cleanup.

realtimescheduler-scaling=&lt;double&gt;; global setting
    When <a href="../api/classcRealTimeScheduler.html">cRealTimeScheduler</a> is selected as scheduler class: ratio of simulation
    time to real time. For example, scaling=2 will cause simulation time to
    progress twice as fast as runtime.

record-eventlog=&lt;bool&gt;, default:false; per-run setting
    Enables recording an eventlog file, which can be later visualized on a
    sequence chart. See eventlog-file= option too.

repeat=&lt;int&gt;, default:1; per-run setting
    For scenarios. Specifies how many replications should be done with the same
    parameters (iteration variables). This is typically used to perform
    multiple runs with different random number seeds. The loop variable is
    available as ${repetition}. See also: seed-set= key.

replication-label=&lt;string&gt;, default:#${repetition}; per-run setting
    Identifies one replication of a measurement (see repeat= and
    measurement-label= as well). This string gets recorded into result files,
    and may be referred to during result analysis.

result-dir=&lt;string&gt;, default:results; per-run setting
    Value for the ${resultdir} variable, which is used as the default directory
    for result files (output vector file, output scalar file, eventlog file,
    etc.)

&lt;object-full-path&gt;.rng-%=&lt;int&gt;; per-object setting
    Maps a module-local RNG to one of the global RNGs. Example: **.gen.rng-1=3
    maps the local RNG 1 of modules matching `**.gen' to the global RNG 3. The
    default is one-to-one mapping.

rng-class=&lt;string&gt;, default:<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>; per-run setting
    The random number generator class to be used. It can be `<a href="../api/classcMersenneTwister.html">cMersenneTwister</a>',
    `<a href="../api/classcLCG32.html">cLCG32</a>', `cAkaroaRNG', or you can use your own RNG class (it must be
    subclassed from <a href="../api/classcRNG.html">cRNG</a>).

&lt;object-full-path&gt;.scalar-recording=&lt;bool&gt;, default:true; per-object setting
    Whether the matching output scalars should be recorded. Syntax:
    &lt;module-full-path&gt;.&lt;scalar-name&gt;.scalar-recording=true/false. Example:
    **.queue.packetsDropped.scalar-recording=true

scheduler-class=&lt;string&gt;, default:<a href="../api/classcSequentialScheduler.html">cSequentialScheduler</a>; global setting
    Part of the Envir plugin mechanism: selects the scheduler class. This
    plugin interface allows for implementing real-time, hardware-in-the-loop,
    distributed and distributed parallel simulation. The class has to implement
    the <a href="../api/classcScheduler.html">cScheduler</a> interface.

seed-%-lcg32=&lt;int&gt;; per-run setting
    When <a href="../api/classcLCG32.html">cLCG32</a> is selected as random number generator: seed for the kth RNG.
    (Substitute k for '%' in the key.)

seed-%-mt=&lt;int&gt;; per-run setting
    When Mersenne Twister is selected as random number generator (default):
    seed for RNG number k. (Substitute k for '%' in the key.)

seed-%-mt-p%=&lt;int&gt;; per-run setting
    With parallel simulation: When Mersenne Twister is selected as random
    number generator (default): seed for RNG number k in partition number p.
    (Substitute k for the first '%' in the key, and p for the second.)

seed-set=&lt;int&gt;, default:${runnumber}; per-run setting
    Selects the kth set of automatic random number seeds for the simulation.
    Meaningful values include ${repetition} which is the repeat loop counter
    (see repeat= key), and ${runnumber}.

sim-time-limit=&lt;double&gt;, unit="s"; per-run setting
    Stops the simulation when simulation time reaches the given limit. The
    default is no limit.

simtime-scale=&lt;int&gt;, default:-12; global setting
    Sets the scale exponent, and thus the resolution of time for the 64-bit
    fixed-point simulation time representation. Accepted values are -18..0; for
    example, -6 selects microsecond resolution. -12 means picosecond
    resolution, with a maximum simtime of ~110 days.

snapshot-file=&lt;filename&gt;, default:${resultdir}/${configname}-${runnumber}.sna; per-run setting
    Name of the snapshot file.

snapshotmanager-class=&lt;string&gt;, default:cFileSnapshotManager; global setting
    Part of the Envir plugin mechanism: selects the class to handle streams to
    which snapshot() writes its output. The class has to implement the
    <a href="../api/classcSnapshotManager.html">cSnapshotManager</a> interface.

tkenv-default-config=&lt;string&gt;; global setting
    Specifies which config Tkenv should set up automatically on startup. The
    default is to ask the user.

tkenv-default-run=&lt;int&gt;, default:0; global setting
    Specifies which run (of the default config, see tkenv-default-config) Tkenv
    should set up automatically on startup. The default is to ask the user.

tkenv-extra-stack=&lt;double&gt;, unit="B", default:48KB; global setting
    Specifies the extra amount of stack that is reserved for each activity()
    simple module when the simulation is run under Tkenv.

tkenv-image-path=&lt;filename&gt;; global setting
    Specifies the path for loading module icons.

tkenv-plugin-path=&lt;filename&gt;; global setting
    Specifies the search path for Tkenv plugins. Tkenv plugins are .tcl files
    that get evaluated on startup.

total-stack=&lt;double&gt;, unit="B"; global setting
    Specifies the maximum memory for activity() simple module stacks. You need
    to increase this value if you get a ``Cannot allocate coroutine stack''
    error.

&lt;object-full-path&gt;.type-name=&lt;string&gt;; per-object setting
    Specifies type for submodules and channels declared with 'like &lt;&gt;'.

user-interface=&lt;string&gt;; global setting
    Selects the user interface to be started. Possible values are Cmdenv and
    Tkenv, provided the simulation executable contains the respective libraries
    or loads them dynamically.

&lt;object-full-path&gt;.vector-max-buffered-values=&lt;int&gt;; per-object setting
    For output vectors: the maximum number of values to buffer per vector,
    before writing out a block into the output vector file. The default is no
    per-vector limit (i.e. only the total memory limit is in effect)

&lt;object-full-path&gt;.vector-record-eventnumbers=&lt;bool&gt;, default:true; per-object setting
    Whether to record event numbers for an output vector. Simulation time and
    value are always recorded. Event numbers are needed by the Sequence Chart
    Tool, for example.

&lt;object-full-path&gt;.vector-recording=&lt;bool&gt;, default:true; per-object setting
    Whether data written into an output vector should be recorded.

&lt;object-full-path&gt;.vector-recording-interval=&lt;custom&gt;; per-object setting
    Recording interval(s) for an output vector. Syntax: [&lt;from&gt;]..[&lt;to&gt;],...
    That is, both start and end of an interval are optional, and intervals are
    separated by comma. Example: ..100, 200..400, 900..

warnings=&lt;bool&gt;, default:true; per-run setting
    Enables warnings.
</pre>
<p>

<p>Predefined variables that can be used in config values:

<pre>
${runid}
    A reasonably globally unique identifier for the run, produced by
    concatenating the configuration name, run number, date/time, etc.
${inifile}
    Name of the (primary) inifile
${configname}
    Name of the active configuration
${runnumber}
    Sequence number of the current run within all runs in the active
    configuration
${network}
    Value of the "network" configuration option
${experiment}
    Value of the "experiment-label" configuration option
${measurement}
    Value of the "measurement-label" configuration option
${replication}
    Value of the "replication-label" configuration option
${processid}
    PID of the simulation process
${datetime}
    Date and time the simulation run was started
${resultdir}
    Value of the "result-dir" configuration option
${repetition}
    The iteration number in 0..N-1, where N is the value of the "repeat"
    configuration option
${seedset}
    Value of the "seed-set" configuration option
${iterationvars}
    Concatenation of all user-defined iteration variables in name=value form
${iterationvars2}
    Concatenation of all user-defined iteration variables in name=value form,
    plus ${repetition}
</pre>
<p>

<p>
<H2><A NAME="sec465"/>21.2 Predefined Configuration Variables</H2>

<p>Predefined variables that can be used in config values:

<pre>
${runid}
    A reasonably globally unique identifier for the run, produced by
    concatenating the configuration name, run number, date/time, etc.
${inifile}
    Name of the (primary) inifile
${configname}
    Name of the active configuration
${runnumber}
    Sequence number of the current run within all runs in the active
    configuration
${network}
    Value of the "network" configuration option
${experiment}
    Value of the "experiment-label" configuration option
${measurement}
    Value of the "measurement-label" configuration option
${replication}
    Value of the "replication-label" configuration option
${processid}
    PID of the simulation process
${datetime}
    Date and time the simulation run was started
${resultdir}
    Value of the "result-dir" configuration option
${repetition}
    The iteration number in 0..N-1, where N is the value of the "repeat"
    configuration option
${seedset}
    Value of the "seed-set" configuration option
${iterationvars}
    Concatenation of all user-defined iteration variables in name=value form
${iterationvars2}
    Concatenation of all user-defined iteration variables in name=value form,
    plus ${repetition}
</pre>
<p>
</BODY>
</HTML>
<hr><hr><H1><A NAME="sec466"/>22 Result File Formats</H1>
<a name="cha:result-file-formats"></a>

<p>The file format described here applies to <i>both output vector and
output scalar files</i>. Their formats are consistent, only the types of
entries occurring into them are different. This unified format also
means that they can be read with a common routine.

<p>Result files are <i>line oriented</i>. A line consists of one or more
tokens, separated by whitespace. Tokens either don't
contain whitespace, or or whitespace is escaped using a backslash, or
are quoted using double quotes. Escaping within quotes using
backslashes is also permitted.

<p>The first token of a line usually identifies the type of the entry. A
notable exception is an output vector data line, which begins with a
numeric identifier of the given output vector.

<p>A line starting with # as the first non-whitespace character denotes
a comment, and is to be ignored during processing.

<p>Result files are written from simulation runs. A simulation run
generates physically contiguous sets of lines into one or more result
files. (That is, lines from different runs do not arbitrarily mix in
the files.)

<p>
A run is identified by a unique textual<i> runId</i>, which appears in
all result files written during that run. The runId may appear on the
user interface, so it should be somewhat meaningful to the user.
Nothing should be assumed about the particular format of runId, but it
will be some string concatenated from the simulated network's name, the
time/date, the hostname, and other pieces of data to make it unique.

<p>
A simulation run will typically write into two result files (.vec and
.sca). However, when using parallel distributed simulation, the user
will end up with several .vec and .sca files, because different
partitions (a separate process each) will write into different files.
However, all these files will contain the same runId, so it is possible
to relate data that belong together.

<p><br><br>

<p>Entry types:

<p>\bfseries
``Run''

<p>Marks the beginning of a new run in the file. Entries after this line
belong to this run.

<p>
<br><br>

<p>Format:

<p><b>run</b> <i>runId</i>

<p>
<br><br>

<p>The following forms are obsolete, but should be understood nevertheless:

<p><b>run</b> <i>runNumber</i>

<p><b>run</b> <i>runNumber</i> <i>networkName</i>

<p><b>run</b> <i>runNumber</i> <i>networkName</i> <i>dateTime</i>

<p>
<br><br>

<p>These forms can be distinguished from the first one during processing,
because runId is not numeric while runNumber is. During processing, the
program can construct an artificial runId from the file name, run
number, and the line number at which this line appears in the file.
(The runNumber comes from omnetpp.ini, and it is not guaranteed to be
unique).

<p>In the new format, runNumber, networkName and dateTime will appear on
separate lines as <i>run</i> <i>attributes</i>.

<p>
<br><br>

<p>Old output vector files don't contain a ``run'' line. During processing,
if any line type is encountered before a ``run'' line, then an implicit
\ ``run'' has to be created and subsequenet entries be assumed to be
part of that.

<p>
<br><br>

<p>Performance note: if not the whole file is kept in memory during
analysis, then the runs in the file (i.e. offsets of the ``run'' lines)
may be indexed for more efficient random access.

<p>
<br><br>

<p>Example:

<p>\ttfamily
run
"largeNet-20050710-14:34:11-localhost-12374"

<p>
<br><br>

<p>\bfseries
``Run Attributes''

<p>Contains an attribute for the current run. These attributes include the
network name, the time/date of execution, the
experiment/measurement/replication labels, the random number seeds,
configuration options that took effect such as the scheduler class,
etc.

<p>
<br><br>

<p>Format:

<p><b>attr</b> <i>name</i> <i>value</i>

<p>
<br><br>

<p><b>TODO</b> define the list of recognized attribute names

<p>
<br><br>

<p>Example

<p>\ttfamily
attr run 1

<p>\ttfamily
attr network "largeNet"

<p>\ttfamily
attr date "2005-07-10 14:34:11"

<p>\ttfamily
attr host "localhost"

<p>\ttfamily
attr inifile "xxx.ini"

<p>\ttfamily
attr experiment "blabla"

<p>\ttfamily
attr measurement "rtete"

<p>\ttfamily
attr replication "12th"

<p>\ttfamily
attr numseeds 2

<p>\ttfamily
attr seed-0-mt 573367

<p>\ttfamily
attr seed-1-mt 124643

<p>
<br><br>

<p>\bfseries
``Param''

<p>Contains a module parameter value for the given run. This is needed so
that module parameters may be included in the analysis (e.g. to
identify the load for a ``thruput vs load'' plot).

<p>
<br><br>

<p>It is not feasible to simply store all parameters of all modules in the
result file (it's just too much). We assume that NED files are
invariant and don't store parameters defined in them. However, we store
parameter assignments that come from omnetpp.ini, in their original
wildcard form (i.e. not expanded) to conserve space. Parameter values
entered interactively by the user are also stored.

<p>
<br><br>

<p>When the original NED files are present, it should thus be possible to
reconstruct all parameters for the given simulation.

<p>

<p>Format:

<p><b>param</b> <i>parameterNamePattern</i> <i>value</i>

<p>
<br><br>

<p>Example:

<p>\ttfamily
param **.gen.sendIaTime \ \ exponential(0.01)

<p>\ttfamily
param **.gen.msgLength \ \ \ 10

<p>\ttfamily
param **.fifo.bitsPerSec \ 1000

<p>
<br><br>

<p>\bfseries
``Scalar''

<p>Contains an output scalar value. This is the same as in older output
scalar files.

<p>\

<p>Format:

<p><b>scalar</b> <i>moduleName</i> <i>scalarName</i> <i>value</i>

<p>
<br><br>

<p><b>TODO</b> room to include the unit (seconds, bits, megabit/second,
etc), and possible extra data (for tagging, commenting, etc?)

<p>
<br><br>

<p>Examples:

<p>\ttfamily
scalar "net.switchA.relay"
"processed frames" 100

<p>
<br><br>

<p>\bfseries
``Vector''

<p>Defines an output vector. This is the same as in older output vector
files.

<p>Format:

<p><b>vector</b> <i>vectorId</i> \ <i>moduleName</i>
\ <i>vectorName</i>

<p><b>vector</b> <i>vectorId</i> \ <i>moduleName</i>
\ <i>vectorName</i> \ 1

<p><b>vector </b><i>vectorId</i> <i>moduleName vectorName columns</i>

<p>
<i> </i>Where columns is a string encoding the meaning and ordering
the columns of data lines. Characters of the string mean:

<p>  <b>E</b> event number
  <b>T</b> simulation time
  <b>V</b> vector value

<p>The default value of columns is 'TV'
for compatibility with old vector files.

<p>
<br><br>

<p>\bfseries
``Vector Attributes''

<p>Vector attributes may follow the definition of vectors. These attibutes
include vector unit, enum definitions, interpolation mode, etc.

<p>
<br><br>

<p>Format:

<p><b>attr</b> name value

<p>\

<p>
<br><br>

<p>\bfseries
``Vector Data''

<p>Adds a value to an output vector. This is the same as in older output
vector files.

<p>Format:

<p>\itshape vectorId column1 column2 ...

<p>Simulation times and event numbers <i>within an output vector</i> are
required to be in increasing order.

<p>Performance note: Data lines belonging to the same output vector may be
written out in clusters (of sizes roughly multiple of the disk's
physical block size). Then, since an output vector file is typically
not kept in memory during analysis, indexing the start offsets of these
clusters allows one to read the file and seek in it more efficiently.
This does not require any change or extension to the file format.

<p><br><br>

<p>\bfseries ``Histogram''

<p>Contains histogram data.

<p>Format:

<p><b>histogram</b> <i>moduleName</i> \ <i>histogramName</i>

<p><b>bin</b> --INF <i>value0</i>

<p><b>bin</b> <i>binLowerBound1</i> <i>value1</i>

<p><b>bin</b> <i>binLowerBound2</i> <i>value2</i>

<p>\bfseries ...

<p>Histogram name and module is defined on the <b>histogram</b> line,
which is followed by several <b>bin</b> lines to contain data. Any
non-<b>bin</b> line marks the end of the histogram data.

<p>The <i>binLowerBound </i>column of <b>bin</b> lines represent the
lower bound of the given histogram cell. <b>Bin</b> lines are in
increasing <i>binLowerBound</i> order.

<p>The <i>value</i> column of <b>bin</b> lines represent observation
count in the given cell: <i>value k</i> is the number of observations
greater or equal than <i>binLowerBound k</i>, but smaller than
<i>binLowerBound k+1</i>. <i>Value</i> is not necessarily an
integer, because the <a href="../api/classcKSplit.html">cKSplit</a> and <a href="../api/classcPSquare.html">cPSquare</a> algorithms produce
non-integer estimates. The first <b>bin</b> line is the underflow
cell, and the last <b>bin</b> line is the overflow cell.

<p>

</BODY>
</HTML>
<hr><hr><H1><A NAME="sec467"/>23 Eventlog File Format</H1>
<a name="cha:eventlog-file-format"></a>

<p>This appendix documents the format of the eventlog file. Eventlog
files are written by the simulation (when enabled). Everything
that happens during the simulation gets recorded into the file,
  <br><ul><font size=-1>[With certain granularity of course, and subject to
  filters that were active during simulation]</font></ul>
so the file can later be used to reproduce the history of the
simulation on a sequence chart, or in some other form.

<p>The file is line-oriented text file. Blank lines and lines beginning
with "#" (comments) will get ignored. Other lines begin with an
<i>entry identifier</i> like <tt>E</tt> for <i>Event</i> or
<tt>BS</tt> for <i>BeginSend</i>, followed by <i>attribute-identifier</i>
and <i>value</i> pairs. One exception is debug output
(recorded from <tt>ev&lt;&lt;...</tt> statements), which are represented
by lines that begin with a hypen, and continue with the actual text.

<pre>
&lt;file&gt; ::= &lt;line&gt;*
&lt;line&gt; ::= &lt;empty-line&gt; | &lt;user-log-message&gt; | &lt;event-log-entry&gt;
&lt;empty-line&gt; ::= CR LF
&lt;user-log-message&gt; ::= - SPACE &lt;text&gt; CR LF
&lt;event-log-entry&gt; ::= &lt;event-log-entry-type&gt; SPACE &lt;parameters&gt; CR LF
&lt;event-log-entry-type&gt; ::= SB | SE | BU | MB | ME | MC | MD | MR | GC | GD |
                           CC | CD | CS | MS | CE | BS | ES | SD | SH | DM | E
&lt;parameters&gt; ::= (&lt;parameter&gt;)*
&lt;parameter&gt; ::= &lt;name&gt; SPACE &lt;value&gt;
&lt;name&gt; ::= &lt;text&gt;
&lt;value&gt; ::= &lt;boolean&gt; | &lt;integer&gt; | &lt;text&gt; | &lt;quoted-text&gt;
</pre>
<p>
Here is a fragment of an existing eventlog file as an example:

<pre>
E # 14 t 1.018454036455 m 8 ce 9 msg 6
BS id 6 tid 6 c <a href="../api/classcMessage.html">cMessage</a> n send/endTx pe 14
ES t 4.840247053855
MS id 8 d t=TRANSMIT,,#808000;i=device/pc_s
MS id 8 d t=,,#808000;i=device/pc_s

E # 15 t 1.025727827674 m 2 ce 13 msg 25
- another frame arrived while receiving -- collision!
CE id 0 pe 12
BS id 0 tid 0 c <a href="../api/classcMessage.html">cMessage</a> n end-reception pe 15
ES t 1.12489449434
BU id 2 txt "Collision! (3 frames)"
DM id 25 pe 15
</pre>
<p>
A correct eventlog also fulfills the following requirements:
<ul>
   <li> simulation events are in increasing event number and simulation time order
   <li> FIXME anything more?
</ul>

<p>The various entry types and their supported attributes are as follows:

<pre>
SB SimulationBeginEntry // recorded at the first event
{
   v int version       // OMNeT++ version, e.g. 0x401 (=1025) is release 4.1
   rid string runId    // identifies the simulation run
}

SE SimulationEndEntry // optional last line of an event log file
{
}

BU BubbleEntry // display a bubble message
{
   id int moduleId // id of the module which printed the bubble message
   txt string text // displayed message text
}

MB ModuleMethodBeginEntry // beginning of a call to another module
{
   sm int fromModuleId // id of the caller module
   tm int toModuleId   // id of the module being called
   m string method     // C++ method name
}

ME ModuleMethodEndEntry // end of a call to another module
{
}

MC ModuleCreatedEntry // creating a module
{
   id int moduleId              // id of the new module
   c string moduleClassName     // C++ class name of the module
   t string nedTypeName         // fully qualified NED type name
   pid int parentModuleId  -1   // id of the parent module
   n string fullName            // full dotted hierarchic module name
   cm bool compoundModule false // simple or compound module
}

MD ModuleDeletedEntry // deleting a module
{
   id int moduleId // id of the module being deleted
}

MR ModuleReparentedEntry // reparenting a module
{
   id int moduleId         // id of the module being reparented
   p int newParentModuleId // id of the new parent module
}

GC GateCreatedEntry     // gate created
{
   m int moduleId       // module in which the gate was create
   g int gateId         // id of the new gate
   n string name        // gate name
   i int index -1       // gate index if vector, -1 otherwise
   o bool isOutput      // input or output gate
}

GD GateDeletedEntry     // gate deleted
{
   m int moduleId       // module in which the gate was created
   g int gateId         // id of the deleted gate
}

CC ConnectionCreatedEntry // creating a connection
{
   sm int sourceModuleId  // id of the source module identifying the connection
   sg int sourceGateId    // id of the gate at the source module identifying the connection
   dm int destModuleId    // id of the destination module
   dg int destGateId      // id of the gate at the destination module
}

CD ConnectionDeletedEntry // deleting a connection
{
   sm int sourceModuleId // id of the source module identifying the connection
   sg int sourceGateId   // id of the gate at the source module identifying the connection
}

CS ConnectionDisplayStringChangedEntry // a connection display string change
{
   sm int sourceModuleId  // id of the source module identifying the connection
   sg int sourceGateId    // id of the gate at the source module identifying the connection
   d string displayString // the new display string
}

MS ModuleDisplayStringChangedEntry // a module display string change
{
   id int moduleId        // id of the module
   d string displayString // the new display string
}

E EventEntry // an event that is processing of a message
{
   # long eventNumber          // unique event number
   t simtime_t simulationTime  // simulation time when the event occurred
   m int moduleId              // id of the processing module
   ce long causeEventNumber -1 // event number from which the message being processed was sent or -1 if the message was sent from initialize
   msg long messageId          // life time unique id of the message being processed
}

CE CancelEventEntry // canceling an event caused by self message
{
   id long messageId              // id of the message being removed from the FES
   pe long previousEventNumber -1 // event number from which the message being cancelled was sent or -1 if the message was sent from initialize
}

BS BeginSendEntry // beginning to send a message
{
   id long messageId                       // life time unique id of the message being sent
   //XXX what about writing dup, encapsulate/decapsulate as separate lines?
   tid long messageTreeId                  // id of the message inherited by dup
   eid long messageEncapsulationId   -1    // id of the message inherited by encapsulation
   etid long messageEncapsulationTreeId -1 // id of the message inherited by both dup and encapsulation
   c string messageClassName               // C++ class name of the message
   n string messageFullName                // message name
   pe long previousEventNumber -1          // event number from which the message being sent was processed or -1 if the message has not yet been processed before
   k short messageKind     0               // message kind
   p short messagePriority 0               // message priority
   l int64 messageLength   0               // message length in bits
   er bool hasBitError   false             // true indicates the message has bit errors
   d string detail       NULL              // detailed information of message content when recording message data is turned on
   //XXX and many other fields, including message contents
}

ES EndSendEntry // prediction of the arrival of a message
{
   t simtime_t arrivalTime // when the message will arrive to its destination module
}

SD SendDirectEntry // sending a message directly to a destination gate
{
   sm int senderModuleId            // id of the source module from which the message is being sent
   dm int destModuleId              // id of the destination module to which the message is being sent
   dg int destGateId                // id of the gate at the destination module to which the message is being sent
   pd simtime_t propagationDelay  0 // propagation delay that is while the message is propagated through the connection
   td simtime_t transmissionDelay 0 // transmission delay that is while the whole message is sent from the source gate
}

SH SendHopEntry // sending a message through a connection identified by its source module and gate id
{
   sm int senderModuleId            // id of the source module from which the message is being sent
   sg int senderGateId              // id of the gate at the source module from which the message is being sent
   pd simtime_t propagationDelay  0 // propagation delay that is while the message is propagated through the connection
   td simtime_t transmissionDelay 0 // transmission delay that is while the whole message is sent from the source gate
}

DM DeleteMessageEntry // deleting a message
{
   id int messageId               // id of the message being deleted
   pe long previousEventNumber -1 // event number from which the message being deleted was sent or -1 if the message was sent from initialize
}
</pre>
<p>
</BODY>
</HTML>


<HR>
<EM>Document converted from LaTeX by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>
from <A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com">quong@best.com</A>)</EM>

</BODY>
</HTML>
