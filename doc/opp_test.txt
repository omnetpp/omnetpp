OMNeT++ Regression Tests
========================

TODO: This description was written for 3.x, and is slightly out of date.


This file documents the opp_test tool. Reading it will help you understand
.test files in the test/ directory and write new test cases for your simulation
models or for the simulation kernel.


Each test case is a single *.test file. All NED code, C++ code and
other data necessary to run the test case, and also PASS criteria are
embedded in the test case file. The advantages for this design are twofold:
 - test cases are self-contained (easy to share, etc)
 - enforces test cases that are compact and to the point

How to run tests (steps 2-4 are automated with the test/runtest script):

1. write the *.test files

  The syntax of test files is described in a later section of this doc.

2. export all source and other files to a working directory

  This is done with the following command:

  % opp_test -g *.test

  This will export all C++ and NED code, ini files, etc. from
  the .test files into separate files. All files will be created
  in the test tool's work directory. (It defaults to ./work,
  but it can be orverridden.

3. create a makefile and build the test program

  You can build an executable test program from the source files
  in the work directory by running:

  % opp_makemake -u cmdenv; make

  The code from all test cases will be combined into a single executable.
  (If there are many test cases, this results in a dramatical
  improvement in terms of necessary disk space and compilation time,
  compared to the case when every test is a separate executable.)

4. execute the tests and see the results

  Typing

  % opp_test -r -v *.test

  will execute all test cases, using the test executable built
  in step 3. For each test case, opp_test will check the output from
  the test program (stdout, stderr and the generated output files)
  against the specification in the test file and decide if it is
  a PASS or FAIL or UNRESOLVED. Finally, it will print a summary
  with the number of test cases PASSed, FAILed and UNRESOLVED.

In practice you would write a small script that automates the job
for you. I use the following 'runtest' script:

  #! /bin/sh
  perl opp_test.pl -g -v *.test || exit 1
  (cd work; opp_makemake -f -u cmdenv; make) || exit 1
  perl opp_test.pl -r -v *.test

Note that you only need the test tool (opp_test) in steps 2 and 4.
One might wonder why steps 2-3-4 are not combined into a single
step, controlled by opp_test. The .test files could also contain
the necessary opp_makemake options too, then. The reason why this is
not done is the following:

Since we're building a single executable that contains all
test cases, we'd have to merge the opp_makemake options from
all .test files, and that is neither trivial nor a clean way.
Also, it was intended to omit everything from the .test files
that needs to be configured. With the present solution,
only the 'runtest' script contains settings that need to
be configured.

Let us see a small test file:

file cMessage_properties_1.test:

  %description:
  Test the name and length properties of cMessage.

  %activity:
  cMessage msg;
  msg.setName("Joe");
  msg.setLength(456);
  ev << "name: " << msg.name() << endl;
  ev << "length: " << msg.length() << endl;

  %contains: stdout
  name: Joe
  length: 456

The test case involves creating a simple module with only an activity()
function that has the C++ code after the %activity line as a function body.
This module is run then in a simulation as the only module. The module C++
code and the corresponding NED definition as well as omnetpp.ini are
auto-generated by opp_test, you don't need to care about them.
The standard output is matched against the lines after the %contains
line, and if it matches, a PASS is declared.

%activity is only a convenience feature to spare you from having to write
boilerplate C++ and NED code manually. There are three other ways to proceed:

- %module lets you define a module class and run it as the only module
  in the simulation. The corresponding NED code and omnetpp.ini is
  auto-generated for you. The module won't have any gates or parameters.

- %module_a and %module_b lets you define a module pair where each module
  has an 'in' and an 'out' gate, and they are connected in both directions.
  The corresponding NED code and omnetpp.ini is auto-generated for you.
  The modules won't have parameters.

- %file lets you take full control of the source and explicitly spell out
  all NED and C++ code (and also additional data files if you need them).

Note that since all sources are compiled into a single test executable,
actions have to be taken to prevent accidental name clashes between C++
symbols in different test cases. As a rule of thumb, C++ symbols should
be put into the namespace named after the test case. This is done 
automatically for the %activity, %module, %global blocks, but for %file 
blocks, the test author should manually insert the namespace:
   namespace @TESTNAME@ {
   ...
   };
The string @TESTNAME@ will be replaced with the test case name. Since it
gets substituted everywhere (C++, NED, msg and ini files), you can also 
write things like @TESTNAME@_function(), or printf("this is @TESTNAME@").

Note: In OMNeT++ 3.x versions of opp_test, the syntaxes {} and {foo} had
special meaning: they were abbreviations of @TESTNAME@ and @TESTNAME@_foo,
respectively. This syntax is not supported any more, and occurrences in old
test cases should be replaced with explicit @TESTNAME@ macros.

A test case is unresolved if the test program cannot be executed at all, the
output cannot be read, or if the test case declares so. The latter is done
by printing #UNRESOLVED or #UNRESOLVED:some-explanation on the standard
output, at the beginning of the line.

It is possible to apply text substitutions to the output before it is matched
against expected output. This is done with %subst directive; there can be
more than one %subst in a test file. It takes a regex to search for, 
replacement text, and flags, in the /search/replace/flags syntax. Flags
can be empty or a combination of the letters i, m, and s, for case-insensitive,
multi-line or single-string match (see perl regex documentation.) %subst
was primarily invented to deal with differences in printf output across
platforms and compilers: different compilers print infinite and not-a-number
in different ways: 1.#INF, inf, Inf, -1.#IND, nan, NaN etc. With %subst
they can be brought to a common form.

The full list of possible % entries in a test file:

Generic entries:
   %description:
   <test-description-lines>

Test case components:
   %includes
   <#include directives>

   %activity:
   <body-of-activity()>

   %global:
   <global-code-pasted-before-activity>

   %module: <modulename>
   <simple-module-C++-definition>

   %module_a: <module_a-name>
   <simple-module-C++-definition-for-module_a>
   %module_b: <module_b-name>
   <simple-module-C++-definition-for-module_b>

   %file: <file-name>
   <file-contents>

   %inifile: [<inifile-name>]
   <inifile-contents>

Preprocessing the output before matching:
   %subst: /searchregex/replacestring/flags

Conditions for PASS:
   %exitcode: <one-or-more-numeric-exit-codes>

   %ignore-exitcode: 1

   %contains: <output-file-to-check>
   <substring>

   %contains-regex: <output-file-to-check>
   <regexp-pattern>

   %not-contains: <output-file-to-check>
   <substring>

   %not-contains-regex: <output-file-to-check>
   <regexp-pattern>

Enjoy!

--Andras
