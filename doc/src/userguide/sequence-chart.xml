<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
    "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="seq-chart">
  <title>Sequence Charts</title>

  <sect1>
    <title>Introduction</title>
    <para>
      This chapter describes the Sequence Chart and the Eventlog Table tools. Both of them
      display an eventlog file recorded by the OMNeT++ 4.0 simulation kernel.
    </para>
    <para>
      An eventlog file contains a log of messages sent during the simulation,
      and the details of events that sent or received them. This includes both
      messages sent between modules and self-messages (timers). The amount of
      data recorded from messages can be controlled by the user, as well as
      start/stop time, which modules to include in the log, and so on.
      The file also contains the topology of the model, that is, the modules and
      their interconnections.
    </para>
    <note>
      Please refer to the OMNeT++ 4.0 Manual for further details on what an eventlog file
      is, and what is its exact format.
    </note>
    <para>
      The Sequence Chart displays eventlog files in a graphical form, focusing on the
      causes and consequences of events and message sends. It helps understanding complex
      simulation models, and helps correctly implementing the desired component
      behaviors. The Eventlog Table displays an eventlog file in a more detailed and
      direct way, in a tabular format, focusing on the exact data. Both tools can display
      filtered eventlogs created via the Eventlog Tool filter command as described in the
      OMNeT++ 4.0 Manual, by a third party custom filter tool, or by the IDE's in memory
      filtering.
    </para>
    <para>
      Using these tools, you will be able to easily examine every detail of your
      simulation back and forth in terms of simulation time or events, focusing on the
      behavior instead of the statistical results of your model.
    </para>
  </sect1>

  <sect1>
    <title>Creating an eventlog file</title>
    <para>
      The Inifile Editor in the OMNeT++ IDE provides a group of widgets in the
      <guilabel>Output Files</guilabel> section to configure automatic eventlog
      recording. To enable it, simply put a checkmark next to its checkbox, or insert the
      line <screen>record-eventlog = true</screen> into the inifile.
    </para>
    <picture file="pictures/INI-Eventlog.png">Inifile eventlog configuration</picture>
    <para>
      By default, the recorded eventlog file will be put in the project's
      <filename>results</filename> directory, with the name
      <filename>${configname}-${runnumber}.log</filename>.
    </para>
    <warning>
      If you override the default file name, please make sure that the file extension is
      <filename>log</filename>, so that the OMNeT++ IDE tools
      will be able to recognize it automatically.
    </warning>
    <para>
      The 'recording intervals' and 'record events' configuration keys control which events will
      be recorded based on their simulation time and on the module where they occur. The
      'message details' configuration key specifies what will be recorded from a message's content.
      Message contents will be recorded each time the message gets sent.
    </para>
    <para>
      The amount of data recorded will affect the eventlog file size as well as the
      execution speed of the simulation, so it is often a good idea to tailor these
      settings to get a reasonable tradeoff between performance and details.
    </para>
    <note>
      Please refer to the OMNeT++ 4.0 Manual for a complete description of eventlog
      recording settings.
    </note>
  </sect1>

  <sect1>
    <title>Examples</title>
    <para>
      This section will guide you through the use of the Sequence Chart and Eventlog Table
      tools, using example simulations from OMNeT++ and the INET Framework.
      Before running any of the simulations, make sure that eventlog recording is
      enabled, by adding or uncommenting the line <screen>record-eventlog = true</screen>
      in <filename>omnetpp.ini</filename> file in the simulation's directory. To open the
      generated eventlog in the OMNeT++ IDE, go to the example's
      <filename>results</filename> directory in the <guilabel>Resource
      Navigator</guilabel> view, and double-click the log file. By default, the file
      will open in the Sequence Chart.
      <tip>
	To open the file in the Eventlog Table as editor, right-click the file, and
	choose the corresponding item from the context menu's <guisubmenu>Open With</guisubmenu>
	submenu.
      </tip>
    </para>
    <sect2>
      <title>Tictoc</title>
      <para>
	The Tictoc example is available in the OMNeT++ installation under the directory
	<filename>samples/tictoc</filename>. Tictoc is the most basic example in this
	chapter, and it provides a quick overview on how to use and understand the Sequence
	Chart.
      </para>
      <para>
	Start the simulation, and choose the simplest configuration, 'Tictoc1', which
	specifies only two nodes called 'tic' and 'toc'. During initializion, one of the
	nodes will send a message to the other. From that on, every time a node
	receives the message, it will simply send it back. This process continues until
	you stop the simulation. In <xref
	linkend="pictures/SequenceChart-Examples-TicTocTwoNodes.png"/> you can see how
	this is represented on a Sequence Chart. The two horizontal black lines correspond
	to the two nodes, and are labelled 'tic' and 'toc'. The red circles represent
	events, and the blue arrows represent message sends. It is easy to see that all
	message sends take 100 ms, and that the first sender is the node 'tic'.
      </para>
      <picture file="pictures/SequenceChart-Examples-TicTocTwoNodes.png">
	Tictoc with two nodes
      </picture>
      <para>
	In the next Tictoc example there are six nodes tossing a message around until it
	reaches its destination. To generate the eventlog file, restart the simulation and
	choose the configuration 'Tictoc9'. In <xref
	linkend="pictures/SequenceChart-Examples-TicTocSeveralNodes.png"/> you can see how
	the message goes from one node to another, starting from node '0' and passing through it
	twice more, until it finally reaches its destination, node
	'3'. The chart also shows that this example, unlike the previous one, starts with a
	self-message instead of immediately sending a message from initialize to another
	node.
      </para>
      <picture file="pictures/SequenceChart-Examples-TicTocSeveralNodes.png">
	Tictoc with six nodes
      </picture>
      <para>
	Let us demonstrate on this simple example how filtering works with the Sequence
	Chart. Open the Filter Fialog with the toolbar button <icon name="filter.png"/>
	and put a checkmark for node '0' and '3' on the <guilabel>Module filter|by
	name</guilabel> panel, and apply it. The chart now displays only two axes that
	correspond to the two selected nodes.  Note that the arrows on this figure are
	decorated with zigzags, meaning that they represent a sequence of message
	sends. Such arrows will be called virtual message sends in the rest of this
	chapter.  The first two arrows show the message returning to node '0' at
	<eventnumber>9</eventnumber> and <eventnumber>13</eventnumber>, and the third
	shows that it reaches the destination at <eventnumber>16</eventnumber>.  The
	events where the message was in between are filtered out.
      </para>
      <picture file="pictures/SequenceChart-Examples-TicTocSeveralNodesFiltered.png">
	Filtering for node '0' and '3'
      </picture>
    </sect2>
    <sect2>
      <title>FIFO</title>
      <para>
	The FIFO example is available in the OMNeT++ installation under the directory
	<filename>samples/fifo</filename>. The FIFO is an important example, because it
	uses a queue which is an essential part of discrete event simulations and
	introduces the notion of message reuses.
      </para>
      <para>
	When you start the simulation, choose the configuration 'low job arrival rate' and
	let it run for a while. In <xref
	linkend="pictures/SequenceChart-Examples-FIFO.png"/> you can see three modules, a
	'source', a 'queue', and a 'sink'. The simulation starts with a self-message and
	then the generator sends the first message to the queue at
	<eventnumber>1</eventnumber>. It is immediately obvious that the message stays in
	the queue for a certain period of time, between <eventnumber>2</eventnumber> and
	<eventnumber>3</eventnumber>.
      </para>
      <tip>
	When you select one event and hover with the mouse above the other,
	the Sequence Chart will show the length of this time period in a tooltip.
      </tip>
      <para>
	Finally, the message is sent to the 'sink' where it is
	destroyed at <eventnumber>4</eventnumber>.
      </para>
      <picture file="pictures/SequenceChart-Examples-FIFO.png">
	The FIFO example
      </picture>
      <para>
	The interesting thing happens at <eventnumber>12</eventnumber> where the incoming
	message suddenly disappears. It seems like the queue does not send that message
	out. Actually what happens is that the queue enqueues the job because it is busy
	serving the message received at <eventnumber>10</eventnumber>.  Since this queue
	is a FIFO, it will send out the first message at <eventnumber>13</eventnumber>. To
	see how this happens, turn on <guilabel>Show Reuse Messages</guilabel> from the
	context menu; the result is shown in <xref
	linkend="pictures/SequenceChart-Examples-FIFOReuse.png"/>.  It displays a couple
	of green dotted arrows, one of which starts at <eventnumber>12</eventnumber> and
	arrives at <eventnumber>17</eventnumber>. This is a reuse arrow; it means that the
	message sent out from the queue at <eventnumber>17</eventnumber> is the same as
	the one received and enqueued at <eventnumber>12</eventnumber>.  Note that the
	service of this message actually begins at <eventnumber>13</eventnumber>. It is
	the moment when the queue becomes free after completing the service of the job
	received at <eventnumber>10</eventnumber>.
      </para>
      <picture file="pictures/SequenceChart-Examples-FIFOReuse.png">
	Showing reuse messages
      </picture>
      <para>
	Another type of message reuse can be seen on the arrow
	from <eventnumber>3</eventnumber> to <eventnumber>6</eventnumber>:
	it represents the fact that the queue reuses
	the same timer message instead of creating a new one each time.
      </para>
      <note>
        Whenever you see a reuse arrow, it means that the underlying implementation
        remembers the message between the two events. It might be stored
        in a pointer variable, a queue, or some other data structure.
      </note>
      <para>
	The last part of this example is about filtering out the queue from the
	chart. Open the <guilabel>Filter Dialog</guilabel>, and put a checkmark for 'sink'
	and 'source' on the <guilabel>Module filter|by NED type</guilabel> panel, and
	apply it. If you look at the result in <xref
	linkend="pictures/SequenceChart-Examples-FIFOFiltered.png"/>, then you will see
	zigzag arrows going from the 'source' to the 'sink'. These arrows represent the
	fact that a message is being sent through the queue from 'source' to 'sink'. The
	first two arrows do not overlap in simulation time, which means the queue did not
	have more than one message in it during that time. On the other hand, the third
	and fourth arrows do overlap due to the fact that the forth job reached the queue
	while it was busy with the third one. Scrolling forward you can find other places
	where the queue becomes empty and arrows do not overlap again.
      </para>
      <picture file="pictures/SequenceChart-Examples-FIFOFiltered.png">
	Filtering the queue out
      </picture>
    </sect2>
    <sect2>
      <title>Routing</title>
      <para>
	The Routing example is available in the OMNeT++ installation under the directory
	<filename>samples/routing</filename>. The predefined configuration called 'Net10'
	specifies a network with 10 nodes, with each node having an application, a few
	queues and a routing module inside. Three preselected nodes, namely the node '1',
	'6', and '8' are destinations, while all nodes are message sources. The routing
	module uses the shortest path algorithm to find the route to the destination. The
	goal in this example is to create a sequence chart that shows messages which
	travel simultaneously from multiple sources to their destinations.
      </para>
      <picture file="pictures/SequenceChart-Examples-RoutingNetwork.png">
	Network with 10 nodes
      </picture>
      <para>
	Since we don't care about the details what happens within nodes, we can just turn
	on filtering for the NED type 'node.Node'. The chart will have 10 axes, each axis
	drawn as two parallel solid black lines close to each other. These are the
	compound modules that represent the nodes in the network. So far events could be
	directly drawn on the simple module's axis where they occured, but now they will
	be drawn on their ancestor compound module's axis.
      </para>
      <picture file="pictures/SequenceChart-Examples-Routing.png">
	Filtering for nodes
      </picture>
      <para>
	To reduce clutter, the chart will automatically omit events which are internal to
	a compound module. An event is internal to a compound module if it only processes
	a message from, and sends out messages to, other modules inside the compound
	module.
      </para>
      <para>
	If you look at <xref linkend="pictures/SequenceChart-Examples-Routing.png"/> you
	will see a message going from node '7' at <eventnumber>10</eventnumber> to node
	'1' at <eventnumber>23</eventnumber>. This message stays in node '2'
	between <eventnumber>15</eventnumber> and <eventnumber>17</eventnumber>.
	The gray background area between them means that zero simulation time has
	elapsed, that is, the model does not account for processing time inside the
	network nodes.
      </para>
      <note>
        This model contains both finite propagation delay and transmission time;
        arrows in the sequence chart correspond to the interval between the start
        of the transmission and the end of the reception.
      </note>
      <para>
	This example also demonstrates message detail recording configured by
	<inifile>eventlog-message-detail-pattern = Packet:declaredOn(Packet)</inifile> in
	the inifile. The exmample in <xref
	linkend="pictures/SequenceChart-Examples-RoutingTooltip.png"/> shows the tooltip
	presented for the second message send between <eventnumber>17</eventnumber> and
	<eventnumber>23</eventnumber>.
      </para>
      <picture file="pictures/SequenceChart-Examples-RoutingTooltip.png">
	Message detail tooltip
      </picture>
      <para>
	It is very easy to find another message on the chart that goes through the network
	parallel in simulation time. The one sent from node '3' at
	<eventnumber>13</eventnumber> to node '8' arriving at
	<eventnumber>19</eventnumber> is such a message.
      </para>
    </sect2>
    <sect2>
      <title>Wireless</title>
      <para>
	The Wirless example is available in the INET Framework under the directory
	<filename>examples/adhoc/ieee80211</filename>. The predefined configuration called
	'Config1' specifies two mobile hosts moving around on the playground, and
	communicating via the IEEE 802.11 wireless protocol. The network devices are
	configured for ad-hoc mode, and the transmitter power is set so that hosts can
	move out of range. One of the hosts is continuously pinging the other.
      </para>
      <para>
	In this section we will explore the protocol's MAC layer, using two sequence
	charts. The first chart will show a successful ping message being sent through the
	wireless channel, and the second will show ping messages getting lost and being
	continuously re-sent.
      </para>
      <para>
	We also would like to record some message details during the simulation. To do
	that, comment out the following line from omnetpp.ini:
	<screen>eventlog-message-detail-pattern = *:(not declaredOn(cMessage) and not
	declaredOn(cNamedObject) and not declaredOn(cObject))</screen>
      </para>
      <para>
	To generate the eventlog file, start the simulation environment and choose the
	configuration 'host1 pinging host0'. Run the simulation in fast mode until about
	event number <eventnumber>5000</eventnumber>.
      </para>
      <sect3>
	<title>Preparing the result</title>
	<para>
	  When you open the Sequence Chart, it will show a couple of self-messages named
	  'move' being scheduled regularly. These are self-messages that control the
	  movement of the hosts on the playground. There is an axis labelled 'pingApp',
	  which starts with a 'sendPing' message that is processed in an event far away on
	  the chart. This is indicated by the so called split arrow.
	</para>
	<picture file="pictures/SequenceChart-Examples-WirelessBeginning.png">
	  The beginning
	</picture>
	<para>
	  You might notice that there are only three axes in <xref
	  linkend="pictures/SequenceChart-Examples-WirelessBeginning.png"/> even though
	  the simulation model clearly contains more simple modules. This is because the
	  Sequence Chart displays the first few events by default and in this scenario
	  they all happen to be within those modules. If you scroll forward or zoom out,
	  then new axes will be added automatically as needed.
	</para>
	<para>
	  Let us ignore the 'move' messages, and focus on the MAC layer instead. To begin
	  with, open the <guilabel>Filter Dialog</guilabel>, and put a checkmark for
	  'Ieee80211Mac' and 'Ieee80211Radio' on the <guilabel>Module filter|by NED
	  type</guilabel> panel, and apply it. The chart will have four axes, two for the
	  MAC and two for the radio simple modules.
	</para>
	<para>
	  The next step is to attach vector data to these axes. Open the context menu for
	  each axis by clicking on them one by one, and select the <guilabel>Attach Vector
	  to Axis</guilabel> submenu. Accept the vector file offered by default, and
	  choose the vector 'mac:State' for the MAC modules, and 'mac:RadioState' for the
	  radio modules. You will have to edit the filter in the vector selection dialog
	  (i.e. delete the last segment) for the radio modules, because at the moment the
	  radio state is actually recorded by the MAC module, so the default filter will
	  not be right. When this step is completed, the chart should display four thick
	  colored bars as module axes. The colors and labels on the bars specify the state
	  of the corresponding state machine at the given simulation time.
	</para>
	<para>
	  To make understanding easier, you might want to manually reorder the axis, so
	  that the radio modules are put next to each other. Use the button <icon
	  name="axisordering.gif"/> on the toolbar to switch to manual ordering. With a
	  little zooming and scrolling you should be able to fit the first message
	  exchange between the two hosts into the window.
	</para>
      </sect3>
      <sect3>
	<title>Successful ping</title>
	<para>
	  The first message sent by 'host1' is not a ping request but an ARP request. The
	  processing of this message in 'host0' generates the corresponding ARP
	  reply. This is shown by the zigzag arrow between <eventnumber>85</eventnumber>
	  and <eventnumber>90</eventnumber>. The reply goes back to 'host1' which then
	  sends a WLAN acknowledge in return. In this process 'host1' discovers the MAC
	  address of 'host0' based on its IP address.
	</para>
	<picture file="pictures/SequenceChart-Examples-WirelessARP.png">
	  Discovering the MAC address
	</picture>
	<para>
	  The send procedure for the first ping message starts at
	  <eventnumber>105</eventnumber> in 'host1', and finishes by receiving the
	  acknowledge at <eventnumber>127</eventnumber>. The ping reply send procedure
	  starts at <eventnumber>125</eventnumber> in 'host0' and finishes by receiving
	  the WLAN acknowledge at <eventnumber>144</eventnumber>. If you scroll a little
	  bit forward you can see as in <xref
	  linkend="pictures/SequenceChart-Examples-WirelessSuccessfulPing.png"/> the
	  second complete successful ping procedure between <eventnumber>170</eventnumber>
	  and <eventnumber>206</eventnumber>. To focus on the second successful ping
	  message exchange, open the <guilabel>Filter Dialog</guilabel>, and enter these
	  numbers in the range filter.
	</para>
	<para>
	  Timing is critical in a protocol implementation, so let's take a look at it
	  using the Sequence Chart. The first self message represents the fact that the
	  MAC module listens to the radio for a DIFS period before sending the message
	  out. The message send from <eventnumber>171</eventnumber> to
	  <eventnumber>172</eventnumber> occurs in zero simulation time as indicated by
	  the gray background. It represents the moment when the MAC module decides to
	  send the ping request down to its radio module. The backoff procedure was
	  skipped for this message, because there was no transmission during the DIFS
	  period. If you look at <eventnumber>172</eventnumber> and
	  <eventnumber>173</eventnumber> you will see how the message propagates through
	  the air from 'radio1' to 'radio0'. This finite amount of time is calculated from
	  the physical distance of the two modules and the speed of light. Also looking at
	  <eventnumber>172</eventnumber> and <eventnumber>174</eventnumber> you can notice
	  that the transmission time is not zero. This time interval is calculated from
	  the message's length and the radio module's bitrate. 
	</para>
	<picture file="pictures/SequenceChart-Examples-WirelessSuccessfulPing.png">
	  The second ping procedure
	</picture>
	<para>
	  Another interesting fact, which can be immediately drawn from the figure, is
	  that the higher level protocol layers do not add delay for generating the ping
	  reply message in 'host0' between <eventnumber>176</eventnumber> and
	  <eventnumber>183</eventnumber>. The MAC layer procedure ends with sending back a
	  WLAN acknowledge after waiting a SIFS period.
	</para>
	<para>
	  And finally, you can get a quick overview about the relative timings of the IEEE
	  802.11 protocol with switching to linear timeline mode. Use the button <icon
	  name="timelinemode.png"/> on the toolbar, and notice how the figure changes
	  dramatically. You might need to scroll and zoom in or out to see the
	  details. This actually shows how useful the nonlinear timeline mode is.
	</para>
	<commercial>
	  <para>
	    You can export this sequence chart for documentation purposes using the
	    context menu's <guilabel>Export to SVG</guilabel> option.
	  </para>
	</commercial>
      </sect3>
      <sect3>
	<title>Unsuccessful ping</title>
	<para>
	  To see how the chart looks when the ping messages get lost in the air, first
	  turn off range filtering. Then go to <eventnumber>1269</eventnumber> by
	  selecting the <guimenuitem>Goto Event</guimenuitem> option from the Eventlog
	  Table view's context menu. In <xref
	  linkend="pictures/SequenceChart-Examples-WirelessUnsuccessfulPing.png"/> you can
	  see how the receiver radio does not send up the incoming message to its MAC
	  layer due to the signal level being too low. This actually happens at
	  <eventnumber>1274</eventnumber> in 'host0'. A little bit later the transmitter
	  MAC layer in 'host1' receives the timeout message at
	  <eventnumber>1275</eventnumber>, and starts the backoff procedure before
	  resending the very same ping message. This process goes on with statistically
	  increasing backoff time intervals until <eventnumber>1317</eventnumber>. Finally
	  the maximum number of retries is reached and the message is dropped.
	</para>
	<picture file="pictures/SequenceChart-Examples-WirelessUnsuccessfulPing.png">
	  Ping messages get lost
	</picture>
	<para>
	  The chart also makes clear that during the unsuccessful ping period there are no
	  events occuring in the MAC layer of 'host0' and it is continuously in 'IDLE'
	  state.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Sequence Chart</title>
    <para>
      This section describes the Sequence Chart in details focusing on its features
      without a particular example.
      <!-- FIXME, TODO, XXX, and FILL-ME-IN in more details. -->
    </para>
    <para>
      The Sequence Chart is divided into three parts: the top and bottom gutters, and the
      main area. The gutters show the simulation time, and the main area displays module
      axes, events and message sends. The chart grows horizontally with simulation time,
      and vertically with the number of modules. Module axes can optionally display
      enumerated or numerical vector data.
    </para>
    <para>
      There are various options, which control how and what the Sequence Chart
      displays. Some of these are available on the toolbar, while some others are
      accessible only from the context menu.
    </para>
    <sect2>
      <title>Legend</title>
      <para>
	Graphical elements on the Sequence Chart represent modules, events and messages,
	as listed in the following table.
      </para>
      <informaltable>
	<tgroup cols="2">
	  <colspec colwidth="170"/>
	  <colspec/>
	  <tbody>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SimpleModuleAxis.png"/></entry>
	      <entry>simple module axis</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-CompoundModuleAxis.png"/></entry>
	      <entry>compound module axis</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-AxisWithAttachedVector.png"/></entry>
	      <entry>axis with attached vector data</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-ModuleFullPath.png"/></entry>
	      <entry>module full path as axis label</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-InitializationEvent.png"/> (hollow circle)</entry>
	      <entry>initialization event</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SelfMessageProcessingEvent.png"/> (green disc)</entry>
	      <entry>self-message processing event</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-MessageProcessingEvent.png"/> (red disc)</entry>
	      <entry>message processing event</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-EventNumber.png"/></entry>
	      <entry>event number</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SelfMessage.png"/> (blue arrow, arched)</entry>
	      <entry>self-message</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-MessageSend.png"/> (blue arrow)</entry>
	      <entry>message send</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-MessageReuse.png"/> (green dotted arrow)</entry>
	      <entry>message reuse</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SplitArrow.png"/> (arrow with a dashed segment)</entry>
	      <entry>message send that goes far away; split arrow</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-ZigZagArrow.png"/> (arrow with zigzag)</entry>
	      <entry>virtual message send; zigzag arrow</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-TransmissionDuration-ReceptionAtStart.png"/> (blue paralellogram)</entry>
	      <entry>transmission duration; reception at start</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-TransmissionDuration-ReceptionAtEnd.png"/> (blue paralellogram)</entry>
	      <entry>transmission duration; reception at end</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SplitTransmissionDuration-ReceptionAtStart.png"/> (blue strips)</entry>
	      <entry>split transmission duration; reception at start</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SplitTransmissionDuration-ReceptionAtEnd.png"/> (blue strips)</entry>
	      <entry>split transmission duration; reception at end</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-MessageName.png"/></entry>
	      <entry>message name</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-ZeroSimulationTimeRegion.png"/> (gray background)</entry>
	      <entry>zero simulation time region</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SimulationTimeHairline.png"/> (dashed gray line)</entry>
	      <entry>simulation time hairline</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>
    <sect2>
      <title>Timeline</title>
      <para>
	Simulation time may be mapped onto the horizontal axis in various ways, linear
	mapping only being one of them. The reason for having multiple mapping modes is
	that intervals between interesting events are often of different magnitudes (for
	example, microsecond timings in a MAC protocol vs multi-second timeouts in higher
	layers), which is impossible to visualize using a linear scale.
      </para>
      <para>
        The available timeline modes are:
	<itemizedlist>
	  <listitem>
	    Linear -- the simulation time is proportional to the distance measured in
	    pixels
	  </listitem>
	  <listitem>
	    Event number -- the event number is proportional to the distance measured in
	    pixels
	  </listitem>
	  <listitem>
	    Step -- the distance between subsequent events, even if they have non subsequent
	    event numbers, is the same
	  </listitem>
	  <listitem>
	    Nonlinear -- the distance between subsequent events is a nonlinear function of
	    the simulation time between them. This makes the figure compact even if there
	    are several magnitudes difference between simulation time intervals. On the
	    other hand it is still possible to decide which interval is longer and which
	    one is shorter.
	  </listitem>
	  <listitem>
	    Custom nonlinear -- like nonlinear. This is useful in those rare cases when
	    the automatic nonlinear mode does not work well. The best practice is to
	    switch to <guilabel>Nonlinear</guilabel> mode first, and then to
	    <guilabel>Custom nonlinear</guilabel>, so that the chart will continuously
	    refresh during changing the parameters. At the extreme, you can set the
	    parameters so that the nonlinear mode becomes equivalent to linear mode or
	    step mode.
	  </listitem>
	</itemizedlist>
	 You can switch between timeline modes using the button <icon
	 name="timelinemode.png"/> on the toolbar or from the context menu.
      </para>
      <para>
      </para>
    </sect2>
    <sect2>
      <title>Zero Simulation Time Regions</title>
      <para>
	It is quite common in simulation models that multiple events occur at the same
	simulation time, possibly in different modules. A region with gray background
	color indicates that the simulation time does not change along the horizontal axis
	within the area, thus all events inside it have the same simulation time
	associated with them.
      </para>
      <picture file="pictures/SequenceChart-ZeroSimulationTimeRegions.png">Nonlinear simulation time</picture>
    </sect2>
    <sect2>
      <title>Module Axes</title>
      <para>
	The Sequence Chart's vertical axis corresponds to modules in the simulation. By
	default, each simple module is displayed on a separate horizontal axis, and events
	that occurred in that module are shown as circles on it. A compound module is
	represented with a double line, and it will display events from all contained
	simple modules, except internal events and those that have their own axes
	displayed. An event is internal to a compound module if it only processes a
	message from, and sends out messages to, other modules inside.
      </para>
      <para>
	It is not uncommon that some axes do not have events at all. These axes would just
	uselessly occupy some place on the screen, so by default they will be omitted from
	the chart unless the <guilabel>Show Axes Without Events</guilabel> option is
	turned on. The discovery process is done lazily as you navigate through the chart,
	and it may add new axes dynamically as soon as it turns out that they actually
	have events.
      </para>
      <para>
	Module axes can be reordered with the option <guilabel>Axis Ordering
	Mode</guilabel> <icon name="axisordering.gif"/>. Ordering can be manual, or sorted
	by module name, by module id or by minimizing the total number axes that arrows
	are crossing.
      </para>
      <note>
        The algorithm that minimizes crossings works by taking a random sample from the
        file, and determines the order of axes from that -- which means that the resulting
        order will only be an approximation. A more precise algorithm which takes all
        arrows into account would not be practical, because of the typically large size of
        eventlog files.
      </note>
    </sect2>
    <sect2>
      <title>Gutter</title>
      <para>
	The upper and lower edges of the Sequence Chart show a gutter that displays the
	simulation time. The left side of the top gutter displays a <emphasis>time
	prefix</emphasis> value, which should be added to each individual simulation time
	shown at the vertical hairlines. This reduces the number of characters on the
	gutter, and allows easier recognition of simulation time changes in the
	significant digits. The right side of the figure displays the simulation time
	range that is currently visible within the window.
      </para>
      <tip>
	To see what is the simulation time at a specific point on the chart, move the
	mouse to the desired place, and read the value in the blue box horizontally
	aligned with the mouse on the gutter.
      </tip>
      <picture file="pictures/SequenceChart-Gutter.png">Gutter and range</picture>
    </sect2>
    <sect2>
      <title>Events</title>
      <para>
	Events are displayed as filled circles along the module axes. A green circle
	represents the processing of a self-message, while a red circle is an event caused
	by receiving a message from another module. The event with event number zero
	represents the module initialization phase, and may spread across multiple module
	axes, because the simulation kernel calls each module during initialization. This
	event is displayed with white background color. 
      </para>
      <para>
	Event numbers are displayed below and to the right of their corresponding events,
	and are prefixed with '#'. Their color changes according to their events' colors.
      </para>
      <picture file="pictures/SequenceChart-Events.png">Various event kinds</picture>
    </sect2>
    <sect2>
      <title>Messages</title>
      <para>
	The Sequence Chart represents message sends via blue arrows. Vertically, the arrow
	starts at the module which sent the message, and ends at the module which
	processed the message. Horizontally the start and end points of the arrow
	correspond to the sender and receiver events. The message name is displayed near
	the middle of the arrow, but not exactly to avoid overlapping with other names
	between the same modules.
      </para>
      <para>
	Sometimes when a message arrives at a module it just stores it, and later on sends
	the very same message out. The events, where the message arrived, and where the
	message was actually sent, are in a so called message reuse relationship. This is
	represented by a green dotted arrow between the two events. These arrows are not
	shown by default due to timer self-messages usually being reused
	continuously. This would add unnecessary clutter to the chart and would make it
	hard to understand. To show and hide these arrows, use the <guilabel>Show Reuse
	Messages</guilabel> <icon name="reusearrows.png"/> button on the toolbar.
      </para>
      <para>
	Sometimes, depending on the zoom factor, a message send goes far away on the
	chart. In this case the line is split into two smaller parts that are displayed at
	the two ends pointing towards each other, but without actually connected with a
	continuous line. One end of both arrow pieces is a dotted line, and the other end
	is a solid line. The one which is solid always exactly points to, or from, the
	event it is really connected to. The other one, which is dotted, either specifies
	only the module where the arrow really starts, or ends, or in case of a
	self-message it just points towards the other arrow horizontally.
      </para>
      <picture file="pictures/SequenceChart-SplitArrows.png">Split arrows</picture>
    </sect2>
    <sect2>
      <title>Attaching Vectors</title>
      <para>
	It is possible to attach Vector data to individual axes from the context menu by
	right clicking on the desired axis and selecting <guilabel>Attach Vector to
	Axis</guilabel> from the corresponding submenu. In this case the solid line of the
	axis will be turned into a colored thick bar. If the vector is of type enum and
	its element names have been registered with the C++ macro Register_Enum, then the
	chart will display those names inside the bar. Otherwise it will simply display
	the value as a number. The background coloring for the thick bar is automatic, it
	is either based on the enumeration member, or alternating for other types.
      </para>
    </sect2>
    <sect2>
      <title>Zooming</title>
      <para>
	To zoom in or out horizontally along the timeline, use the <guilabel>Zoom
	In</guilabel> <icon name="zoomplus.png"/> and <guilabel>Zoom Out</guilabel> <icon
	name="zoomminus.png"/> buttons on the toolbar. To decrease or increase the
	distance between the axes use the <guilabel>Increase/Decrease Spacing</guilabel>
	<icon name="incr_spacing.png"/> <icon name="decr_spacing.png"/> commands.
	<warning>
	  When you zoom out more events and messages become visible on the chart making it
	  slower while zooming in more message lines break making it less informative. Try
	  to keep a reasonable zoom level.
	</warning>
      </para>
    </sect2>
    <sect2>
      <title>Navigation</title>
      <para>
	To scroll the Sequence Chart either use the scroll bars, drag with the mouse left
	button or scroll with the mouse wheel using the <keycap>SHIFT</keycap> modifier
	key for horizontal scroll.
      </para>
      <para>
	There are also navigation options to go to the previous
	(<keycap>SHIFT+LEFT</keycap>) or next (<keycap>SHIFT+RIGHT</keycap>) event in the
	same module.
      </para>
      <para>
	Similarly to the Eventlog Table to go to the cause event press
	<keycap>CTRL+LEFT</keycap> and to go to the arrival of a message send press
	<keycap>CTRL+RIGTH</keycap> while an event is selected.
      </para>
    </sect2>
    <sect2>
      <title>Tooltips</title>
      <para>
	The Sequence Chart displays tooltips for axes, events, message sends and
	resuses. When a tooltip is shown for any of the above the chart will highlight the
	corresponding parts. Sometimes when the chart is zoomed out it might show a
	complex tooltip at once because there are multiple things under the mouse.
      </para>
      <tip>
	To measure the simulation time difference between two events select one of them
	and stay at the other to display the tooltip.
      </tip>
      <picture file="pictures/SequenceChart-Tooltip.png">Event tooltip</picture>
    </sect2>
    <sect2>
      <title>Bookmarks</title>
      <para>
	Just like the Eventlog Table the Sequence Chart also supports bookmarks to make
	navigation easier. Actually bookmarks are saved for the files rather than the
	various editors, therefore they are shared between them. The chart highlights
	bookmarked events with a circle around them similarly to primary selection but
	with a different color.
      </para>
    </sect2>
    <commercial>
      <sect2>
	<title>Exporting</title>
	<para>
	  The Sequence Chart supports exporting continuous parts into SVG format for
	  documentation purposes. This function is available from the context menu <icon
	  name="export_wiz.gif"/>. You can export the whole Sequence Chart, a region
	  between two selected events, or the currently visible area.
	</para>
      </sect2>
    </commercial>
    <sect2>
      <title>Associated Views</title>
      <para>
	When you open an eventlog file in the Sequence Chart editor, it will automatically
	open the Eventlog Table view with the same file. If you select an event on the
	Sequence Chart editor, then the Eventlog Table view will jump to the same event
	and vice versa. This interconnection makes navigation easier, and you can
	immediately see the details of selected event's raw data.
      </para>
    </sect2>
    <sect2>
      <title>Filtering</title>
      <para>
	You can also filter the contents of the Sequence Chart. This actually means that
	some of the events are not displayed on the chart so that the user can focus on
	the relevant parts. When filtering is turned on (displayed in the status line)
	some of the message arrows might be decorated with a filter sign (a double zigzag
	crossing the arrow line's center). Such a message arrow means that there is a
	message going out from the source module which after some processing in some other
	filtered out modules reaches the target module. The message name of the arrow in
	this case corresponds to the first and the last message in the chain that was
	filtered out.
      </para>
      <picture file="pictures/SequenceChart-ZigZagArrows.png">Zigzag arrows</picture>
      <para>
	When a module filter is used, then it will determine which modules will have
	axes. If events occured in a module are completely filtered out, then the Sequence
	Chart will not display the superfluous axis belonging to that module. This reduces
	the number of axes and makes it easier to understand the figure.
      </para>
      <para>
	Events may not have subsequent event numbers, which means that the events in
	between have been filtered out. At the extreme, the chart may even become empty
	meaning that there are no matching events at all.
      </para>
      <para>
	To filter the Sequence Chart, open the <guilabel>Filter Dialog</guilabel> use the
	filter button <icon name="filter.png"/> on the toolbar. You can also filter from
	the context menu using the shortcuts provided for events and message sends
	currently under the mouse.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Eventlog Table</title>
    <para>
      This section describes the Eventlog table in details focusing on its features
      without a particular example.
      <!-- FIXME, TODO, XXX, and FILL-ME-IN in more details. -->
    </para>
    <para>
      The Evenlog Table has one row per line in the eventlog file. It has three columns,
      where the first two called event number and simulation time show the values
      corresponding to the simulation event where the line was recorded. The third column
      called details contains the actual data, which varies for each line kind. The
      different kind of lines can be easily recognized by their icon. Some lines, such as
      sending a message through a sequence of gates, relate with each other, and are
      indented for easier recognition.
    </para>
    <para>
      There are various options, which control how and what the Eventlog Table
      displays. Some of these are available on the toolbar, while some others are
      accessible only from the context menu.
    </para>
    <sect2>
      <title>Display Mode</title>
      <para>
	The eventlog file content may be displayed in two different notations. The
	<guilabel>Raw</guilabel> data notation shows exactly what is present in the file.
      </para>
      <picture file="pictures/EventlogTable-RawMode.png">
	<guilabel>Raw</guilabel> notation
      </picture>
      <para>
	On the other hand the <guilabel>Descriptive</guilabel> notation displays the log
	file after some preprocessing into a human readable form. It also resolves
	references and types, so that less navigation is required to understand what is
	going on. To switch between the two, use the <guilabel>Display Mode</guilabel>
	<icon name="displaymode.png"/> button on the toolbar or the context menu.
      </para>
      <picture file="pictures/EventlogTable-DescriptiveMode.png">
	<guilabel>Descriptive</guilabel> notation
      </picture>
    </sect2>
    <sect2>
      <title>Name Mode</title>
      <para>
	There are three different ways to display names in the Eventlog table, it is
	configurable by the <guilabel>Name Mode</guilabel> <icon name="namemode.gif"/>
	option. Full path and full name shows what you would expect. The smart mode uses
	the context where the line is to decide whether a full path or a full name should
	be displayed. For each event line this mode always displays the full path. For all
	other lines, if the name is the same as the enclosing event's module name, then it
	shows the full name only. This choice makes lines shorter and allows faster
	reading.
      </para>
    </sect2>
    <sect2>
      <title>Type Mode</title>
      <para>
	The option called <guilabel>Type Mode</guilabel> can be used to switch between
	displaying the C++ class name or the NED type name in parenthesis just before the
	name of modules. This is rarely used so only available from the context menu.
      </para>
    </sect2>
    <sect2>
      <title>Line Filter</title>
      <para>
	The Eventlog Table may be filtered by using the <guilabel>Line Filter</guilabel>
	<icon name="LineFilterMode.png"/> button on the toolbar. This option allows
	filtering for lines with specific kinds. There are some predefined filters,
      </para>
      <para>
	You can also provide a custom filter pattern, referring to fields present in
	<guilabel>Raw</guilabel> mode, using a match expresssion. The following example is
	a custom filter, which will show message sends where the message's class is
	AirFrame. <screen>BS and c(AirFrame)</screen> Please refer to the OMNeT++ 4.0
	Manual for more details on match expressions.
      </para>
      <note>
	To avoid confusion, event lines marked with green circles <icon name="event.png"/>
	are always shown in the Eventlog Table independently of the line filter.
      </note>
    </sect2>
    <sect2>
      <title>Navigation</title>
      <para>
	You can navigate using the standard keyboard and mouse gestrures just like in any
	other table. There are a couple of non standard navigation options in the context
	menu, which can also be used with the keyboard.
      </para>
      <para>
	The simplest are the <guilabel>Goto Event</guilabel> and the <guilabel>Goto
	Simulation Time</guilabel>, both of which simply jump to the given location.
      </para>
      <para>
	There are navigation options to go to the previous (<keycap>ALT+UP</keycap>) or
	next (<keycap>ALT+DOWN</keycap>) event in general, and to go to the previous
	(<keycap>SHIFT+UP</keycap>) or next (<keycap>SHIFT+DOWN</keycap>) event in the
	same module.
      </para>
      <para>
	Some of the navigation options focus on the causes of events and consequences of
	message sends. To go to the cause event, press <keycap>CTRL+UP</keycap>, and to go
	to the arrival of a message send, press <keycap>CTRL+DOWN</keycap>, while the
	selection is on the message being sent.
      </para>
      <para>
	Finally, there are navigation options for message reuse relationships. You can go
	the origin event of a message from the line where it was being reused. In the
	other direction, you can go to the reuser event of a message from the event where
	it was received. These options are enabled only if they actually makes sense for
	the current selection.
      </para>
      <picture file="pictures/EventlogTable-NavigationMenu.png">Navigation context menu</picture>
    </sect2>
    <sect2>
      <title>Selection</title>
      <para>
	The Eventlog Table uses multiple selection even though most of the user commands
	require single selection.
      </para>
    </sect2>
    <sect2>
      <title>Searching</title>
      <para>
	For performance reasons, the search <icon name="Search.gif"/> function works
	directly on the eventlog file and not the text displayed in the Eventlog table. It
	means that some static text present in <guilabel>Descriptive</guilabel> mode
	cannot be found. Usually it is easier to figure out what to search for in
	<guilabel>Raw</guilabel> mode, where the eventlog file's content is directly
	displayed. The search can work in both directions starting from the current
	selection, and may be case insensitive. To repeat the last search, use the
	<guilabel>Find Next</guilabel> <icon name="SearchNext.gif"/> command.
      </para>
    </sect2>
    <sect2>
      <title>Bookmarks</title>
      <para>
	For easier navigation, the Eventlog table supports navigation history. This is
	accessible from the standard IDE toolbar just like for other kind of editors. It
	works by remembering each position where the user stayed more than 3 seconds. The
	navigation history is temporary, and thus it is not saved when the file is closed.
      </para>
      <para>
	Persistent bookmarks <icon name="bkmrk_nav.gif"/> are also supported, and they can
	be added from the context menu. A Bookmarked event is highlighted with a different
	background color.
      </para>
      <picture file="pictures/EventlogTable-Bookmark.png">A bookmark</picture>
      <para>
	To jump to a bookmark, use the standard bookmark view possibly even after
	restarting the IDE.
      </para>
    </sect2>
    <sect2>
      <title>Tooltips</title>
      <para>
	At the moment only the message send lines might have tooltips. If message detail
	recording was configured for the simulation, then a tooltip will show the recorded
	content of a message send over the corresponding line.
      </para>
      <picture file="pictures/EventlogTable-Tooltip.png">A message send tooltip</picture>
    </sect2>
    <sect2>
      <title>Associated Views</title>
      <para>
	When you open an eventlog file in the Eventlog Table editor, it will automatically
	open the Sequence Chart view with the same file. If you select an event on the
	Eventlog Table editor, then the Sequence Chart view will jump to the same event
	and vice versa. This interconnection makes navigation easier, and you can
	immediately see the cause and consequence relationships of the selected event.
      </para>
    </sect2>
    <sect2>
      <title>Filtering</title>
      <para>
	If the Eventlog Table displays a filtered eventlog, then subsequent events may not
	have subsequent event numbers, which means that the events in between have been
	filtered out. At the extreme, the table may even become empty, which means that
	there are no matching events at all.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Filter Dialog</title>
    <para>
      The content of an eventlog can be filtered within the OMNeT++ IDE. This is called on
      the fly filtering as opposed to the file content filtering provided by the Eventlog
      Tool. To use on the fly filtering, open the filter configuration dialog with the
      button <icon name="Filter.png"/> on the toolbar, enable some of the range, module,
      message, or trace filters, set the various filter parameters, and apply it. The
      result is another eventlog resident in memory, where some events are filtered out.
      <note>
	Similarly to the command line Eventlog Tool, described in the OMNeT++ 4.0 Manual,
	the in memory filtering can only filter out whole events.
      </note>
    </para>
    <para>
      In memory, on the fly filtering means that the filter's result is not saved into an
      eventlog file, but it is rather lazily computed and stored within memory. This
      allows rapid switching between different views of the same eventlog within both the
      Sequence Chart and the Eventlog Table.
    </para>
    <para>
      The filter configuration dialog shown in <xref
      linkend="SequenceChart-FilterDialog.png"/> has many options, they are organized into
      a tree each restricting the eventlog's content on its own. The individual filter
      components may be turned on and off independently of each other. This allows
      remembering the filter settings even if some of them are temporarily not used.
    </para>
    <para>
      The combination of various filter options might be complicated and hard to
      understand. To make it easier, the <guilabel>Filter Dialog</guilabel> automatically
      displays the current filter in a human readable form at the bottom of the dialog.
    </para>
    <picture file="SequenceChart-FilterDialog.png">
      Filter Dialog
    </picture>
    <sect2>
      <title>Range filter</title>
      <para>
	This is the simplest one, which filters out events from the beginning, and from
	the end of the eventlog. It might help to reduce the computation time dramatically
	when defining filters, which otherwise would be very expensive to compute for the
	whole eventlog file.
      </para>
    </sect2>
    <sect2>
      <title>Module filter</title>
      <para>
	With this kind of filter you can filter out events that did not occur in any of
	the specified modules. The modules which will be included in the result can be
	selected by their NED type, full path, module id, or by a match expression. The
	expression may refer to the raw data present in the lines marked with 'MC' in the
	eventlog file.
      </para>
    </sect2>
    <sect2>
      <title>Message filter</title>
      <para>
	This filter is the most complicated one. It allows filtering for events, which
	either process or send specific messages. The messages can be selected based on
	their C++ class name, message name, various message ids, and a match expression.
	The expression may refer to the raw data present in the lines marked with 'BS' in
	the eventlog file.
      </para>
      <para>
	There are four different message ids to filter for, each with different
	characteristics. The most basic one is the id, which is unique for each
	constructed message independently of how it was created. The tree id is special in
	that it gets copied over when a message is created by copying (duplicating)
	another. The encapsulation id is different in that it gives the id of the
	innermost encapsulated message. Finally, the encapsulation tree id combines the
	two by providing the innermost encapsulated message's tree id.
      </para>
    </sect2>
    <sect2>
      <title>Tracing causes/consequeces</title>
      <para>
	The trace filter allows filtering for causes and consequence of a particular event
	specified by its event number. The cause/consequence relation between two events
	means that there is a message send/resuse path from the cause event to the
	consequence event. If there was a message reuse in the path, then the whole path
	is considered to be a message reuse itself.
      </para>
      <warning>
	Since computing the causes and consequences far away in the eventlog file from the
	traced event might be a time consuming task, there are extra range limits around
	the traced event to be set. These limits are separate from the range filter due to
	being relative to the traced event. This means that if you change the traced event
	there is no need to change the range parameters. It is strongly recommended to
	provide these limits when tracing events to avoid long running operations.
      </warning>
    </sect2>
    <sect2>
      <title>Collection limits</title>
      <para>
	When an in memory filter is applied to an eventlog, it does not only filter out
	events, but it also provides automatic discovery for virtual message sends. It
	means that two events far away, and not directly related to each other, might have
	a virtual message send (or reuse) between them. Recall that there is a virtual
	message send (or reuse) between two events if and only if there is a path of
	message sends (or reuses) connecting the two.
      </para>
      <para>
	The process of collecting these virtual message dependencies is time consuming and
	thus has to be limited. There are two options, one of which limits the number of
	virtual message sends collected per event. The other one limits the depth of
	cause/consequence chains during collection.
      </para>
    </sect2>
    <sect2>
      <title>Long Running Operations</title>
      <para>
	Sometimes computing the filter's result takes a lot of time, especially when
	tracing causes/consequences without specifying proper range limits in terms of
	event numbers or simulation times. If you canel the long running operation, then
	you can go back to the <guilabel>Filter Dialog</guilabel> to modify the filter
	parameters, or simply turn it off. To restart drawing, use the refresh button
	<icon name="refresh.gif"/> on the toolbar.
	<tip>
	  Providing a proper range filter is always a good idea to speed up computing the
	  filter's result.
	</tip>
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Other features</title>
    <para>
      Both the Sequence Chart and the Eventlog Table tools can be used as an editor and
      also as a view. The difference between being an editor or a view is quite important,
      because there is only at most one instance of a view of the same kind. It means that
      even if multiple eventlog files are open in Sequence Chart editors, there are no
      more than one Eventlog Table views shared between them. This singleton view will
      automatically display the eventlog file of the active editor. It will also remember
      its position and state when switching among editors back and forth. For more details
      on what an editor and a view is, and what are the differences please refer to the
      Eclipse documentation.
      <note>
	Despite the name editor, which is a concept of the Eclipse platform, neither the
	Sequence Chart, nor the Eventlog Table can be used to actually change the contents
	of an eventlog file.
      </note>
    </para>
    <para>
      It is possible to open the same eventlog file in multiple editors, and to navigate
      to different locations, or use different diplay modes or filters in them. Once an
      eventlog is open in an editor, you can use the <guimenuitem>Window|New
      Editor</guimenuitem> to open it again.
      <tip>
	Dragging one of the editors from the tabbed pane to the side of the editors' area
	allows you to interact with the two simultaneously.
      </tip>
    </para>
    <sect2>
      <title>Settings</title>
      <para>
	There are various settings for both tools which affect the display, such as
	display modes, content position, filter parameters, etc. These user specified
	settings are automatically saved for each file, and they are reused whenever the
	file is visited again. The per file settings are stored under the OMNeT++
	workspace, in the directory
	<filename>.metadata\.plugins\org.eclipse.core.resources\.projects\&lt;project-name&gt;</filename>.
      </para>
    </sect2>
    <sect2>
      <title>Large File Support</title>
      <para>
	Since an eventlog file might be several Gbytes, both tools are designed in a way
	that allows efficiently displaying such a file without requiring large amounts of
	physical memory to load it at once. As you navigate through the file, physical
	memory is filled up with the content lazily. Since it is difficult to reliably
	identify when the system is going low on physical memory, it is up to the user to
	release the allocated memory when needed. This operation, although usually not
	required, is available from the context menu as <guimenuitem>Release
	Memory</guimenuitem>. It does not affect the user interface in any way.
      </para>
      <para>
	The fact that the eventlog file is loaded lazily and optionally filtered also
	means that the exact number of lines and events it contains cannot be cheaply
	determined. This affects the way scrollbars work in the lazy direction, horizontal
	for the Sequence Chart, and vertical for the Eventlog Table. Basically these
	scrollbars act as a non linear approximation in that direction. This is most of
	the time remains unnoticable for the user unless the file is really small.
      </para>
    </sect2>
    <sect2>
      <title>Viewing a running simulation's results</title>
      <para>
	Despite the simulation kernel keeps the eventlog file open for writing while the
	simulation is running, it may be open in the OMNeT++ IDE simultaneously. Both
	tools can be instructed by pressing the <keycap>END</keycap> key to follow the
	eventlog's end as new content is appended to it. If you pause the simulation in
	the runtime environment, then after a few seconds the tools will refresh their
	contents and jump to the very end. This process actually makes possible to follow
	the simulation on the Sequence Chart step-by-step.
      </para>
    </sect2>
    <sect2>
      <title>Caveats</title>
      <para>
	Sometimes drawing the Sequence Chart may take a lot of time. Zooming out too much,
	for example, might result in slow response times. A dialog might pop up telling
	that a long running eventlog operation is in progress. You can safely cancel these
	operations at any time you like, or just wait until they finish. To restart the
	rendering process, simply press the refresh button <icon name="refresh.gif"/> on
	the toolbar. Before actually doing that, it is a good idea to revert to some
	defaults (e.g. default zoom level) or revert the last changes (e.g. navigate back,
	turn filter off, etc.) and then try refreshing.
      </para>
      <warning>
	An opreration which runs for an unreasonable long time might be a sign of a
	problem that should be reported for further consideration.
      </warning>
    </sect2>
  </sect1>

</chapter>
