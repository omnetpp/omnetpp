#!/usr/bin/env perl
#
# Creates a makefile for a given OMNeT++/OMNEST model.
# Assumes that .ned, .msg, .cc and .h files are in one directory (or directory tree).
# The name of the program defaults to the name of the directory ('myproject').
#
# Author: Andras Varga
#

import os
import re
import argparse
from typing import List, Dict, Any
from builtins import isinstance
from configparser import ConfigParser
from pathlib import Path

progname = sys.argv[0]
is_windows = bool(os.environ.get('OS')) and 'windows' in os.environ['OS'].lower()
is_mingw = bool(os.environ.get('MSYSTEM')) and 'mingw' in os.environ['MSYSTEM'].lower()

def makemake():
    # code for makemake function goes here

parser = argparse.ArgumentParser(
    prog='makemake',
    description="Create a Makefile for an OMNeT++/OMNEST model, based on source files in current directory"
)

parser.add_argument('object_files_or_libraries', nargs='*', help="Object files or libraries")
parser.add_argument('-h', '--help', action='help', help="Show this help message and exit")
parser.add_argument('-f', '--force', action='store_true', help="Force overwriting existing Makefile")
parser.add_argument('-e', '--ext', help="C++ source file extension, usually 'cc' or 'cpp'")
parser.add_argument('-o', '--output', help="Name of simulation executable or library to be built")
parser.add_argument('-O', '--out', help="Specifies the name of the output directory tree for out-of-directory build")
parser.add_argument('--deep', action='store_true', help="Generates a 'deep' Makefile")
parser.add_argument('-r', '--recurse', action='store_true', help="Causes make to recursively descend into all subdirectories")
parser.add_argument('-X', '--except', dest="except", action="append", help="With -r and --deep option: ignore the given directory")
parser.add_argument('-d', '--subdir', dest="subdirs", action="append", help="Causes make to recursively descend into the given directory")
parser.add_argument('-P', '--projectdir', help="Specifies the project root directory")
parser.add_argument('-M', '--mode', help="Selects the build mode, 'debug' or 'release'")
parser.add_argument("-Kname=value", "--makefile-define", help="Defines a makefile variable, i.e. causes name=value line to get inserted into the makefile.")
parser.add_argument("-n", "--nolink", action="store_true", help="Produce object files but do not create executable or library. Useful for models with parts in several directories. With this option, -u and -l have no effect.")
parser.add_argument("-s", "--make-so", action="store_true", help="Build shared library (.so or .dll). Useful if you want to load the model dynamically (via the load-libs= omnetpp.ini or the -l Cmdenv/Qtenv command-line option).")
parser.add_argument("-a", "--make-lib", action="store_true", help="Create static library (.a or .lib).")
parser.add_argument("-S", "--fordll", action="store_true", help="Compile C++ files for use in DLLs; see -p option. The -s (build shared library) option implies this one.")
parser.add_argument("-w", "--withobjects", action="store_true", help="Link with all object files found in -I directories, or add them to the created library. OBSOLETE.")
parser.add_argument("-u", "--userinterface", help="Selects the user interface libraries to link with. Possible values are 'all', 'Cmdenv', 'Qtenv'. Defaults to 'all'.")
parser.add_argument("-I", dest="include_dirs", action="append", help="Additional NED and C++ include directory")
parser.add_argument("-L", dest="library_dirs", action="append", help="Add a directory to the library path")
parser.add_argument("-l", dest="libraries", action="append", help="Additional library to link against")
parser.add_argument("-p", "--symbol", help="DLL export/import symbol")
parser.add_argument("-i", "--includefragment", help="Append file to near end of Makefile")

# TODO add to the parser help:
"""
    object file or library
                          Arguments will simply get added to the linker (or
                          librarian) command line. Thus, wildcards and macros
                          are accepted, and will be resolved at build time.
                          Useful macros are \$O (the output location of this
                          makefile), \$(PROJECT_OUTPUT_PATH) and \$(CONFIGNAME);
                          see the generated makefiles for more. On Unix you
                          need to single-quote them ('\$O') against getting
                          resolved prematurely by the shell.

Default output is Makefile, which you can invoke by typing "make".

The contents of the makefrag file will be built into the generated makefile,
letting you to override the default target, change variables, etc.
"""

#
# Prepare the variables for the template
#

args = parser.parse_args()

makefile = "Makefile"
if os.path.isfile(makefile) and force != 1:
    error("use -f to force overwriting existing {}".format(makefile))

if type == "SHAREDLIB":
    compile_for_dll = 1

folder = os.getcwd()

objs = []
generated_headers = []
extra_objs = []
cc_files = []
cpp_files = []
ned_files = []
msg_files = []
msg_cc_files = []
msg_h_files = []
sm_files = []
sm_cc_files = []
sm_h_files = []
source_dirs = []
backslashed_source_dirs = []

# determine, and clean up format of project root dir
if project_dir == "":
    # try to find project root directory (go up until we find a ".project" file)
    dir = os.getcwd()
    dir = dir.replace("\\", "/")
    while True:
        if os.path.isfile("{}/.project".format(dir)):
            project_dir = dir
            break
        if "/" in dir:
            dir = dir[:dir.rindex("/")]
        else:
            project_dir = "."
            break
elif not os.path.isdir(project_dir):
    error("specified project directory \"{}\" does not exist".format(project_dir))

if project_dir != "":
    project_dir = existing_dirto_canonical_absolute(project_dir)
    #print "Project directory: $project_dir\n"
    if not (folder.startswith(project_dir)):
        error("current directory is not under the given project directory \"{}\"".format(project_dir))

project_name = project_dir
project_name = project_name.rstrip("/\\")
project_name = project_name[project_name.rindex("/\\")+1:]
target = target if target != "" else project_name

# target should only be a name, cannot contain relative path
if "\\" in target or "/" in target:
    error("target (-o option) should only be a name, it cannot contain relative path")

# recursive and deep do not mix
if is_deep:
    is_recursive = 0

makecommand = os.environ.get("MAKE") or "make"

# find Makefile.inc
comspec = os.environ.get("COMSPEC")
comspec = comspec.replace("\\", "\\\\")
config_file = os.popen("opp_configfilepath").read().strip()
if os.system("opp_configfilepath") != 0:
    error("opp_configfilepath returned nonzero exit code -- make sure it exists and is in the PATH")
if not config_file or not os.path.isfile(config_file):
    error("opp_configfilepath didn't return the name of an existing directory, result was \"{}\"".format(config_file))

# determine outdir (defaults to "out")
if out_root == "":
    out_root = "out"
out_root_abs = out_root if not is_relative(out_root) or project_dir == "" else "{}/{}".format(project_dir, out_root)
out_root_rel = abs2rel(out_root_abs, project_dir)
out_dir = canonicalize("{}".format(out_root_rel))

# determine subpath: the project-relative path of this folder
subpath = os.getcwd()
subpath = subpath.replace(project_dir, "", 1)
subpath = subpath.lstrip("/\\")  # remove the leading slash/backslash as this is a relative directory

# collect source files
if is_deep:
    all_excluded_dirs = [out_dir] + except_subdirs + submake_dirs
    source_dirs = collect_dirs(".", all_excluded_dirs)
    if len(source_dirs) > 10000:
        error("too many subdirs for --deep")
else:
    source_dirs = []
    if is_good_dir(".", except_subdirs):
        source_dirs = ["."]

for f in source_dirs:
    ff = "" if f == "." else f + "/"
    cc_files.extend(glob(ff + "*.cc"))
    cpp_files.extend(glob(ff + "*.cpp"))
    msg_files.extend(glob(ff + "*.msg"))
    sm_files.extend(glob(ff + "*.sm"))
    ned_files.extend(glob(ff + "*.ned"))

backslashed_source_dirs = []
for i in source_dirs:
    i2 = i.replace("/", "\\")
    backslashed_source_dirs.append(i2)

# include dirs and lib dirs (make them relative to the project dir)
include_dirs = [abs2rel(i, project_dir) for i in include_dirs]
lib_dirs = [abs2rel(i, project_dir) for i in lib_dirs]

# try to determine if .cc or .cpp files are used
if cc_ext == "":
    if not cc_files and cpp_files:
        cc_ext = "cpp"
    elif cc_files and not cpp_files:
        cc_ext = "cc"
    elif cc_files and cpp_files:
        error("you have both .cc and .cpp files -- specify -e cc or -e cpp option to select which set of files to use")
    else:
        cc_ext = "cc"  # if no files, use .cc extension
else:
    if cc_ext == "cc" and not cc_files and cpp_files:
        warning("you specified -e cc but you have only .cpp files!")
    if cc_ext == "cpp" and cc_files and not cpp_files:
        warning("you specified -e cpp but you have only .cc files!")

obj_ext = "o"

target_prefix = ""
target_suffix = ""
if type == "EXE":
    target_suffix = "$(EXE_SUFFIX)"
elif type == "SHAREDLIB":
    target_suffix = "$(SHARED_LIB_SUFFIX)"
    target_prefix = "$(LIB_PREFIX)"
elif type == "STATICLIB":
    target_suffix = "$(A_LIB_SUFFIX)"
    target_prefix = "$(LIB_PREFIX)"

# prepare submake_dirs. First, check that all specified subdirs exist
for subdir in submake_dirs:
    if not os.path.isdir(subdir):
        error("subdirectory '{}' does not exist".format(subdir))

if is_recursive:
    submake_dirs += [f for f in glob.glob("*") if is_good_dir(f, except_subdirs)]

# create names for subdir targets
submake_names = [re.sub(r"[^a-z_a-Z0-9_]", "_", i) for i in submake_dirs]

# process extra_args (do ".o" <--> ".obj" translation; NOTE: we don't try to
# translate library names, because libs are supposed to be given via -L/-l)
# NOTE2: we need to remove possible quotes (cmd.exe does not do it)
extra_objs = [i.replace("^'(.*)'$", r"\1").replace(r"\.o(bj)?$", ".obj_ext") for i in extra_args]

sources = []
if cc_ext == "cc":
    sources.extend(cc_files)
if cc_ext == "cpp":
    sources.extend(cpp_files)
sources.extend(msg_files)
sources.extend(sm_files)
if not ignore_ned_files:
    sources.extend(ned_files)

objs = [make_derived_file_name(f, obj_ext) for f in sources if not f.startswith("*") and not is_generated_ccfile(f, cc_ext)]

msg_cc_files = [make_derived_file_name(f, "cc") for f in msg_files]
msg_h_files = [make_derived_file_name(f, "h") for f in msg_files]
generated_headers += msg_h_files

sm_cc_files = [make_derived_file_name(f, "cc") for f in sm_files]
sm_h_files = [make_derived_file_name(f, "h") for f in sm_files]
generated_headers += sm_h_files

# makefrag files
makefrags = "";
if fragment_files:
    for frag in fragment_files:
        makefrags += "-include " + frag + "\n"
else:
    if os.path.isfile("makefrag"):
        makefrags += "-include makefrag\n"

# defines
if compile_for_dll and dll_symbol != "":
    defines.append(dll_symbol + "_EXPORT")

deps = ""  # we'll run opp_makedep afterwards

# XP has 8K limit on line length, so we may have to use the inline file feature of nmake
approximate_linker_line_length = 500 + len(quote_join(objs)) + len(quote_join(extra_objs)) + 2*len(quote_join(libs)) + 2*len(quote_join(lib_dirs))
is_long_linker_line = approximate_linker_line_length > 8000

# fill in template variables
m = {
    "lbrace" : "{",
    "rbrace" : "}",
    "targetprefix" : target_prefix,
    "target" :  target,
    "targetsuffix" : target_suffix,
    "outdir" : out_dir,
    "subpath" : subpath,
    "isdeep" : is_deep,
    "progname" : "opp_makemake",
    "args" : join(" ", args),
    "configfile" : config_file,
    "cc" : cc_ext,
    "deps" : deps,
    "exe" : type == "EXE",
    "sharedlib" : type == "SHAREDLIB",
    "staticlib" : type == "STATICLIB",
    "nolink" : type == "NOLINK",
    "defaultmode" : default_mode,
    "allenv" : user_interface.startswith('A'),
    "cmdenv" : user_interface.startswith('C'),
    "qtenv" : user_interface.startswith('Q'),
    "extraobjs" : quote_join(extra_objs),
    "includepath" : prefix_quote_join(include_dirs, "-I"),
    "libpathdirs" : lib_dirs,
    "libs" : libs,
    "defines" : prefix_quote_join(defines, "-D"),
    "makefilevariables" : makefile_variables,
    "makecommand" : makecommand,
    "makefile" : "Makefile",
    "makefrags" : makefrags,
    "msgccfiles" : msg_cc_files,
    "msghfiles" : msg_h_files,
    "msgfiles" : msg_files,
    "smccfiles" : sm_cc_files,
    "smhfiles" : sm_h_files,
    "smfiles" : sm_files,
    "objs" : quote_join(objs),
    "submakedirs" : submake_dirs,
    "submakenames" : submake_names,
    "dllsymbol" : dll_symbol,
    "sourcedirs" : source_dirs,
    "backslashedsourcedirs" : backslashed_source_dirs,
    "gcclongline" : (is_long_linker_line and is_windows)
}

content = substitute_into_template(template(), m, "{", "}")

old_content = read_text_file(makefile) if os.path.exists(makefile) else "";

if content != old_content:
    print(("Updating" if os.path.exists(makefile) else "Creating") + makefile + " in " + folder + "...\n")
    with fopen(makefile, "w") as f:
        print(content, file=f)

def is_generated_ccfile(f, cc_ext):
    return f.endswith("_n."+cc_ext) or f.endswith("_m."+cc_ext) or f.endswith("_sm."+cc_ext)

def make_derived_file_name(fname, ext):
    if fname.endswith(".ned"):
        return fname[:-4] + "_n." + ext
    elif fname.endswith(".msg"):
        return fname[:-4] + "_m." + ext
    elif fname.endswith(".sm"):
        return fname[:-3] + "_sm." + ext
    elif fname.endswith("." + cc_ext):
        return fname[:-len(cc_ext)-1] + "." + ext
    else:
        return re.sub(r"\.[^.]+$", "." + ext, fname)

def collect_dirs(dir, except_dirs=None):
    except_dirs = except_dirs or []
    result = []
    if is_good_dir(dir, except_dirs):
        result.append(canonicalize(dir))
        for f in glob.glob(f"{dir}/*"):
            result.extend(collect_dirs(f, except_dirs))
    return result

def is_good_dir(dirpath, except_dirs=None):
    except_dirs = except_dirs or []
    if not os.path.isdir(dirpath):
        return False

    # skip dot directories, also CVS, SVN, etc aux dirs
    IGNORABLE_DIRS = ["CVS", "RCS", "SCCS", "_darcs", "blib", ".git", ".svn", ".git", ".bzr", ".hg", "backups"]

    dirname = os.path.basename(dirpath)
    if dirname.startswith(".") or dirname in IGNORABLE_DIRS:
        return False

    # check exceptdirs. For that, we convert everything to canonical absolute path
    abs_dir = existing_dir_to_canonical_absolute(dirpath)
    for except_dir_pattern in except_dirs:
        for except_dir in glob.glob(except_dir_pattern):
            if os.path.isdir(except_dir):
                abs_except_dir = existing_dir_to_canonical_absolute(except_dir)
                if abs_dir == abs_except_dir:
                    return False

    return True

#
# Performs template substitution. Constructs understood are:
#  - {foo} gets replaced by the value of "foo";
#  - {bar?some text} gets replaced by "some text" if value of "bar" is true*.
#  - {~bar?some text} gets replaced by "some text" if value of "bar" is false*
#  - {bar:} only keep the rest of the line if value of "bar" is true*
#  - {~bar:} only keep the rest of the line if value of "bar" is false*
#  - {@i1:list1,i2:list2,...} ... {i1} ...{/@}  parallel iteration list1, list2 etc.
# * true/false are interpreted as in Perl: "" and "0" are false, everything else is true.
#
# Newlines inside {...} are not permitted; this allows detecting errors caused
# by misplaced braces. Also, nesting is not supported.
#
# Lines starting with ### treated as comments and will be removed from the output
#
def substitute_into_template(template: str, mapref: dict, start_tag: str = '{', end_tag: str = '}') -> str:
    # remove whole-line comments
    template = re.sub(r'\n[ \t]*###.*\n', '\n', template)
    # remove end-line comments
    template = re.sub(r'[ \t]*###.*\n', '\n', template)

    buf = ""
    start_tag_len = len(start_tag)
    end_tag_len = len(end_tag)

    current = 0
    while True:
        start = template.find(start_tag, current)
        if start == -1:
            break
        else:
            end = template.find(end_tag, start)
            if end != -1:
                end += end_tag_len
                tag = template[start:end]
                #print("processing $tag\n")
                key = template[start+start_tag_len:end-end_tag_len]
                if "\n" in key:
                    raise ValueError("template error: newline inside \"{}\" (misplaced start/end tag?)".format(tag))
                is_loop = key[0] == "@"
                if is_loop:
                    key = key[1:]  # drop "@"
                is_negated = key[0] == "~"
                if is_negated:
                    key = key[1:]  # drop "~"
                is_opt_line = key[-1] == ":" and "?" not in key
                if is_opt_line:
                    key = key[:-1]  # drop trailing ":"
                questionmark_pos = key.find("?")
                substring_after_questionmark = "" if questionmark_pos == -1 else key[questionmark_pos+1:]
                if questionmark_pos != -1:
                    key = key[:questionmark_pos] # drop "?..." from key

                # determine replacement string, and possibly adjust start/end
                replacement = ""
                if is_loop:
                    # basic loop syntax: {@i:list1,j:list2,...} ... {i} ... {/@}
                    # this is parallel iteration, not nested loops!
                    # first, find loop close tag {/@}
                    loop_end_tag = f"{start_tag}/@{end_tag}" # "{/var}"
                    balance = 1
                    pos = end - 1  # because we'll start with +1
                    while balance != 0:
                        pos = index_of_either(template, f"{start_tag}@", loop_end_tag, pos + 1)
                        if pos == -1:
                            error(f"template error: missing loop end marker {loop_end_tag}")
                        is_start_tag = template[pos + start_tag_len : pos + start_tag_len + 1] == "@"
                        balance += 1 if is_start_tag else -1
                    loop_end_pos = pos
                    loop_body = template[end:loop_end_pos]
                    end = loop_end_pos + len(loop_end_tag)
                    # parse loop spec: "i:list1,j:list2,..."
                    loop_vars = []
                    loop_lists = []
                    for loop_spec in key.split(","):
                        if not re.match(r" *([a-z_a-Z0-9_]+) *: *([a-z_a-Z0-9_]+) */", loop_spec):
                            error(f"template error: syntax error in loop tag {tag}, {start_tag}@var1:list1,var2:list2,...{end_tag} expected in body")
                        loop_vars.append($1)
                        loop_lists.append($2)
                    # execute loop: iterate in parallel on all loop variables
                    length = len(get_from_map_as_list(map, loop_lists[0]))
                    for i in range(length):
                        for j in range(len(loop_vars)):
                            loop_var_j = loop_vars[j]
                            loop_list_j = get_from_map_as_list(map, loop_lists[j])
                            if len(loop_list_j) != length:
                                raise ValueError("template error: list lengths differ in {}".format(tag))
                            map[loop_var_j] = loop_list_j[i]
                        replacement += substitute_into_template(loop_body, map, start_tag, end_tag)

                    # remove loop variables
                    for j in range(len(loop_vars)):
                        del map[loop_vars[j]]
                elif is_opt_line:
                    # replacing a whole line
                    condition = get_from_map_as_bool(map, key)
                    if (not condition if is_negated else condition):
                        # put line in: all variables OK
                        pass
                    else:
                        # omit line
                        end_line = template.index("\n", end)
                        if end_line == -1:
                            end_line = len(template)
                        replacement = ""
                        end = end_line + 1
                elif questionmark_pos != -1:
                    # conditional
                    replacement = (get_from_map_as_bool(map, key) != is_negated) ? substring_after_questionmark : ""
                else:
                    # plain replacement
                    if is_negated:
                        raise ValueError("template error: wrong syntax \"{}\" (possible missing \"?\")".format(tag))
                    replacement = get_from_map_as_string(map, key)

                # do it: replace substring(start, end) with replacement, unless replacement==null
                buf += substr2(template, current, start)  # template code up to the {...}
                buf += replacement
                current = end

    buf += template[current:]  # rest of the template
    buf = re.sub(r" +\n", "\n", buf)  # remove spaces at line end
    buf = re.sub(r"\n\n\n+", "\n\n", buf)  # remove multiple empty lines
    return buf

def substr2(string: str, startoffset: int, endoffset: int) -> str:
    return string[startoffset:endoffset]

def quote_join(listref: List[str]) -> str:
    return prefix_quote_join(listref, "")

def prefix_quote_join(listref: List[str], prefix: str) -> str:
    list = listref[:]  # make a copy of the list
    sep = " \\\n    " if len(list) > 5 else " "
    result = ""
    for i in list:
        result += sep + prefix + quote(i)
    return result if result != "" else ""  # chop off leading space

def index_of_either(template: str, substring1: str, substring2: str, from_: int) -> int:
    index1 = template.index(substring1, from_)
    index2 = template.index(substring2, from_)
    return index2 if index1 == -1 else index1 if index2 == -1 else index1 if index1 < index2 else index2

# for substitute_into_template()
def get_from_map_as_string(mapref: Dict[str, Any], key: str) -> str:
    map = mapref.copy()
    if key not in map:
        raise Exception("template error: undefined template parameter '" + key + "'")
    return map[key]

# for substitute_into_template()
def get_from_map_as_bool(mapref: Dict[str, Any], key: str) -> bool:
    map = mapref.copy()
    if key not in map:
        raise Exception("template error: undefined template parameter '" + key + "'")
    value = map[key]

    if isinstance(value, list):
        return bool(len(value))  # True if list is non-empty, False otherwise
    else:
        return value

# for substitute_into_template()
def get_from_map_as_list(mapref, key):
    map = mapref
    if key not in map:
        raise KeyError(f"template error: undefined template parameter '{key}'")
    value = map[key]
    if not isinstance(value, list):
        raise TypeError(f"template error: list value expected for template parameter '{key}', got '{value}'")
    return value

#
# Converts absolute path $inputpath to relative path (relative to the current
# directory $referencedir), provided that both $inputpath and $referencedir are under a
# "project base directory" $projectdir. Otherwise it returns the original path.
# All "\" are converted to "/".
#
def abs2rel(inputpath, projectdir=None, referencedir=None):
    if projectdir is None or projectdir == "":
        return inputpath
    if referencedir is None or referencedir == "":
        referencedir = os.getcwd()

    # some normalization
    inputpath = inputpath.replace("\\", "/")
    referencedir = referencedir.replace("\\", "/")
    projectdir = projectdir.replace("\\", "/")

    inputpath = re.sub(r"/\./", "/", inputpath)
    referencedir = re.sub(r"/\./", "/", referencedir)
    projectdir = re.sub(r"/\./", "/", projectdir)

    inputpath = re.sub(r"//+", "/", inputpath)
    referencedir = re.sub(r"//+", "/", referencedir)
    projectdir = re.sub(r"//+", "/", projectdir)

    referencedir = re.sub(r"/*$", "/", referencedir)
    projectdir = re.sub(r"/*$", "/", projectdir)

    if not (inputpath.lower().startswith(projectdir.lower()) and referencedir.lower().startswith(projectdir.lower())):
        return inputpath

    while True:
        # keep cutting off common prefixes until no more
        match = re.match(r"^(.*?/)", inputpath)
        if not match:
            break
        prefix = match.group(1)
        if referencedir.lower().startswith(prefix.lower()):
            inputpath = re.sub(f"^{re.escape(prefix)}", "", inputpath, flags=re.IGNORECASE)
            referencedir = re.sub(f"^{re.escape(prefix)}", "", referencedir, flags=re.IGNORECASE)
        else:
            break

    # assemble relative path: change every directory name in $referencedir to "..",
    # then add $inputpath to it.
    referencedir = referencedir.replace(r'[^/]+', '..')
    rel = referencedir + inputpath

    return rel

def is_relative(path):
    # a path is absolute if it begins with "/" or "\", or contains ":/" or ":\"
    return not (path.startswith("/") or path.startswith("\\") or ":/" in path or ":\\" in path)

#
# Convert a path to an absolute path in canonical form.
# Path must point to a directory which currently exists.
#
def existing_dir_to_canonical_absolute(dir):
    if not os.path.isdir(dir):
        raise ValueError(f"argument must be an existing directory: {dir}")

    old = os.getcwd()
    os.chdir(dir)
    ret = os.getcwd()
    os.chdir(old)
    return ret

def canonicalize(path):
    path = path.replace("\\", "/")  # backslash -> fwd slash
    path = re.sub(r"//+", "/", path)  # xx//xx -> xx/xx
    path = re.sub(r"(/\.)+/", "/", path)  # xx/././xx -> xx/xx
    path = re.sub(r"^(\./)+", "", path) unless path == "./"  # ./xx -> xx
    path = re.sub(r"/$", "", path)  # xx/ -> xx

    # now we'll need to replace "/<subdir>/../" with "/" as many times as we can

    return path

def quote(dir):
    if " " in dir:
        dir = f"\"{dir}\""
    return dir

def read_text_file(file):
    with open(file, "r") as infile:
        content = infile.read()
    return content

def runprog(cmd):
    if os.name == "nt" and not os.environ.get("isMINGW"):
        os.system(os.environ["COMSPEC"], "/c", cmd)
    else:
        os.system(cmd)

def error(text):
    print(f"{progname}: error: {text}", file=sys.stderr)
    sys.exit(1)

def warning(text):
    print(f"{progname}: warning: {text}", file=sys.stderr)

def template():
    #
    # NOTE: the following template must be kept in sync with the file:
    # <omnetpp>/ui/org.omnetpp.cdt/src/org/omnetpp/cdt/makefile/Makefile.TEMPLATE
    #
    return r"""
#
# OMNeT++/OMNEST Makefile for {targetprefix}{target}
#
# This file was generated with the command:
#  {progname} {args}
#

### Some definitions first; note that we only print them if there're going to be needed
{~nolink:}# Name of target to be created (-o option)
{~nolink:}TARGET_DIR = .
{~nolink:}TARGET_NAME = {targetprefix}{target}$(D)
{~nolink:}TARGET = $(TARGET_NAME){targetsuffix}
{~nolink:}TARGET_IMPLIB = $(TARGET_NAME)$(IMPLIB_SUFFIX)
{~nolink:}TARGET_IMPDEF = $(TARGET_NAME)$(IMPDEF_SUFFIX)
{~nolink:}TARGET_FILES = $(TARGET_DIR)/$(TARGET)
{~nolink:}
{exe:}# User interface (uncomment one) (-u option)
{exe:}{~allenv?#}USERIF_LIBS = $(ALL_ENV_LIBS) # that is, $(QTENV_LIBS) $(CMDENV_LIBS)
{exe:}{~cmdenv?#}USERIF_LIBS = $(CMDENV_LIBS)
{exe:}{~qtenv?#}USERIF_LIBS = $(QTENV_LIBS)
{exe:}
{sourcedirs:}# C++ include paths (with -I)
{sourcedirs:}INCLUDE_PATH = {includepath}
{sourcedirs:}
{~nolink:}# Additional object and library files to link with
{~nolink:}EXTRA_OBJS = {extraobjs}
{~nolink:}
{~nolink:}{~staticlib:}# Additional libraries (-L, -l options)
{~nolink:}{~staticlib:}LIBS ={@dir:libpathdirs} $(LDFLAG_LIBPATH){dir}{/@} {@lib:libs} -l{lib}{/@}
{~nolink:}{~staticlib:}
# Output directory
### Note: these variables are public API (see help text), don't change
PROJECT_OUTPUT_DIR = {outdir}
PROJECTRELATIVE_PATH = {subpath}
O = $(PROJECT_OUTPUT_DIR)/$(CONFIGNAME)/$(PROJECTRELATIVE_PATH)

{sourcedirs:}# Object files for local .{cc}, .msg and .sm files
{sourcedirs:}OBJS = {objs}
{sourcedirs:}
{sourcedirs:}# Message files
{sourcedirs:}MSGFILES ={@msg:msgfiles} \
{sourcedirs:}    {msg}{/@}
{sourcedirs:}
{sourcedirs:}# SM files
{sourcedirs:}SMFILES ={@sm:smfiles} \
{sourcedirs:}    {sm}{/@}
{sourcedirs:}
{defaultmode:}# Default mode (-M option); can be overridden with make MODE=debug (or =release)
{defaultmode:}ifndef MODE
{defaultmode:}MODE = {defaultmode}
{defaultmode:}endif
{defaultmode:}
{makefilevariables:}# Other makefile variables (-K)
{@d:makefilevariables}{d}
{/@}

#------------------------------------------------------------------------------

# Pull in OMNeT++ configuration (Makefile.inc)

ifneq ("$(OMNETPP_CONFIGFILE)","")
CONFIGFILE = $(OMNETPP_CONFIGFILE)
else
CONFIGFILE = $(shell opp_configfilepath)
endif

ifeq ("$(wildcard $(CONFIGFILE))","")
$(error Config file '$(CONFIGFILE)' does not exist -- add the OMNeT++ bin directory to the path so that opp_configfilepath can be found, or set the OMNETPP_CONFIGFILE variable to point to Makefile.inc)
endif

include $(CONFIGFILE)

{~nolink:}{~staticlib:}# Simulation kernel and user interface libraries
{exe:}OMNETPP_LIBS = $(OPPMAIN_LIB) $(USERIF_LIBS) $(KERNEL_LIBS) $(SYS_LIBS)
{sharedlib:}OMNETPP_LIBS = -loppenvir$D $(KERNEL_LIBS) $(SYS_LIBS)
{~nolink:}{~staticlib:}{libpathdirs:}ifneq ($(PLATFORM),win32)
{~nolink:}{~staticlib:}{libpathdirs:}LIBS +={@dir:libpathdirs} -Wl,-rpath,$(abspath {dir}){/@}
{~nolink:}{~staticlib:}{libpathdirs:}endif

{sourcedirs:}COPTS = $(CFLAGS) $(IMPORT_DEFINES) {defines} $(INCLUDE_PATH) -I$(OMNETPP_INCL_DIR)
{sourcedirs:}MSGCOPTS = $(INCLUDE_PATH){dllsymbol? -P}{dllsymbol}{dllsymbol?_API}
{sourcedirs:}SMCOPTS =
{sourcedirs:}
# we want to recompile everything if COPTS changes,
# so we store COPTS into $COPTS_FILE (if COPTS has changed since last build)
# and make the object files depend on it
COPTS_FILE = $O/.last-copts
ifneq ("$(COPTS)","$(shell cat $(COPTS_FILE) 2>/dev/null || echo '')")
  $(shell $(MKPATH) "$O")
  $(file >$(COPTS_FILE),$(COPTS))
endif

{sharedlib:}# On Windows, the target has additional file(s). An import lib and an optional debug symbol file is created too.
{sharedlib:}ifeq ($(PLATFORM),win32)
{sharedlib:}  TARGET_FILES+= $(TARGET_DIR)/$(TARGET_IMPLIB)
{sharedlib:}  LDFLAGS+= $(LDFLAG_IMPLIB)$O/$(TARGET_IMPLIB)
{sharedlib:}  ifeq ($(TOOLCHAIN_NAME),clang-msabi)
{sharedlib:}    ifeq ($(MODE),debug)
{sharedlib:}      TARGET_FILES+=$(TARGET_DIR)/$(TARGET_NAME).pdb
{sharedlib:}    endif
{sharedlib:}  else
{sharedlib:}    TARGET_FILES+= $(TARGET_DIR)/$(TARGET_IMPDEF)
{sharedlib:}    LDFLAGS+= $(LDFLAG_IMPDEF)$O/$(TARGET_IMPDEF)
{sharedlib:}  endif
{sharedlib:}endif
{sharedlib:}
#------------------------------------------------------------------------------
# User-supplied makefile fragment(s)
{makefrags:}{makefrags}
#------------------------------------------------------------------------------

# Main target
{~nolink:}all: $(TARGET_FILES)
{~nolink:}
### Rules for $TARGET. Note that end product will be hardlinked into the
### TARGET_DIR (by default, the Makefile's directory); on systems that don't
### support soft links it will be copied.

### Copy binaries to their final destination from the out directory
$(TARGET_DIR)/% :: $O/%
	@mkdir -p $(TARGET_DIR)
	$(Q)$(LN) $< $@
ifeq ($(TOOLCHAIN_NAME),clang-msabi)
	-$(Q)-$(LN) $(<:%.dll=%.lib) $(@:%.dll=%.lib) 2>/dev/null

$O/$(TARGET_NAME).pdb: $O/$(TARGET)
endif

{exe:}$O/$(TARGET): {sourcedirs?$(OBJS)} {submakedirs?submakedirs} $(wildcard $(EXTRA_OBJS)) {makefile} $(CONFIGFILE)
{exe:}	@$(MKPATH) $O
{exe:}	@echo Creating executable: $@
{gcclongline:}{exe:}	$(Q)echo >.tmp$$$$ {sourcedirs?$(OBJS)} $(EXTRA_OBJS) && $(AR_CR) .tmplib$$$$ @.tmp$$$$ && $(CXX) -o $O/$(TARGET) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) .tmplib$$$$ $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS) $(LDFLAGS) && rm .tmp$$$$ && rm .tmplib$$$$
{~gcclongline:}{exe:}	$(Q)$(CXX) $(LDFLAGS) -o $O/$(TARGET) {sourcedirs?$(OBJS)} $(EXTRA_OBJS) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS)
{sharedlib:}$O/$(TARGET) $O/$(TARGET_IMPDEF) $O/$(TARGET_IMPLIB) &: {sourcedirs?$(OBJS)} {submakedirs?submakedirs} $(wildcard $(EXTRA_OBJS)) {makefile} $(CONFIGFILE)
{sharedlib:}	@$(MKPATH) $O
{sharedlib:}	@echo Creating shared library: $@
{gcclongline:}{sharedlib:}	$(Q)echo >.tmp$$$$ {sourcedirs?$(OBJS)} $(EXTRA_OBJS) && $(SHLIB_LD) -o $O/$(TARGET) @.tmp$$$$ $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS) $(LDFLAGS) ; rm .tmp$$$$
{~gcclongline:}{sharedlib:}	$(Q)$(SHLIB_LD) -o $O/$(TARGET) {sourcedirs?$(OBJS)} $(EXTRA_OBJS) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS) $(LDFLAGS)
{sharedlib:}	$(Q)$(SHLIB_POSTPROCESS) $O/$(TARGET)
{sharedlib:}ifeq ($(PLATFORM),win32)
{sharedlib:}	$(Q)llvm-ar d $O/$(TARGET_IMPLIB) $(TARGET) # WORKAROUND: throw away the first file from the archive to make the LLD generated import lib valid
{sharedlib:}endif
{staticlib:}$O/$(TARGET): {sourcedirs?$(OBJS)} {submakedirs?submakedirs} $(wildcard $(EXTRA_OBJS)) {makefile} $(CONFIGFILE)
{staticlib:}	@$(MKPATH) $O
{staticlib:}	@echo Creating static library: $@
{gcclongline:}{staticlib:}	$(Q)echo >.tmp$$$$ {sourcedirs?$(OBJS)} $(EXTRA_OBJS) && $(AR_CR) $O/$(TARGET) @.tmp$$$$ && rm .tmp$$$$
{~gcclongline:}{staticlib:}	$(Q)$(AR_CR) $O/$(TARGET) {sourcedirs?$(OBJS)} $(EXTRA_OBJS)
{nolink:}all: {sourcedirs?$(OBJS)} {submakedirs?submakedirs} {makefile} $(CONFIGFILE)
{nolink:}	@# Do nothing

{submakedirs:}submakedirs: {@i:submakenames} {i}_dir{/@}
{submakedirs:}
.PHONY: all clean cleanall depend msgheaders smheaders {@i:submakenames} {i}{/@}
{@i:submakenames}{i}: {i}_dir
{/@}
{submakedirs:}
{@i:submakenames,dir:submakedirs}{i}_dir:
	cd {dir} && $(MAKE) all

{/@}

{sourcedirs:}# disabling all implicit rules
{sourcedirs:}.SUFFIXES :
{sourcedirs:}
### Pattern rules for cc files.
{sourcedirs:}$O/%.o: %.{cc} $(COPTS_FILE) | msgheaders smheaders
{sourcedirs:}	@$(MKPATH) $(dir $@)
{sourcedirs:}	$(qecho) "$<"
{sourcedirs:}	$(Q)$(CXX) -c $(CXXFLAGS) $(COPTS) -o $@ $<
{@dir:sourcedirs,bsdir:backslashedsourcedirs}
{/@}
### Pattern rules for msg files.
{sourcedirs:}%_m.{cc} %_m.h: %.msg
{sourcedirs:}	$(qecho) MSGC: $<
{sourcedirs:}	$(Q)$(MSGC) -s _m.{cc} -MD -MP -MF $O/$(basename $<)_m.h.d $(MSGCOPTS) $?
{sourcedirs:}
{@msg:msgfiles,m_cc:msgccfiles,m_h:msghfiles}
{/@}
### Pattern rules for sm files.
{sourcedirs:}%_sm.{cc} %_sm.h: %.sm
{sourcedirs:}	$(qecho) SMC: $<
{sourcedirs:}	$(Q)$(SMC) -c++ -suffix {cc} $(SMCOPTS) $?
{sourcedirs:}
{@sm:smfiles,sm_cc:smccfiles,sm_h:smhfiles}
{/@}

### Utility target for running opp_msgc; otherwise unused by this makefile
msgheaders: {sourcedirs?$(MSGFILES:.msg=_m.h)}
{@i:submakedirs}	$(Q)cd {i} && $(MAKE) msgheaders
{/@}

### Utility target for running the SMC compiler; otherwise unused by this makefile
smheaders: {sourcedirs?$(SMFILES:.sm=_sm.h)}
{@i:submakedirs}	$(Q)cd {i} && $(MAKE) smheaders
{/@}

### clean, depend, etc.
clean:
	$(qecho) Cleaning $(TARGET)
	$(Q)-rm -rf $O  ### must be done separately, because it fails on MinGW ('rm' is bogus)
{~nolink:}	$(Q)-rm -f $(TARGET_FILES)
	$(Q)-rm -f $(call opp_rwildcard, . , *_m.{cc} *_m.h *_sm.{cc} *_sm.h)
{@i:submakedirs}	-$(Q)cd {i} && $(MAKE) clean
{/@}

cleanall:
	$(Q)$(CLEANALL_COMMAND)
	$(Q)-rm -rf $(PROJECT_OUTPUT_DIR)

help:
	@echo "$$HELP_SYNOPSYS"
	@echo "$$HELP_TARGETS"
	@echo "$$HELP_VARIABLES"
	@echo "$$HELP_EXAMPLES"

# include all dependencies
-include $(OBJS:%=%.d) $(MSGFILES:%.msg=$O/%_m.h.d)
"""