#
# OMNeT++/OMNEST Makefile for {targetprefix}{target}
#
# This file was generated with the command:
#  {progname} {args}
#

### Some definitions first; note that we only print them if there're going to be needed
{~nolink:}# Name of target to be created (-o option)
{~nolink:}TARGET = {targetprefix}{target}{targetsuffix}
{~nolink:}
{exe:}# User interface (uncomment one) (-u option)
{exe:}{~allenv?#}USERIF_LIBS = $(ALL_ENV_LIBS) # that is, $(TKENV_LIBS) $(QTENV_LIBS) $(CMDENV_LIBS)
{exe:}{~cmdenv?#}USERIF_LIBS = $(CMDENV_LIBS)
{exe:}{~tkenv?#}USERIF_LIBS = $(TKENV_LIBS)
{exe:}{~qtenv?#}USERIF_LIBS = $(QTENV_LIBS)
{exe:}
{sourcedirs:}# C++ include paths (with -I)
{sourcedirs:}INCLUDE_PATH = {includepath}
{sourcedirs:}
{~nolink:}# Additional object and library files to link with
{~nolink:}EXTRA_OBJS = {extraobjs}
{~nolink:}
{~nolink:}{~staticlib:}# Additional libraries (-L, -l options)
{~nolink:}{~staticlib:}LIBS ={@dir:libpathdirs} $(LDFLAG_LIBPATH){dir}{/@} {@lib:libs} -l{lib}{/@}
{~nolink:}{~staticlib:}
# Output directory
### Note: these variables are public API (see help text), don't change
PROJECT_OUTPUT_DIR = {outdir}
PROJECTRELATIVE_PATH = {subpath}
O = $(PROJECT_OUTPUT_DIR)/$(CONFIGNAME)/$(PROJECTRELATIVE_PATH)

{sourcedirs:}# Object files for local .{cc}, .msg and .sm files
{sourcedirs:}OBJS = {objs}
{sourcedirs:}
{sourcedirs:}# Message files
{sourcedirs:}MSGFILES ={@msg:msgfiles} \
{sourcedirs:}    {msg}{/@}
{sourcedirs:}
{sourcedirs:}# SM files
{sourcedirs:}SMFILES ={@sm:smfiles} \
{sourcedirs:}    {sm}{/@}
{sourcedirs:}
{defaultmode:}# Default mode (-M option); can be overridden with make MODE=debug (or =release)
{defaultmode:}ifndef MODE
{defaultmode:}MODE = {defaultmode}
{defaultmode:}endif
{defaultmode:}
{makefilevariables:}# Other makefile variables (-K)
{@d:makefilevariables}{d}
{/@}

#------------------------------------------------------------------------------

# Pull in OMNeT++ configuration (Makefile.inc)

ifneq ("$(OMNETPP_CONFIGFILE)","")
CONFIGFILE = $(OMNETPP_CONFIGFILE)
else
ifneq ("$(OMNETPP_ROOT)","")
CONFIGFILE = $(OMNETPP_ROOT)/Makefile.inc
else
CONFIGFILE = $(shell opp_configfilepath)
endif
endif

ifeq ("$(wildcard $(CONFIGFILE))","")
$(error Config file '$(CONFIGFILE)' does not exist -- add the OMNeT++ bin directory to the path so that opp_configfilepath can be found, or set the OMNETPP_CONFIGFILE variable to point to Makefile.inc)
endif

include $(CONFIGFILE)

### # Check that MODE is valid (not enabled, to allow implementing other MODEs)
### ifneq ($(MODE),"debug")
### ifneq ($(MODE),"release")
### $(error MODE must be "debug" or "release")
### endif
### endif

{~nolink:}{~staticlib:}# Simulation kernel and user interface libraries
{exe:}OMNETPP_LIBS = $(OPPMAIN_LIB) $(USERIF_LIBS) $(KERNEL_LIBS) $(SYS_LIBS)
{sharedlib:}OMNETPP_LIBS = -loppenvir$D $(KERNEL_LIBS) $(SYS_LIBS)
{~nolink:}{~staticlib:}{libpathdirs:}ifneq ($(TOOLCHAIN_NAME),clangc2)
{~nolink:}{~staticlib:}{libpathdirs:}LIBS +={@dir:libpathdirs} -Wl,-rpath,$(abspath {dir}){/@}
{~nolink:}{~staticlib:}{libpathdirs:}endif

{sourcedirs:}COPTS = $(CFLAGS) $(IMPORT_DEFINES) {defines} $(INCLUDE_PATH) -I$(OMNETPP_INCL_DIR)
{sourcedirs:}MSGCOPTS = $(INCLUDE_PATH){dllsymbol? -P}{dllsymbol}{dllsymbol?_API}
{sourcedirs:}SMCOPTS =
{sourcedirs:}
# we want to recompile everything if COPTS changes,
# so we store COPTS into $COPTS_FILE and have object
# files depend on it (except when "make depend" was called)
COPTS_FILE = $O/.last-copts
ifneq ("$(COPTS)","$(shell cat $(COPTS_FILE) 2>/dev/null || echo '')")
$(shell $(MKPATH) "$O" && echo "$(COPTS)" >$(COPTS_FILE))
endif

#------------------------------------------------------------------------------
# User-supplied makefile fragment(s)
# >>>
{makefrags:}{makefrags}
# <<<
#------------------------------------------------------------------------------

# Main target
{~nolink:}all: $O/$(TARGET)
{~nolink:}	$(Q)$(LN) $O/$(TARGET) .
{~nolink:}
### Rules for $TARGET. Note that end product will be softlinked into the
### Makefile's directory; on systems that don't support soft links it will
### be copied. Note that MinGW's "ln -s" also actually copies the file.
{exe:}$O/$(TARGET): {sourcedirs?$(OBJS)} {submakedirs?submakedirs} $(wildcard $(EXTRA_OBJS)) {makefile} $(CONFIGFILE)
{exe:}	@$(MKPATH) $O
{exe:}	@echo Creating executable: $@
{gcclongline:}{exe:}	$(Q)echo >.tmp$$$$ {sourcedirs?$(OBJS)} $(EXTRA_OBJS) && $(AR) .tmplib$$$$ @.tmp$$$$ && $(CXX) -o $O/$(TARGET) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) .tmplib$$$$ $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS) $(LDFLAGS) && rm .tmp$$$$ && rm .tmplib$$$$
{~gcclongline:}{exe:}	$(Q)$(CXX) $(LDFLAGS) -o $O/$(TARGET) {sourcedirs?$(OBJS)} $(EXTRA_OBJS) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS)
{sharedlib:}$O/$(TARGET): {sourcedirs?$(OBJS)} {submakedirs?submakedirs} $(wildcard $(EXTRA_OBJS)) {makefile} $(CONFIGFILE)
{sharedlib:}	@$(MKPATH) $O
{sharedlib:}	@echo Creating shared library: $@
{gcclongline:}{sharedlib:}	$(Q)echo >.tmp$$$$ {sourcedirs?$(OBJS)} $(EXTRA_OBJS) && $(AR) .tmplib$$$$ @.tmp$$$$ && $(SHLIB_LD) -o $O/$(TARGET) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) .tmplib$$$$ $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS) $(LDFLAGS) && rm .tmp$$$$ && rm .tmplib$$$$
{~gcclongline:}{sharedlib:}	$(Q)$(SHLIB_LD) -o $O/$(TARGET) {sourcedirs?$(OBJS)} $(EXTRA_OBJS) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS) $(LDFLAGS)
{sharedlib:}	$(Q)$(SHLIB_POSTPROCESS) $O/$(TARGET)
{staticlib:}$O/$(TARGET): {sourcedirs?$(OBJS)} {submakedirs?submakedirs} $(wildcard $(EXTRA_OBJS)) {makefile} $(CONFIGFILE)
{staticlib:}	@$(MKPATH) $O
{staticlib:}	@echo Creating static library: $@
{gcclongline:}{staticlib:}	$(Q)echo >.tmp$$$$ {sourcedirs?$(OBJS)} $(EXTRA_OBJS) && $(AR) $O/$(TARGET) @.tmp$$$$ && rm .tmp$$$$
{~gcclongline:}{staticlib:}	$(Q)$(AR) $O/$(TARGET) {sourcedirs?$(OBJS)} $(EXTRA_OBJS)
{nolink:}all: {sourcedirs?$(OBJS)} {submakedirs?submakedirs} {makefile} $(CONFIGFILE)
{nolink:}	@# Do nothing

{submakedirs:}submakedirs: {@i:submakenames} {i}_dir{/@}
{submakedirs:}
.PHONY: all clean cleanall depend msgheaders smheaders {@i:submakenames} {i}{/@}
{@i:submakenames}{i}: {i}_dir
{/@}
{submakedirs:}
{@i:submakenames,dir:submakedirs}{i}_dir:
	cd {dir} && $(MAKE) all

{/@}

{sourcedirs:}.SUFFIXES: .{cc}
{sourcedirs:}
### Pattern rules for cc files.
{sourcedirs:}$O/%.o: %.{cc} $(COPTS_FILE) | msgheaders smheaders
{sourcedirs:}	@$(MKPATH) $(dir $@)
{sourcedirs:}	$(qecho) "$<"
{sourcedirs:}	$(Q)$(CXX) -c $(CXXFLAGS) $(COPTS) -o $@ $<
{@dir:sourcedirs,bsdir:backslashedsourcedirs}
{/@}
### Pattern rules for msg files.
{sourcedirs:}%_m.{cc} %_m.h: %.msg
{sourcedirs:}	$(qecho) MSGC: $<
{sourcedirs:}	$(Q)$(MSGC) -s _m.{cc} $(MSGCOPTS) $?
{sourcedirs:}
{@msg:msgfiles,m_cc:msgccfiles,m_h:msghfiles}
{/@}
### Pattern rules for sm files.
{sourcedirs:}%_sm.{cc} %_sm.h: %.sm
{sourcedirs:}	$(qecho) SMC: $<
{sourcedirs:}	$(Q)$(SMC) -c++ -suffix {cc} $(SMCOPTS) $?
{sourcedirs:}
{@sm:smfiles,sm_cc:smccfiles,sm_h:smhfiles}
{/@}

### Utility target for running opp_msgc; otherwise unused by this makefile
msgheaders: {sourcedirs?$(MSGFILES:.msg=_m.h)}
{@i:submakedirs}	$(Q)cd {i} && $(MAKE) msgheaders
{/@}

### Utility target for running the SMC compiler; otherwise unused by this makefile
smheaders: {sourcedirs?$(SMFILES:.sm=_sm.h)}
{@i:submakedirs}	$(Q)cd {i} && $(MAKE) smheaders
{/@}

### clean, depend, etc.
clean:
	$(qecho) Cleaning...
	$(Q)-rm -rf $O  ### must be done separately, because it fails on MinGW ('rm' is bogus)
	$(Q)-rm -f {target} {target}.exe lib{target}.so lib{target}.a lib{target}.dll lib{target}.dylib
{@dir:sourcedirs}	$(Q)-rm -f {dir}/*_m.{cc} {dir}/*_m.h {dir}/*_sm.{cc} {dir}/*_sm.h
{/@}
{@i:submakedirs}	-$(Q)cd {i} && $(MAKE) clean
{/@}

cleanall: clean
	$(Q)-rm -rf $(PROJECT_OUTPUT_DIR)

# include all dependencies
-include $(OBJS:%.o=%.d)
