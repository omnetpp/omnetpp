#
# OMNeT++/OMNEST Makefile for {targetprefix}{target}
#
# This file was generated with the command:
#  {progname} {args}
#

### Some definitions first; note that we only print them if there're going to be needed
{~nolink:}# Name of target to be created (-o option)
{~nolink:}TARGET = {targetprefix}{target}{targetsuffix}
{~nolink:}
{exe:}# User interface (uncomment one) (-u option)
{exe:}{~allenv?#}USERIF_LIBS = $(ALL_ENV_LIBS) # that is, $(TKENV_LIBS) $(QTENV_LIBS) $(CMDENV_LIBS)
{exe:}{~cmdenv?#}USERIF_LIBS = $(CMDENV_LIBS)
{exe:}{~tkenv?#}USERIF_LIBS = $(TKENV_LIBS)
{exe:}{~qtenv?#}USERIF_LIBS = $(QTENV_LIBS)
{exe:}
{sourcedirs:}# C++ include paths (with -I)
{sourcedirs:}INCLUDE_PATH = {includepath}
{sourcedirs:}
{~nolink:}# Additional object and library files to link with
{~nolink:}EXTRA_OBJS = {extraobjs}
{~nolink:}
{~nolink:}{~staticlib:}# Additional libraries (-L, -l options)
{~nolink:}{~staticlib:}LIBS ={@dir:libpathdirs} {-L}{dir}{/@} {@lib:libs} {-l}{lib}{.lib}{/@}
{~nolink:}{~staticlib:}{libpathdirs:}{~nmake:}LIBS +={@dir:libpathdirs} -Wl,-rpath,`abspath {dir}`{/@}
{~nolink:}{~staticlib:}
# Output directory
### Note: these variables are public API (see help text), don't change
PROJECT_OUTPUT_DIR = {outdir}
PROJECTRELATIVE_PATH = {subpath}
O = $(PROJECT_OUTPUT_DIR)/$(CONFIGNAME)/$(PROJECTRELATIVE_PATH)

{sourcedirs:}# Object files for local .{cc}, .msg and .sm files
{sourcedirs:}OBJS = {objs}
{sourcedirs:}
{sourcedirs:}# Message files
{sourcedirs:}MSGFILES ={@msg:msgfiles} \
{sourcedirs:}    {msg}{/@}
{sourcedirs:}
{sourcedirs:}# SM files
{sourcedirs:}SMFILES ={@sm:smfiles} \
{sourcedirs:}    {sm}{/@}
{sourcedirs:}
{defaultmode:}# Default mode (-M option); can be overridden with {nmake?n}make MODE=debug (or =release)
{defaultmode:}{nmake?!}ifndef MODE
{defaultmode:}MODE = {defaultmode}
{defaultmode:}{nmake?!}endif
{defaultmode:}
{makefilevariables:}# Other makefile variables (-K)
{@d:makefilevariables}{d}
{/@}

{nmake:}MAKE=nmake -nologo -f Makefile.vc
{nmake:}
#------------------------------------------------------------------------------

# Pull in OMNeT++ configuration (Makefile.inc or configuser.vc)
{nmake:}!if "$(OMNETPP_CONFIGFILE)"!=""
{nmake:}CONFIGFILE = $(OMNETPP_CONFIGFILE)
{nmake:}!elseif "$(OMNETPP_ROOT)"!=""
{nmake:}CONFIGFILE = $(OMNETPP_ROOT)/configuser.vc
{nmake:}!else
{nmake:}CONFIGFILE = {configfile}
{nmake:}!endif
{nmake:}
{nmake:}!if !exist($(CONFIGFILE))
{nmake:}!error '$(CONFIGFILE)' does not exist -- set OMNETPP_ROOT or OMNETPP_CONFIGFILE to point to configuser.vc. From the IDE, set the OMNeT++ install location on the Window | Preferences dialog.
{nmake:}!endif
{nmake:}
{nmake:}!include $(CONFIGFILE)

{~nmake:}ifneq ("$(OMNETPP_CONFIGFILE)","")
{~nmake:}CONFIGFILE = $(OMNETPP_CONFIGFILE)
{~nmake:}else
{~nmake:}ifneq ("$(OMNETPP_ROOT)","")
{~nmake:}CONFIGFILE = $(OMNETPP_ROOT)/Makefile.inc
{~nmake:}else
{~nmake:}CONFIGFILE = $(shell opp_configfilepath)
{~nmake:}endif
{~nmake:}endif
{~nmake:}
{~nmake:}ifeq ("$(wildcard $(CONFIGFILE))","")
{~nmake:}$(error Config file '$(CONFIGFILE)' does not exist -- add the OMNeT++ bin directory to the path so that opp_configfilepath can be found, or set the OMNETPP_CONFIGFILE variable to point to Makefile.inc)
{~nmake:}endif
{~nmake:}
{~nmake:}include $(CONFIGFILE)

### # Check that MODE is valid (not enabled, to allow implementing other MODEs)
### {nmake:}!if "$(MODE)"!="debug" && "$(MODE)"!="release"
### {nmake:}error MODE must be "debug" or "release"
### {nmake:}!endif
### {~nmake:}ifneq ($(MODE),"debug")
### {~nmake:}ifneq ($(MODE),"release")
### {~nmake:}$(error MODE must be "debug" or "release")
### {~nmake:}endif
### {~nmake:}endif

{~nolink:}{~staticlib:}# Simulation kernel and user interface libraries
{~nolink:}{~staticlib:}OMNETPP_LIB_SUBDIR = $(OMNETPP_LIB_DIR)/$(TOOLCHAIN_NAME)
{exe:}OMNETPP_LIBS = {-L}"$(OMNETPP_LIB_SUBDIR)" {-L}"$(OMNETPP_LIB_DIR)" {-l}oppmain$D{.lib} $(USERIF_LIBS) $(KERNEL_LIBS) $(SYS_LIBS)
{sharedlib:}OMNETPP_LIBS = {-L}"$(OMNETPP_LIB_SUBDIR)" {-L}"$(OMNETPP_LIB_DIR)" {-l}oppenvir$D{.lib} $(KERNEL_LIBS) $(SYS_LIBS)

{sourcedirs:}COPTS = $(CFLAGS) {defines} $(INCLUDE_PATH) -I$(OMNETPP_INCL_DIR)
{sourcedirs:}MSGCOPTS = $(INCLUDE_PATH){dllsymbol? -P}{dllsymbol}{dllsymbol?_API}
{sourcedirs:}SMCOPTS =
{sourcedirs:}
{~nmake:}# we want to recompile everything if COPTS changes,
{~nmake:}# so we store COPTS into $COPTS_FILE and have object
{~nmake:}# files depend on it (except when "make depend" was called)
{~nmake:}COPTS_FILE = $O/.last-copts
{~nmake:}ifneq ($(MAKECMDGOALS),depend)
{~nmake:}ifneq ("$(COPTS)","$(shell cat $(COPTS_FILE) 2>/dev/null || echo '')")
{~nmake:}$(shell $(MKPATH) "$O" && echo "$(COPTS)" >$(COPTS_FILE))
{~nmake:}endif
{~nmake:}endif
{~nmake:}
#------------------------------------------------------------------------------
# User-supplied makefile fragment(s)
# >>>
{makefrags:}{makefrags}
# <<<
#------------------------------------------------------------------------------

# Main target
{~nolink:}all: $O/$(TARGET)
{~nolink:}{nmake:}	$(Q)copy $(O:/=\)\$(TARGET) . >NUL
{~nolink:}{nmake:}	-$(Q)copy $(O:/=\)\$(TARGET).manifest . >NUL
{sharedlib:}{nmake:}	-$(Q)copy $(O:/=\)\$(TARGET:.dll=.lib) . >NUL
{~nolink:}{~nmake:}	$(Q)$(LN) $O/$(TARGET) .
{~nolink:}
### Rules for $TARGET. Note that end product will be softlinked into the
### Makefile's directory; on systems that don't support soft links it will
### be copied. Note that MinGW's "ln -s" also actually copies the file.
{exe:}$O/$(TARGET): {sourcedirs?$(OBJS)} {submakedirs?submakedirs} {~nmake?$(wildcard }$(EXTRA_OBJS){~nmake?)} {makefile}
{exe:}{nmake:}	-@md $(O:/=\) 2>nul
{exe:}{~nmake:}	@$(MKPATH) $O
{exe:}	@echo Creating executable: $@
{gcclongline:}{exe:}	$(Q)echo >.tmp$$$$ {sourcedirs?$(OBJS)} $(EXTRA_OBJS) && $(AR) .tmplib$$$$ @.tmp$$$$ && $(CXX) {-out}$O/$(TARGET) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) .tmplib$$$$ $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS) $(LDFLAGS) && rm .tmp$$$$ && rm .tmplib$$$$
{~gcclongline:}{exe:}	$(Q)$({nmake?LINK}{~nmake?CXX}) $(LDFLAGS) {-out}$O/$(TARGET) {nmake_inlinefile} {sourcedirs?$(OBJS)} $(EXTRA_OBJS) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS) {nmake_inlineend}
{sharedlib:}$O/$(TARGET): {sourcedirs?$(OBJS)} {submakedirs?submakedirs} {~nmake?$(wildcard }$(EXTRA_OBJS){~nmake?)} {makefile}
{sharedlib:}{nmake:}	-@md $(O:/=\) 2>nul
{sharedlib:}{~nmake:}	@$(MKPATH) $O
{sharedlib:}{~nmake:}	@echo Creating shared library: $@
{gcclongline:}{sharedlib:}	$(Q)echo >.tmp$$$$ {sourcedirs?$(OBJS)} $(EXTRA_OBJS) && $(AR) .tmplib$$$$ @.tmp$$$$ && $(SHLIB_LD) {-out}$O/$(TARGET) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) .tmplib$$$$ $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS) $(LDFLAGS) && rm .tmp$$$$ && rm .tmplib$$$$
{~gcclongline:}{sharedlib:}	$(Q)$(SHLIB_LD) {-out}$O/$(TARGET) {nmake_inlinefile} {sourcedirs?$(OBJS)} $(EXTRA_OBJS) $(AS_NEEDED_OFF) $(WHOLE_ARCHIVE_ON) $(LIBS) $(WHOLE_ARCHIVE_OFF) $(OMNETPP_LIBS) $(LDFLAGS) {nmake_inlineend}
{sharedlib:}{~nmake:}	$(Q)$(SHLIB_POSTPROCESS) $O/$(TARGET)
{staticlib:}$O/$(TARGET): {sourcedirs?$(OBJS)} {submakedirs?submakedirs} {~nmake?$(wildcard }$(EXTRA_OBJS){~nmake?)} {makefile}
{staticlib:}{nmake:}	-@md $(O:/=\) 2>nul
{staticlib:}{~nmake:}	@$(MKPATH) $O
{staticlib:}{~nmake:}	@echo Creating static library: $@
{gcclongline:}{staticlib:}	$(Q)echo >.tmp$$$$ {sourcedirs?$(OBJS)} $(EXTRA_OBJS) && $(AR) $O/$(TARGET) @.tmp$$$$ && rm .tmp$$$$
{~gcclongline:}{staticlib:}	$(Q)$(AR) {nmake?/out:}$O/$(TARGET) {nmake_inlinefile} {sourcedirs?$(OBJS)} $(EXTRA_OBJS) {nmake_inlineend}
{nolink:}all: {sourcedirs?$(OBJS)} {submakedirs?submakedirs} {makefile}
{nolink:}	@{nmake?rem}{~nmake?#} Do nothing

### Subdir targets. Note that nmake.exe does not support .PHONY (that's why we need
### the *_dir targets), and does not print "Entering"/"Leaving" messages like gnu make.
{submakedirs:}submakedirs: {@i:submakenames} {i}_dir{/@}
{submakedirs:}
{~nmake:}.PHONY: all clean cleanall depend msgheaders smheaders {@i:submakenames} {i}{/@}
{~nmake:}{@i:submakenames}{i}: {i}_dir
{~nmake:}{/@}
{submakedirs:}
{@i:submakenames,dir:submakedirs}{i}_dir:
{nmake:}	echo [Entering {dir}] && cd {dir} && $(MAKE) all && echo [Leaving {dir}]
{~nmake:}	cd {dir} && $(MAKE) all

{/@}

{sourcedirs:}.SUFFIXES: .{cc}
{sourcedirs:}
### Pattern rules for cc files. For gnu make a single rule is enough;
### for nmake we need per-directory rules, plus one for "." (even though
### "." is in sourcedirs), because nmake doesn't recognize "$O/." as "$O"
{sourcedirs:}{~nmake:}$O/%.{obj}: %.{cc} $(COPTS_FILE)
{sourcedirs:}{~nmake:}	@$(MKPATH) $(dir $@)
{sourcedirs:}{~nmake:}	$(qecho) "$<"
{sourcedirs:}{~nmake:}	$(Q)$(CXX) -c $(CXXFLAGS) $(COPTS) -o $@ $<
{sourcedirs:}{nmake:}{lbrace}.{rbrace}.{cc}{lbrace}$O{rbrace}.{obj}:
{sourcedirs:}{nmake:}	-@md $(O:/=\) 2>nul
{sourcedirs:}{nmake:}	$(Q)$(CXX) -c $(CXXFLAGS) $(COPTS) /Fo"$@" -Tp $<
{@dir:sourcedirs,bsdir:backslashedsourcedirs}
{nmake:}{lbrace}{dir}{rbrace}.{cc}{lbrace}$O/{dir}{rbrace}.{obj}:
{nmake:}	-@md $(O:/=\)\{bsdir} 2>nul
{nmake:}	$(Q)$(CXX) -c $(CXXFLAGS) $(COPTS) /Fo"$@" -Tp $<
{/@}
### Pattern rules for msg files. For gnu make one rule is enough,
### nmake needs per-file rules
{sourcedirs:}{~nmake:}%_m.{cc} %_m.h: %.msg
{sourcedirs:}{~nmake:}	$(qecho) MSGC: $<
{sourcedirs:}{~nmake:}	$(Q)$(MSGC) -s _m.{cc} $(MSGCOPTS) $?
{sourcedirs:}{~nmake:}
{@msg:msgfiles,m_cc:msgccfiles,m_h:msghfiles}
{nmake:}{m_cc} {m_h} : {msg}
{nmake:}	$(qecho) MSGC: $@
{nmake:}	$(Q)$(MSGC:/=\) -s _m.{cc} $(MSGCOPTS) {msg}
{/@}
### Pattern rules for sm files. For gnu make one rule is enough,
### nmake needs per-file rules
{sourcedirs:}{~nmake:}%_sm.{cc} %_sm.h: %.sm
{sourcedirs:}{~nmake:}	$(qecho) SMC: $<
{sourcedirs:}{~nmake:}	$(Q)$(SMC) -c++ -suffix {cc} $(SMCOPTS) $?
{sourcedirs:}{~nmake:}
{@sm:smfiles,sm_cc:smccfiles,sm_h:smhfiles}
{nmake:}{sm_cc} {sm_h} : {sm}
{nmake:}	$(qecho) SMC: $@
{nmake:}	$(Q)$(SMC:/=\) -c++ -suffix {cc} $(SMCOPTS) {sm}
{/@}

### Utility target for running opp_msgc; otherwise unused by this makefile
msgheaders: {sourcedirs?$(MSGFILES:.msg=_m.h)}
{@i:submakedirs}	$(Q)cd {i} && $(MAKE) msgheaders
{/@}

### Utility target for running the SMC compiler; otherwise unused by this makefile
smheaders: {sourcedirs?$(SMFILES:.sm=_sm.h)}
{@i:submakedirs}	$(Q)cd {i} && $(MAKE) smheaders
{/@}

### clean, depend, etc.
clean:
	$(qecho) Cleaning...
{nmake:}	-$(Q)rmdir /s /q $(O:/=\) 2>nul
{nmake:}	-$(Q)del $(VC_AUX_FILES) 2>nul
{nmake:}{exe:}	-$(Q)del $(TARGET) $(TARGET:.exe=.lib) $(TARGET:.exe=.dll) 2>nul
{nmake:}{sharedlib:}	-$(Q)del $(TARGET) $(TARGET:.dll=.exe) $(TARGET:.dll=.lib) 2>nul
{nmake:}{staticlib:}	-$(Q)del $(TARGET) $(TARGET:.lib=.exe) $(TARGET:.lib=.dll) 2>nul
{nmake:}{nolink:}	-$(Q)del {target}.exe {target}.dll {target}.lib 2>nul
{~nmake:}	$(Q)-rm -rf $O  ### must be done separately, because it fails on MinGW ('rm' is bogus)
{~nmake:}	$(Q)-rm -f {target} {target}.exe lib{target}.so lib{target}.a lib{target}.dll lib{target}.dylib
{~nmake:}{@dir:sourcedirs}	$(Q)-rm -f {dir}/*_m.{cc} {dir}/*_m.h {dir}/*_sm.{cc} {dir}/*_sm.h
{~nmake:}{/@}
{nmake:}{@bsdir:backslashedsourcedirs}	-$(Q)del {bsdir}\*_m.{cc} {bsdir}\*_m.h {bsdir}\*_sm.{cc} {bsdir}\*_sm.h 2>nul
{nmake:}{/@}
{@i:submakedirs}	-$(Q)cd {i} && $(MAKE) clean
{/@}

cleanall: clean
{nmake:}	-$(Q)rmdir /s /q $(PROJECT_OUTPUT_DIR:/=\) 2>nul
{~nmake:}	$(Q)-rm -rf $(PROJECT_OUTPUT_DIR)

depend:
	$(qecho) Creating dependencies...
{sourcedirs:}	$(Q)$(MAKEDEPEND) $(INCLUDE_PATH) -f Makefile{nmake?.vc} -P{nmake?^}{~nmake?\$}$O/ -- $(MSG_CC_FILES) $(SM_CC_FILES) {@d:sourcedirs} {d}/*.{cc}{/@}
{@i:submakedirs}{nmake:}	-cd {i} && if exist Makefile.vc $(MAKE) depend
{~nmake:}	$(Q)-cd {i} && if [ -f Makefile ]; then $(MAKE) depend; fi
{/@}

{sourcedirs:}# DO NOT DELETE THIS LINE -- make depend depends on it.
{sourcedirs:}{deps}
